<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yangkuan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-18T08:05:42.326Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yang Kuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>感知机</title>
    <link href="http://yoursite.com/2019/09/17/%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <id>http://yoursite.com/2019/09/17/感知机/</id>
    <published>2019-09-17T13:21:02.000Z</published>
    <updated>2019-09-18T08:05:42.326Z</updated>
    
    <content type="html"><![CDATA[<p>感知机（<code>perceptron</code>）是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，取$+1$和$-1$二值。感知机对应于输入空间（特征空间）中将实例划分为正负两类的分离超平面，属于判别模型。<br><a id="more"></a> </p><h1 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>假设输入空间（特征空间）是$X\in{R^n}$，输出空间是$Y={+1,-1}$。输入$x\in{X}$表示实例的特征向量，对应于输入空间（特征空间）的点；输出$y\in{Y}$表示实例的类别。由输入空间到输出空间的如下函数  </p><p>$$<br>f(x)=sign(w\cdot{x}+b)<br>$$</p><p>称为感知机。其中，$w$和$b$为感知机模型的参数，$w\in{R^n}$叫作权值（weight）或权值向量（weight vector），$b\in{R}$叫作偏置（bias），$w\cdot{x}$表示$w$和$x$的内积。$sign$是符号函数，即  </p><p>$$<br>sign(x)= \begin{cases}<br>+1, &amp; x \geq 0 \<br>-1, &amp; x &lt; 0<br>\end{cases}<br>$$</p><p>感知机是一种线性分类模型，属于判别模型。感知机模型的空间假设是定义在特征空间中的所有线性分类模型（linear classification model）或线性分类器（linear classifier），即函数集合$f|f(x)=w\cdot{x}+b$。</p><p>感知机其实就是寻找一个超平面$w\cdot{x}+b=0$将特征空间划分成为两个部分。位于超平面两侧的点分别被分为正负两类。</p><h1 id="感知机学习策略"><a href="#感知机学习策略" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h1><h2 id="数据集的线性可分性定义"><a href="#数据集的线性可分性定义" class="headerlink" title="数据集的线性可分性定义"></a>数据集的线性可分性定义</h2><p>给定一个数据集   </p><p>$$<br>T={(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)},<br>$$</p><p>其中，$x_i\in{X}=R^n, y_i\in{Y}={+1,-1}, i=1,2,\cdots,N$，如果存在某个超平面能够将数据集的正实例点和负实例点完全正确地划分到超平面的两侧，即对所有$y_i=+1$的实例$i$，有$w\cdot{x}+b&gt;0$；对所有$y_i=-1$的实例$i$，有$w\cdot{x}+b&lt;0$，则称数据集$T$是线性可分数据集(linear separable data set)；否则称数据集$T$线性不可分。</p><h2 id="学习策略"><a href="#学习策略" class="headerlink" title="学习策略"></a>学习策略</h2><p>损失函数是误分类点到超平面$S$的总距离，首先写出输入空间$R^n$中任一点$x_0$到超平面$S$的距离：</p><p>$$<br>\frac{1}{||w||}|w\cdot{x_0}+b|<br>$$</p><p>其中，$||w||$是$w$的$L_2$范数。<br>其次，对于误分类的数据$(x_i,y_i)$来说，有$-y_i(w\cdot{x}+b)&gt;0$成立。因此误分类点$x_i$到超平面$S$的距离也可以表示成：</p><p>$$<br>-\frac{1}{||w||}y_i(w\cdot{x_i}+b)<br>$$</p><p>假设超平面$S$对应的误分类点集合为$M$，那么所有误分类点到超平面$S$的总距离为</p><p>$$<br>-\frac{1}{||w||}\sum_{x_i\in{M}}y_i(w\cdot{x_i}+b)<br>$$</p><p>不考虑$\frac{1}{||w||}$就得到了感知机学习的损失函数。  </p><p>给定训练数据集</p><p>$$<br>T={(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)},<br>$$<br>其中，$x_i\in{X}=R^n, y_i\in{Y}={+1,-1}, i=1,2,\cdots,N$。感知机$sign(w\cdot{x}+b)$学习的损失函数定义为</p><p>$$<br>L(w,b)=-\sum_{x_i\in{M}}y_i(w\cdot{x_i}+b)<br>$$<br>其中，$M$是误分类点的集合。</p><h1 id="感知机学习算法"><a href="#感知机学习算法" class="headerlink" title="感知机学习算法"></a>感知机学习算法</h1><p>感知机学习算法有原始形式和对偶形式两种。</p><h2 id="原始形式"><a href="#原始形式" class="headerlink" title="原始形式"></a>原始形式</h2><p>感知机学习算法是对以下最优化问题的算法。给定一个训练数据集</p><p>$$<br>T={(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)},<br>$$<br>其中，$x_i\in{X}=R^n, y_i\in{Y}={+1,-1}, i=1,2,\cdots,N$，求解参数$w,b$，使其为以下损失函数最小化问题的解  </p><p>$$<br>min_{w,b}L(w,b)=min_{w,b}-\sum_{x_i\in{M}}y_i(w\cdot{x_i}+b)<br>$$</p><p>其中，$M$是误分类点的集合。</p><p>感知机学习算法是误分类驱动的，具体采用随机梯度下降法（stochastic gradient descent）。</p><p><strong>感知机学习算法的原始形式</strong></p><p><strong>输入</strong>：训练数据集$T={(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)}$，<br>其中，$x_i\in{X}=R^n, y_i\in{Y}={+1,-1}, i=1,2,\cdots,N$；学习率$\eta(0&lt;\eta\le{1})$；<br><strong>输出</strong>：$w,b$；感知机模型$f(x)=sign(w\cdot{x}+b)$。<br>（1） 选取初值$w_0,b_0$；<br>（2） 在训练集中选取数据$(x_i,y_i)$；<br>（3） 如果$y_i(w\cdot{x}+b)\le{0}$，即$x_i$是误分类的点，那么  </p><p>$$<br>w\leftarrow{w+\eta{y_ix_i}}\<br>b\leftarrow{b+\eta{y_i}}<br>$$</p><p>（4） 转至(2)，直至训练集中没有误分类点</p><h2 id="算法收敛性"><a href="#算法收敛性" class="headerlink" title="算法收敛性"></a>算法收敛性</h2><p>证明对于线性可分的数据集感知机学习算法原始形式收敛，即经过有限次迭代可以得到一个将训练数据集完全正确划分的分离超平面及感知机模型。</p><p><strong>定理</strong> 设训练数据集$T={(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)}$是线性可分的，其中存在$x_i\in{X}=R^n, y_i\in{Y}={+1,-1}, i=1,2,\cdots,N$，则<br>（1）存在满足条件$||\hat{w}<em>{opt}||=1$的超平面$\hat{w}</em>{opt}\cdot{\hat{x}}=\hat{w}<em>{opt}\cdot{x}+b</em>{opt}$将训练数据集完全正确分开；且存在$\gamma&gt;0$，对所有$i=1,2,\cdots,N$  </p><p>$$<br>y_i(\hat{w}_{opt}\cdot{\hat{x_i}})=y_i(\hat{w}<em>{opt}\cdot{x}+b</em>{opt})\geq\gamma<br>$$</p><p>（2）令$R=max_{1\le{i}\le{N}}$，则感知机算法的原始形式在训练集上的误分类次数$k$满足不等式  </p><p>$$<br>k\le(\frac{R}{\gamma})^2<br>$$</p><p>即表示训练次数有上届，能够在有限次训练中找到将数据集完全正确划分的超平面。详细证明可以阅读《统计学习方法》。</p><h1 id="感知机学习算法的对偶形式"><a href="#感知机学习算法的对偶形式" class="headerlink" title="感知机学习算法的对偶形式"></a>感知机学习算法的对偶形式</h1><p>对偶形式的基本思想是将$w$和$b$表示成实例$x_i$和标记$y_i$的线性组合的形式，通过求解其系数而求得$w$和$b$。<br>对于误分类点，更新$w$和$b$如下：</p><p>$$<br>w\leftarrow{w+\eta{y_ix_i}}\<br>b\leftarrow{b+\eta{y_i}}<br>$$</p><p>逐步更新$w,b$，假设更新$n$次，则$w,b$关于$(x_i,y_i)$的增量分别是$\alpha_iy_ix_i$和$\alpha{y_i}$，这个$\alpha_i=n_i\eta$。这样从学习过程不难看出，最后学习到的$w,b$可以分别表示为</p><p>$$<br>w=\sum_{i=1}^N{\alpha_iy_ix_i}\<br>b=\sum_{i=1}^N{\alpha_iy_i}<br>$$</p><p>这里，$a_i\ge0,i=1,2,\cdots,N$，当$\eta=1$时，表示第$i$个实例点由于误分而进行更新的次数。实例点更新次数越多，意味着它距离分离超平面越近，也越难正确分类。</p><p><strong>感知机学习算法的对偶形式</strong></p><p><strong>输入</strong>：训练数据集$T={(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)}$，<br>其中，$x_i\in{X}=R^n, y_i\in{Y}={+1,-1}, i=1,2,\cdots,N$；学习率$\eta(0&lt;\eta\le{1})$；<br><strong>输出</strong>：$\alpha,b$；感知机模型$f(x)=sign({\sum_{j=1}^N{\alpha_jy_jx_j}}\cdot{x}+b)$。其中，$\alpha=(\alpha_1,\alpha_2,\cdots,\alpha_N)^T$。<br>（1）$\alpha\leftarrow0,b\leftarrow0$<br>（2）在训练集中选取数据$(x_i,y_i)$<br>（3）如果$y_i({\sum_{j=1}^N{\alpha_jy_jx_j}}\cdot{x}+b)\le0$  </p><p>$$<br>\alpha_i\leftarrow\alpha_i+\eta \<br>b\leftarrow{b+\eta{y_i}}<br>$$</p><p>（4）转至（2）直到没有误分类数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感知机（&lt;code&gt;perceptron&lt;/code&gt;）是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，取$+1$和$-1$二值。感知机对应于输入空间（特征空间）中将实例划分为正负两类的分离超平面，属于判别模型。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="统计学习" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>统计学习三要素</title>
    <link href="http://yoursite.com/2019/09/10/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E4%B8%89%E8%A6%81%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/09/10/统计学习三要素/</id>
    <published>2019-09-10T02:37:22.000Z</published>
    <updated>2019-09-10T05:23:20.318Z</updated>
    
    <content type="html"><![CDATA[<p>统计学习方法是由模型、策略和算法构成的，即统计学习方法由三要素构成，可以简单表示为：</p><p>$$<br>方法=模型+策略+算法<br>$$<br><a id="more"></a> </p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>统计学习首先要考虑的问题是学习什么样的模型。在监督学习过程中，模型就是所要学习的条件概率分布$P(Y/X)$或者决策函数$Y=f(X)$。模型的假设空间包含所有可能的条件概率分布或决策函数。  </p><p>对于决策函数是输入变量的线性函数的情况，模型的假设空间就是所有线性函数构成的函数集合。假设空间用$F$表示。假设空间可以定义为决策函数的集合</p><p>$$<br>F={f|Y=f(X)}<br>$$</p><p>其中，$X$和$Y$是定义在输入空间$\LARGE{x}$和输出空间$\LARGE{y}$上的变量。这时$F$通常是由一个参数向量决定的函数族：</p><p>$$<br>F={f|Y=f_\theta(X),\theta\in{R^n}}<br>$$<br>参数向量$\theta$取值于$n$维欧氏空间$R^n$，称为参数空间。</p><p>假设空间也可以定义为条件概率的集合</p><p>$$<br>F={P|P(Y/X)}<br>$$<br>其中，$X$和$Y$是定义在输入空间$\LARGE{x}$和输出空间$\LARGE{y}$上的随机变量。这时$F$通常是由一个参数向量决定的条件概率分布族：</p><p>$$<br>F={P|P_\theta(Y/X)}<br>$$</p><p>参数向量$\theta$取值于$n$维欧氏空间$R^n$，也称为参数空间。</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>有了模型的假设空间，统计学习接着需要考虑使用什么样的策略从假设空间中选取出最优的模型。  </p><p>首先引入损失函数与风险函数的概念，损失函数模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>监督学习问题是在假设空间$F$中选取模型$f$作为决策函数，对于给定的输入$X$，由$f(X)$给出相应的输出$Y$，这个输出的预测值$f(X)$与真实值$Y$可能一致也可能不一致，用一个损失函数(loss function)与代价函数(cost function)来度量错误的程度。损失函数是$f(X)$与$Y$的非负实值函数，记作$L(Y,f(X))$。</p><p>统计学习常用的损失函数有以下几种：<br>（1）0-1损失函数(0-1 loss function)  </p><p>$$<br>L(Y,f(X)) = \begin{cases}<br>1, &amp; Y \neq f(X) \<br>0, &amp; Y = f(X)<br>\end{cases}<br>$$</p><p>（2）平方损失函数(quadratic loss function)</p><p>$$<br>L(Y,f(X)) = (Y-f(X))^2<br>$$</p><p>（3）绝对损失函数(absolute loss function)</p><p>$$<br>L(Y,f(X)) = |Y-f(X)|<br>$$</p><p>（4）对数损失函数(logarithmic loss function)或者对数似然损失函数(log-likelihood loss function)</p><p>$$<br>L(Y,P(Y/X)) = -log{P(Y/X)}<br>$$</p><h3 id="风险函数"><a href="#风险函数" class="headerlink" title="风险函数"></a>风险函数</h3><p>损失函数值越小，模型就越好。由于模型的输入、输出$(X,Y)$是随机变量，遵循联合分布$P(X,Y)$，所以损失函数的期望是</p><p>$$<br>R_{exp}(f)=E_p[L(Y,f(X))]=\int_{\LARGE{x}\times\Large{y}}L(y,f(x))P(x,y)dxdy<br>$$</p><p>这是理论上$f(X)$关于联合分布$P(X,Y)$的平均意义下的损失，称为风险函数（risk function）或期望损失（expected loss）。学习的目标就是选择期望风险最小的模型。</p><p>给定一个训练数据集</p><p>$$<br>T={(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)}<br>$$</p><p>模型$f(X)$关于训练数据集的平均损失称为经验风险(empirical risk)或经验损失(empirical loss)，记作$R_{emp}$:</p><p>$$<br>R_{emp}(f)=\frac{1}{N}\sum_{i=1}^N{L(y_i,f(x_i))}<br>$$</p><p>期望风险$R_{exp}(f)$是模型关于联合分布的期望损失，经验风险$R_{emp}(f)$是模型关于训练样本集的平均损失。根据大数定律，当样本容量$N$趋于无穷时，经验风险$R_{emp}(f)$趋于期望风险$R_{exp}(f)$。但是现实中训练样本数目有限，甚至很小，所以用经验风险估计期望风险常常并不理想，需要对经验风险进行一定的矫正。</p><h3 id="经验风险最小化与结构风险最小化"><a href="#经验风险最小化与结构风险最小化" class="headerlink" title="经验风险最小化与结构风险最小化"></a>经验风险最小化与结构风险最小化</h3><p>在假设空间、损失函数以及训练数据集确定的情况下，经验风险函数式就可以确定。通过最小化经验风险就可以得到最优的模型。根据这一策略，按照经验风险最小化求最优模型就是求解最优化问题：</p><p>$$<br>min_{f\in{F}}\frac{1}{N}\sum_{i=1}^N{L(y_i,f(x_i))}<br>$$</p><p>其中，$F$是假设空间。</p><p>当样本容量足够大时，经验风险最小化能保证有很好的学习效果，在现实中被广泛采用。当样本容量很小的时候，经验风险最小化学习的效果就不一定很好，会产生过拟合现象。  </p><p>结构风险最小化(structural risk minimization,SRM)是为了防止过拟合而提出的策略。结构风险最小化等价于正则化(regularization)。结构风险在经验风险上加上表示模型复杂度的正则项(regularizer)或惩罚项(penalty term)。在假设空间、损失函数以及训练数据集确定的情况下，结构风险的定义是：</p><p>$$<br>R_{srm}(f)=\frac{1}{N}\sum_{i=1}^N{L(y_i,f(x_i))}+\lambda{J(f)}<br>$$</p><p>其中$J(f)$为模型的复杂度，是定义在假设空间$F$上的泛函。模型$f$越复杂，复杂度$J(f)$就越大。也就是说，复杂度表示了对复杂模型的惩罚。$\lambda\geq{0}$是系数，用以权衡经验风险和模型复杂度。结构风险小需要经验风险和模型复杂度同时小。</p><p>结构风险最小化的策略认为结构风险最小的模型就是最优的模型。所以求最优模型，就是求解以下问题：</p><p>$$<br>min_{f\in{F}}R_{srm}(f)=min_{f\in{F}}{\frac{1}{N}\sum_{i=1}^N{L(y_i,f(x_i))}+\lambda{J(f)}}<br>$$</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法是指学习模型的具体计算方法。统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后考虑用什么样的计算方法求解最优模型。</p><p>这时，统计学习问题归结为最优化问题，统计学习的算法称为求解最优化问题的算法。统计学习方法之间的不同，主要来自其模型、策略、算法的不同。确定里模型、策略、算法，统计学习的方法也就确定了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计学习方法是由模型、策略和算法构成的，即统计学习方法由三要素构成，可以简单表示为：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;方法=模型+策略+算法&lt;br&gt;$$&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="统计学习" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>统计学习方法概论</title>
    <link href="http://yoursite.com/2019/09/09/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/09/09/统计学习方法概论/</id>
    <published>2019-09-09T02:21:21.000Z</published>
    <updated>2019-09-10T02:37:38.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-统计学习"><a href="#1-统计学习" class="headerlink" title="1. 统计学习"></a>1. 统计学习</h1><p>统计学习（statistical learning）是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测人与分析的一门学科。</p><p>$$<br>已有数据\xrightarrow{构建}模型\xrightarrow{预测分析}数据<br>$$<br><a id="more"></a> </p><h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ul><li>统计学习以计算机与网络为平台，是构建在计算机及网络之上的；</li><li>统计学习以数据为研究对象，是数据驱动的学科；</li><li>统计学习的目的是对数据进行预测与分析；</li><li>统计学习以方法为中心，统计学习方法构建模型并应用模型进行预测与分析；</li><li>统计学习是概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域的交叉学科，并且在发展中逐步形成独自的理论体系与方法论。</li></ul><p>统计学习的对象是数据，统计学习从数据出发，提取数据的特征，抽取出数据的模型，发现数据中的知识，又回到对数据的分析与预测中。数据形式多样，包括存在于计算机及网络上的各种数字、文字、图像、音频、视频数据以及它们的组合。</p><h2 id="统计学习的前提"><a href="#统计学习的前提" class="headerlink" title="统计学习的前提"></a>统计学习的前提</h2><p>统计学习关于数据的基本假设是同类数据具有一定的统计规律性。这里的同类数据指的是具有某种共同性质的数据。由于它们具有统计规律性，所以可以用概率统计方法来加以处理。</p><h2 id="统计学习的目的"><a href="#统计学习的目的" class="headerlink" title="统计学习的目的"></a>统计学习的目的</h2><p>统计学习用于对数据进行预测和分析，特别是对未知新数据进行预测与分析。对数据的预测可以使计算机更加智能化，或者说使计算机的某些性能得到提升；对数据的分析可以让人们获得新的知识，给人们带来新的发现。</p><p>统计学习总的目标就是考虑学习什么样的模型和如何学习模型，以使模型能对数据进行准确的预测与分析，同时也要考虑尽可能地提升学习效率。</p><p><strong>统计学习与机器学习的异同</strong></p><p>统计学习和机器学习的界限一直很模糊，有人认为统计学习偏向于理论上的完善，机器学习基于统计学习，并将其延伸到实践中。<br>机器学习旨在于使最准确的预测成为可能，统计学习模型是为推断变量之间的关系而设计的。<br>我认为，统计学习与机器学习主要就是理论与实践的区别。</p><h2 id="统计学习的方法"><a href="#统计学习的方法" class="headerlink" title="统计学习的方法"></a>统计学习的方法</h2><p>统计学习的方法时基于数据构建统计模型从而对数据进行预测与分析。统计学习由监督学习（supervised learning）、非监督学习（unsupervised learning）、半监督学习（semi-supervised learning）和强化学习（reinforcement learning）等组成。</p><p><strong>监督学习</strong>是从给定的、有限的、用于学习的训练模型（training data）集合出发，假设数据是独立同分布产生的；并且假设要学习的模型属于某个函数的集合，称为假设空间（hypothesis space）；应用某个评价准则（evaluation criterion），从假设空间中选取一个最优的模型，使它对已知训练数据集未知测试数据（test data）在给定的评价准则下有最优的预测；最优模型的选取由算法实现。</p><p>统计学习方法包括模型的假设空间、模型选择的准则以及模型学习的算法，称其为统计学习方法的三要素，简称为模型（model）、策略（stratage）和算法（algorithm）。</p><p>实现统计学习方法的步骤如下：<br>（1）得到一个有限的训练数据集合；<br>（2）确定包含多有可能的模型的假设空间，即学习模型的集合；<br>（3）确定模型选择的准则，即学习的策略；<br>（4）实现求解最优模型的算法，即学习的算法；<br>（5）通过学习方法选择最优模型；<br>（6）利用学习的最优模型对新数据进行预测或分析。</p><p>统计学习研究一般包括统计学习方法（statistical learning method）、统计学习理论（statistical learning theory）以及统计学习应用三个方面。</p><h1 id="2-监督学习"><a href="#2-监督学习" class="headerlink" title="2. 监督学习"></a>2. 监督学习</h1><p><strong>监督学习</strong>（supervised learning）的任务是学习一个模型，是模型能够对任意给定的输入，对其相应的输出做出一个好的预测。</p><h2 id="基本概率"><a href="#基本概率" class="headerlink" title="基本概率"></a>基本概率</h2><h3 id="输入空间、特征空间与输出空间"><a href="#输入空间、特征空间与输出空间" class="headerlink" title="输入空间、特征空间与输出空间"></a>输入空间、特征空间与输出空间</h3><p>在监督学习中，将输入与输出所有可能取值的集合分别称为输入空间与输出空间。输入与输出空间可以是有限元素的集合，也可以是整个欧氏空间。输入和输出空间可以是同一空间，也可以不是同一空间；通常输出空间小于输入空间。<br>每一个具体的输入都是一个实例（instance），通常由特征向量（feature vector）表示。所有的特征向量存在的空间称为特征空间（feature space）。</p><h3 id="联合概率分布"><a href="#联合概率分布" class="headerlink" title="联合概率分布"></a>联合概率分布</h3><p>监督学习假设输入与输出的随机变量$X$和$Y$遵循联合概率分布$P(X,Y)$。$P(X,Y)$表示分布函数，或分布密度函数。</p><h3 id="假设空间"><a href="#假设空间" class="headerlink" title="假设空间"></a>假设空间</h3><p>监督学习的目的在于学习一个由输入到输出的映射，这一映射由模型来表示。换句话说，学习的目的就是找到最满足映射关系的模型。模型属于由输入空间到输出空间的映射的集合，这个集合就是假设空间（hypothesis space）。监督学习的模型可以是概率模型或非概率模型，由条件概率分布$P(Y/X)$或决策函数（decision function）$Y=f(X)$表示。</p><h2 id="问题的形式化"><a href="#问题的形式化" class="headerlink" title="问题的形式化"></a>问题的形式化</h2><p>监督学习利用训练数据集学习一个模型，再用模型对测试样本集进行预测（prediction）。由于在这个过程中需要训练数据集，而训练数据集往往是通过人工标注的，所以统称为监督学习。监督学习分为学习和预测两个过程，由学习系统和预测系统完成。</p><p>首先给定一个训练数据集：</p><p>$$<br>T={(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)}<br>$$</p><p>其中$(x_i,y_i),i=1,2,\cdots,N$，称为样本或样本点。$x_i\in\chi\subseteqq{R^n}$是输入的观测值，也称为输入或实例，$y_i\subseteqq\LARGE{y}$是输出的观测值，也称为输出。  </p><p>监督学习中，假设训练数据和测试数据都是依联合概率分布$P(X,Y)$独立同分布产生的。<br>在学习过程中，学习系统利用给定的训练数据集，通过学习（或训练）得到一个模型，表示为条件概率分布$\hat{P}(Y/X)$或决策函数$Y=\hat{f}(X)$。条件概率分布$\hat{P}(Y/X)$或决策函数$Y=\hat{f}(X)$描述输入与输出随机变量之间的映射关系。<br>在预测过程中，预测系统对于给定的测试样本集合中的输入$x_{N+1}$，由模型$y_{N+1}=argmax_{y_{N+1}}\hat{P}(y_{N+1}/x_{N+1})$或$y_{N+1}=\hat{f}(x_{N+1})$给出相应的输出$y_{N+1}$。其中$y_{N+1}=argmax_{y_{N+1}}\hat{P}(y_{N+1}/x_{N+1})$表示的是对于给定的$x_{N+1}$使得$\hat{P}(y_{N+1}/x_{N+1})$最大时对应的$y_{N+1}$的取值。<br>在学习的过程中，学习系统（也就是学习算法）试图通过训练数据集中的样本$(x_i,y_i)$带来的信息学习模型。具体来说，对于输入$x_i$，一个具体的模型$y=f(x)$可以产生一个输出$f(x_i)$，而训练数据集中对应的输出是$y_i$，如果这个模型有很好的预测能力，那么训练样本输出$y_i$就应该和模型的输出$f(x_i)$尽可能接近。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-统计学习&quot;&gt;&lt;a href=&quot;#1-统计学习&quot; class=&quot;headerlink&quot; title=&quot;1. 统计学习&quot;&gt;&lt;/a&gt;1. 统计学习&lt;/h1&gt;&lt;p&gt;统计学习（statistical learning）是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测人与分析的一门学科。&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;已有数据\xrightarrow{构建}模型\xrightarrow{预测分析}数据&lt;br&gt;$$&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="统计学习" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>句子分块</title>
    <link href="http://yoursite.com/2019/04/19/%E5%8F%A5%E5%AD%90%E5%88%86%E5%9D%97/"/>
    <id>http://yoursite.com/2019/04/19/句子分块/</id>
    <published>2019-04-19T02:52:03.000Z</published>
    <updated>2019-05-05T09:11:44.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="句子分块"><a href="#句子分块" class="headerlink" title="句子分块"></a>句子分块</h2><p>分块也称为浅层分析，它基本上是识别句子部分和短语(如名词短语)。 词性标注告诉你单词是名词，动词，形容词等，但它并没有给你任何关于句子中句子或短语结构的线索。有时除了单词的词性，自然语言处理任务需要获取更多信息，这是就需要对句子进行解析，从中获得完整的解析树。<br><a id="more"></a><br><a href="https://github.com/nicolashernandez/PyRATA" target="_blank" rel="noopener">PyRATA</a></p><p><a href="https://www.programcreek.com/python/example/91255/nltk.RegexpParser" target="_blank" rel="noopener">Python nltk.RegexpParser() Examples</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def prepareForNLP(text):</span><br><span class="line">    sentences = nltk.sent_tokenize(text)</span><br><span class="line">    sentences = [nltk.word_tokenize(sent) for sent in sentences]</span><br><span class="line">    sentences = [nltk.pos_tag(sent) for sent in sentences]</span><br><span class="line">    return sentences</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def chunk(sentence):</span><br><span class="line">    chunkToExtract = &quot;&quot;&quot;</span><br><span class="line">NP: &#123;&lt;NNP&gt;*&#125;</span><br><span class="line">&#123;&lt;DT&gt;?&lt;JJ&gt;?&lt;NNS&gt;&#125;</span><br><span class="line">&#123;&lt;NN&gt;&lt;NN&gt;&#125;&quot;&quot;&quot;</span><br><span class="line">    grammar = r&quot;&quot;&quot;</span><br><span class="line">     NP: &#123;&lt;DT|JJ|NN.*&gt;+&#125;          # Chunk sequences of DT, JJ, NN</span><br><span class="line">     PP: &#123;&lt;IN&gt;&lt;NP&gt;&#125;               # Chunk prepositions followed by NP</span><br><span class="line">     VP: &#123;&lt;VB.*&gt;&lt;NP|PP|CLAUSE&gt;+&#125; # Chunk verbs and their arguments</span><br><span class="line">     CLAUSE: &#123;&lt;NP&gt;&lt;VP&gt;&#125;           # Chunk NP, VP</span><br><span class="line">     &#125;&lt;[\.VI].*&gt;+&#123;       # chink any verbs, prepositions or periods</span><br><span class="line">     &quot;&quot;&quot;</span><br><span class="line">    parser = nltk.RegexpParser(grammar)</span><br><span class="line">    result = parser.parse(sentence)</span><br><span class="line">    print &quot;result.label():&quot;, result.label()</span><br><span class="line">    for subtree in result.subtrees():</span><br><span class="line">        t = subtree</span><br><span class="line">        t = &apos; &apos;.join(word for word, pos in t.leaves())</span><br><span class="line">        print(t)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    example_sent = &quot;A man with a red helmet stands on a small moped on a dirt road .&quot;.lower()</span><br><span class="line">    sentences = prepareForNLP(example_sent)</span><br><span class="line">    for sentence in sentences:</span><br><span class="line">        chunk(sentence)</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a man with a red helmet stands on a small moped on a dirt road .</span><br><span class="line">a man</span><br><span class="line">with a red helmet</span><br><span class="line">a red helmet</span><br><span class="line">stands on a small moped on a dirt road</span><br><span class="line">on a small moped</span><br><span class="line">a small moped</span><br><span class="line">on a dirt road</span><br><span class="line">a dirt road</span><br></pre></td></tr></table></figure></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><h3 id="名词短语的分块："><a href="#名词短语的分块：" class="headerlink" title="名词短语的分块："></a>名词短语的分块：</h3><p><a href="https://aclweb.org/aclwiki/NP_Chunking_(State_of_the_art" target="_blank" rel="noopener">NP Chunking (State of the art)</a>)</p><h3 id="词性标记集"><a href="#词性标记集" class="headerlink" title="词性标记集"></a>词性标记集</h3><p><a href="https://www.ibm.com/support/knowledgecenter/zh/SS5RWK_3.5.0/com.ibm.discovery.es.ta.doc/iiysspostagset.htm" target="_blank" rel="noopener">英语标记集</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;句子分块&quot;&gt;&lt;a href=&quot;#句子分块&quot; class=&quot;headerlink&quot; title=&quot;句子分块&quot;&gt;&lt;/a&gt;句子分块&lt;/h2&gt;&lt;p&gt;分块也称为浅层分析，它基本上是识别句子部分和短语(如名词短语)。 词性标注告诉你单词是名词，动词，形容词等，但它并没有给你任何关于句子中句子或短语结构的线索。有时除了单词的词性，自然语言处理任务需要获取更多信息，这是就需要对句子进行解析，从中获得完整的解析树。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="自然语言处理" scheme="http://yoursite.com/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
      <category term="chunk" scheme="http://yoursite.com/tags/chunk/"/>
    
      <category term="NLTK" scheme="http://yoursite.com/tags/NLTK/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴实习生面试</title>
    <link href="http://yoursite.com/2019/04/17/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/04/17/阿里巴巴实习生面试/</id>
    <published>2019-04-17T14:50:46.000Z</published>
    <updated>2019-04-17T15:10:07.275Z</updated>
    
    <content type="html"><![CDATA[<p>阿里巴巴暑期实习，官网内推投的成都蚂蚁金服，经过漫长等待和催促终于等来了面试。<br><a id="more"></a> </p><h2 id="一面（48min）"><a href="#一面（48min）" class="headerlink" title="一面（48min）"></a>一面（48min）</h2><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><h3 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h3><ul><li>一个之前没注意的问题：synchronized关键字可以修饰类吗？</li></ul><h3 id="Spring-bean的生命周期和作用域"><a href="#Spring-bean的生命周期和作用域" class="headerlink" title="Spring bean的生命周期和作用域"></a>Spring bean的生命周期和作用域</h3><h3 id="IOC有什么用"><a href="#IOC有什么用" class="headerlink" title="IOC有什么用"></a>IOC有什么用</h3><p>解耦</p><h3 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h3><ul><li>索引</li><li>索引的优缺点</li><li>锁</li></ul><h3 id="蚂蚁金服干啥了解吗"><a href="#蚂蚁金服干啥了解吗" class="headerlink" title="蚂蚁金服干啥了解吗"></a>蚂蚁金服干啥了解吗</h3><p>安全</p><h3 id="蚂蚁金服的对手有哪些"><a href="#蚂蚁金服的对手有哪些" class="headerlink" title="蚂蚁金服的对手有哪些"></a>蚂蚁金服的对手有哪些</h3><p>微信支付、京东金融</p><h3 id="蚂蚁金服和对手的优势和劣势"><a href="#蚂蚁金服和对手的优势和劣势" class="headerlink" title="蚂蚁金服和对手的优势和劣势"></a>蚂蚁金服和对手的优势和劣势</h3><h3 id="幂等律"><a href="#幂等律" class="headerlink" title="幂等律"></a>幂等律</h3><p>一个请求与多个请求等效</p><h3 id="一个用户的同一请求（比如充值操作）由于网络问题等多次发送给服务端，怎么实现幂等？"><a href="#一个用户的同一请求（比如充值操作）由于网络问题等多次发送给服务端，怎么实现幂等？" class="headerlink" title="一个用户的同一请求（比如充值操作）由于网络问题等多次发送给服务端，怎么实现幂等？"></a>一个用户的同一请求（比如充值操作）由于网络问题等多次发送给服务端，怎么实现幂等？</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阿里巴巴暑期实习，官网内推投的成都蚂蚁金服，经过漫长等待和催促终于等来了面试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="实习" scheme="http://yoursite.com/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="阿里巴巴" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"/>
    
      <category term="蚂蚁金服" scheme="http://yoursite.com/tags/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>Stacked Cross Attention for Image-Text Matching</title>
    <link href="http://yoursite.com/2019/04/15/Stacked-Cross-Attention-for-Image-Text-Matching/"/>
    <id>http://yoursite.com/2019/04/15/Stacked-Cross-Attention-for-Image-Text-Matching/</id>
    <published>2019-04-15T02:30:23.000Z</published>
    <updated>2019-04-15T09:37:19.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这篇文章做了什么？"><a href="#这篇文章做了什么？" class="headerlink" title="这篇文章做了什么？"></a>这篇文章做了什么？</h2><p>通过对图像中的对象或者突出内容与句子中的单词进行潜在语义对齐，使得图文匹配过程能够捕获到视觉与语言之间细粒度的相互关系，使得图文匹配更具有可解释性。目的是将单词和图像区域映射到同一嵌入空间（<code>common embedding space</code>）从而推断整个图像与句子之间的相似度。<br><a id="more"></a> </p><h2 id="相比于已有的方法有什么优点？"><a href="#相比于已有的方法有什么优点？" class="headerlink" title="相比于已有的方法有什么优点？"></a>相比于已有的方法有什么优点？</h2><p>已有方法：</p><ol><li>简单聚合所有可能的区域以及单词对之间的相似度，却没有关注区分单词和区域之间的重要性；</li><li>使用多步骤的注意力过程来捕获数量有限且缺乏一定解释性的语义对齐。</li></ol><p>这篇文章使用提出的<code>Stacked Cross Attention</code>去发现在图像区域和单词之间的所有潜在对齐，从而计算图文相似度。已有方法通过执行固定步骤的注意力推理，从而在一个时刻只能发现有限的语义对齐，而<code>Stacked Cross Attention</code>可以同时发现所有可能的语义对齐。由于语义对齐的数量随着不同的图像和句子而变化，因此<code>Stacked Cross Attention</code>方法推断出的对应关系更加全面，从而使图像文本匹配更具可解释性。</p><h2 id="这篇文章是怎么做的？"><a href="#这篇文章是怎么做的？" class="headerlink" title="这篇文章是怎么做的？"></a>这篇文章是怎么做的？</h2><ol><li>利用自底向上的注意力机制检测图像区域，并提取图像区域的特征；</li><li>将句子中的单词及其句子上下文映射为特征向量；</li><li>应用<code>Stacked Cross Attention</code>通过对齐图像区域和单词特征来推断图文相似度。</li><li>这篇文章的损失函数关注每一个<code>Batch</code>中最负面的图文对（也就是最不匹配的图文对）。所以对于给定的正样例对$(I,T)$，那么最负样例对定义为$\hat{I}<em>h=argmax</em>{m\neq{I}}S(m,T)$以及$\hat{T}<em>h=argmax</em>{d\neq{T}}S(I,d)$。所以这篇文章定义损失函数如下：  </li></ol><p>$$<br>l_{hard}(I,T)=[\alpha-S(I,T)+S(I,\hat{T}<em>h)]</em>++[\alpha-S(I,T)+S(\hat{I}<em>h,T)]</em>+<br>$$</p><h2 id="怎么文章题目中的Stacked-Cross-Attention？"><a href="#怎么文章题目中的Stacked-Cross-Attention？" class="headerlink" title="怎么文章题目中的Stacked Cross Attention？"></a>怎么文章题目中的<code>Stacked Cross Attention</code>？</h2><p><code>Stacked Cross Attention</code>通过两个阶段来关注图像和文本的上下文信息。第一个阶段，给定一个图像和一个句子，关注每个图像区域对应的句子中的单词，并将每个图像区域与来自句子的受关注信息进行比较，以确定图像区域的重要性（比如图像区域在句子中是否被提到）。第二阶段，与第一阶段相似的，根据每个单词对应的图像区域来决定每个单词的重要性（也就是对每个单词的关注度）。</p><h2 id="文章的实验结果展示"><a href="#文章的实验结果展示" class="headerlink" title="文章的实验结果展示"></a>文章的实验结果展示</h2><p>这篇文章在Flickr30K以及MS-COCO数据集上进行实验，结果如下：</p><p><img src="/2019/04/15/Stacked-Cross-Attention-for-Image-Text-Matching/Stacked-Cross-Attention1.png" alt="image"></p><p><img src="/2019/04/15/Stacked-Cross-Attention-for-Image-Text-Matching/Stacked-Cross-Attention2.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;这篇文章做了什么？&quot;&gt;&lt;a href=&quot;#这篇文章做了什么？&quot; class=&quot;headerlink&quot; title=&quot;这篇文章做了什么？&quot;&gt;&lt;/a&gt;这篇文章做了什么？&lt;/h2&gt;&lt;p&gt;通过对图像中的对象或者突出内容与句子中的单词进行潜在语义对齐，使得图文匹配过程能够捕获到视觉与语言之间细粒度的相互关系，使得图文匹配更具有可解释性。目的是将单词和图像区域映射到同一嵌入空间（&lt;code&gt;common embedding space&lt;/code&gt;）从而推断整个图像与句子之间的相似度。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="图像识别" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
      <category term="神经网络" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="论文阅读" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="图文匹配" scheme="http://yoursite.com/tags/%E5%9B%BE%E6%96%87%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>MyIsam存储引擎</title>
    <link href="http://yoursite.com/2019/04/10/MyIsam%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/2019/04/10/MyIsam存储引擎/</id>
    <published>2019-04-10T02:18:51.000Z</published>
    <updated>2019-04-10T02:46:46.092Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Spring Boot的@Transactional注解对MyISAM存储引擎生效的问题？</li></ol><p>未解决问题，一脸懵逼。。。。</p><a id="more"></a> <p>其中，数据表对应的实体对象如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import javax.persistence.Entity;</span><br><span class="line">import javax.persistence.GeneratedValue;</span><br><span class="line">import javax.persistence.GenerationType;</span><br><span class="line">import javax.persistence.Id;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    @Id</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String name, String password) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用Spring Data Jpa进行数据操作，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line">import org.springframework.data.jpa.repository.Modifying;</span><br><span class="line">import org.springframework.data.jpa.repository.Query;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">@Repository(&quot;user_repository&quot;)</span><br><span class="line">public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Integer deleteUserById(Long id);</span><br><span class="line"></span><br><span class="line">    @Modifying(clearAutomatically = true)</span><br><span class="line">    @Query(value = &quot;update User set name=?2,password=?3 where id=?1&quot;)</span><br><span class="line">    Integer updateUserById(Long id,String name,String password);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>业务逻辑层代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">@Service(&quot;uService&quot;)</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserRepository userRepository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = Exception.class)</span><br><span class="line">    public Integer deleteUserById(Long id)&#123;</span><br><span class="line">        Integer i = userRepository.deleteUserById(id);</span><br><span class="line">        if(id.equals(718L))&#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;删除714错误，回滚&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = &#123;IllegalArgumentException.class&#125;)</span><br><span class="line">    public User saveUser(User user)&#123;</span><br><span class="line">        User u = userRepository.save(user);</span><br><span class="line"></span><br><span class="line">        if(u.getName()==&quot;yang1&quot;)&#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;存入yang，导致回滚&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = &#123;IllegalArgumentException.class&#125;)</span><br><span class="line">    public Integer updateUserById(User user)&#123;</span><br><span class="line">        Integer i = userRepository.updateUserById(user.getId(),user.getName(),user.getPassword());</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后是测试代码，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    private final Logger LOGGER = LoggerFactory.getLogger(this.getClass());</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void deleteUserById() &#123;</span><br><span class="line">        Integer i = userService.deleteUserById(718L);</span><br><span class="line">        LOGGER.error(&quot;delete by user id successful: &quot;+ i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void saveUser()&#123;</span><br><span class="line">        User user = new User(&quot;yang&quot;,&quot;adasdsa&quot;);</span><br><span class="line">        User u = userService.saveUser(user);</span><br><span class="line">        LOGGER.error(u.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void updateUser()&#123;</span><br><span class="line">        User user = new User(&quot;yang&quot;,&quot;adasdsa&quot;);</span><br><span class="line">        user.setId(714L);</span><br><span class="line">        int i = userService.updateUserById(user);</span><br><span class="line">        LOGGER.error(&quot;update by user id successful: &quot;+ i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在测试删除用户（deleteUserById）以及保存用户（saveUser）时，发现抛出异常会导致回滚，但是我的数据库引擎是MyIsam，讲道理不应该支持事务。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Spring Boot的@Transactional注解对MyISAM存储引擎生效的问题？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;未解决问题，一脸懵逼。。。。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MyIsam" scheme="http://yoursite.com/tags/MyIsam/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://yoursite.com/2019/04/08/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/08/代理模式/</id>
    <published>2019-04-08T08:01:31.000Z</published>
    <updated>2019-04-08T10:55:16.262Z</updated>
    
    <content type="html"><![CDATA[<p>代理是一种设计模式，提供了对目标对象的间接访问方式，即通过代理访问目标对象。代理模式的作用：控制和管理访问。<br><a id="more"></a> </p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在程序运行前就已经存在对应的代理类，那么这种代理方式就称之为静态代理。由于这种代理方式下的代理类往往是程序员自己在Java代码中定义的，当我们需求发生变化的时候，代理类以及目标类都需要进行修改维护，不够灵活。但是静态代理也有优点，就是在不对目标对象进行修改的前提下就可以对目标对象进行功能扩展和拦截。<br>下面举个简单的例子，在CS（客户端\服务器）主从结构的网络架构中，一般服务器会对客户端发送而来的请求进行过滤和记录，这个时候就可以使用代理类来实现上述功能。</p><ol><li><p>首先，我们定义服务端顶层接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 顶层接口，目标类和代理类都需要实现顶层接口</span><br><span class="line">  */</span><br><span class="line">interface ServerInterface&#123;</span><br><span class="line">    public void processRequest(String request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其次，定义服务类：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 目标类</span><br><span class="line">  */</span><br><span class="line">class Server implements ServerInterface&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void processRequest(String request) &#123;</span><br><span class="line">        System.out.println(&quot;process request&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>最后定义服务代理类，服务类和代理类都实现服务顶层接口：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 代理类</span><br><span class="line"> */</span><br><span class="line">class ServerProxy implements ServerInterface&#123;</span><br><span class="line">    ServerInterface serverInterface;</span><br><span class="line"></span><br><span class="line">    public ServerProxy(ServerInterface serverInterface) &#123;</span><br><span class="line">        this.serverInterface = serverInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * 过滤来自客户端的不合理请求</span><br><span class="line">        * @param request</span><br><span class="line">        * @return</span><br><span class="line">        */</span><br><span class="line">    public boolean filter(String request)&#123;</span><br><span class="line">        System.out.println(&quot;filter request&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * 记录来自客户端的请求</span><br><span class="line">        */</span><br><span class="line">    public void logBefore()&#123;</span><br><span class="line">        System.out.println(&quot;log before&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * 记录返回给客户端的结果</span><br><span class="line">        */</span><br><span class="line">    public void logReturn()&#123;</span><br><span class="line">        System.out.println(&quot;log return&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void processRequest(String request) &#123;</span><br><span class="line">        logBefore();</span><br><span class="line">        if(!filter(request))&#123;</span><br><span class="line">            serverInterface.processRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">        logReturn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从上面可以看出，当我们的需求改变的时候，比如说我们不仅需要过滤请求、日志记录，还需要进行客户端登录时，那么就需要在代理类中添加登录服务器的方法<code>logIn()</code>，并且给<code>processRequest</code>方法中添加登录方法，而实际情况中服务器中处理请求的方法<code>processRequest</code>成千上万，这个时候程序员就需要给一个个<code>processRequest</code>方法添加<code>logIn</code>操作，可以看到修改和维护代码代价过大，代码也不够简洁。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="JDK原生动态代理"><a href="#JDK原生动态代理" class="headerlink" title="JDK原生动态代理"></a>JDK原生动态代理</h3><p>动态代理中，代理类是在运行时通过Java中的反射机制动态生成的。有兴趣的可以去看看Java中<code>ProxyClassFactory</code>类以及<code>ProxyGenerator</code>类动态生成代理类的源码。</p><p>对于应用程序员而言，主要使用<code>InvocationHandler</code>类以及<code>Proxy.newProxyInstance()</code>实现动态代理。我们还是以上述客户端/服务器网络架构为例。</p><p>顶层的服务接口<code>ServerInterface</code>不变，目标类<code>Server</code>也不用改变，只用实现<code>InvocationHandler</code>接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 日志记录类</span><br><span class="line"> */</span><br><span class="line">class Logger &#123;</span><br><span class="line">    /**</span><br><span class="line">        * 记录来自客户端的请求</span><br><span class="line">        */</span><br><span class="line">    public void logBefore() &#123;</span><br><span class="line">        System.out.println(&quot;log before&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * 记录返回给客户端的结果</span><br><span class="line">        */</span><br><span class="line">    public void logReturn() &#123;</span><br><span class="line">        System.out.println(&quot;log return&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 动态代理</span><br><span class="line"> */</span><br><span class="line">class ServerDynamicProxy implements InvocationHandler &#123;</span><br><span class="line">    Object target;</span><br><span class="line">    Object prozy;</span><br><span class="line"></span><br><span class="line">    public ServerDynamicProxy(Object target, Object prozy) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">        this.prozy = prozy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 动态绑定，返回代理对象</span><br><span class="line">    *</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">    public Object bind() &#123;</span><br><span class="line">        return Proxy.newProxyInstance(target.getClass().getClassLoader()</span><br><span class="line">                , target.getClass().getInterfaces(), this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Class prozyClass = proxy.getClass();</span><br><span class="line">        Method beforeMethod = prozyClass.getMethod(&quot;logBefore&quot;);</span><br><span class="line">        Method returnMethod = prozyClass.getMethod(&quot;logReturn&quot;);</span><br><span class="line"></span><br><span class="line">        beforeMethod.invoke(prozy);</span><br><span class="line">        method.invoke(this.target, args);</span><br><span class="line">        returnMethod.invoke(prozy);</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就是动态代理的使用，当测试的时候只需要在主函数中调用<code>bind()</code>方法返回代理类就可以了，当然需要进行强制类型转换，从<code>Object</code>转换成目标类。<br>如果想看见动态代理生成的代理类，可以使用<code>System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;);</code></p><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理，所以当目标类没有实现接口时，就无法使用JDK代理，只能使用CGLIB实现动态代理。<br>示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 目标类</span><br><span class="line"> */</span><br><span class="line">public class Server &#123;</span><br><span class="line"></span><br><span class="line">    public void processRequest(String request) &#123;</span><br><span class="line">        System.out.println(&quot;process request&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 代理类</span><br><span class="line"> */</span><br><span class="line">public class ServerMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    private Object target;//业务类对象，供代理方法中进行真正的业务方法调用</span><br><span class="line"></span><br><span class="line">    public ServerMethodInterceptor(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //相当于JDK动态代理中的绑定</span><br><span class="line">    public Object getInstance() &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer(); //创建加强器，用来创建动态代理类</span><br><span class="line">        enhancer.setSuperclass(this.target.getClass());  //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）</span><br><span class="line">        //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line">        // 创建动态代理类对象并返回</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        // log before</span><br><span class="line">        System.out.println(&quot;log before&quot;);</span><br><span class="line">        Object result = methodProxy.invokeSuper(o,objects);</span><br><span class="line">        // log return</span><br><span class="line">        System.out.println(&quot;log return&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理是一种设计模式，提供了对目标对象的间接访问方式，即通过代理访问目标对象。代理模式的作用：控制和管理访问。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="动态代理" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
      <category term="静态代理" scheme="http://yoursite.com/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动实习生面试</title>
    <link href="http://yoursite.com/2019/03/30/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/03/30/字节跳动实习生面试/</id>
    <published>2019-03-30T13:20:08.000Z</published>
    <updated>2019-03-30T13:33:43.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ol><li>垃圾回收讲一下；</li><li>java内存模型；<blockquote><ul><li>垃圾回收算法（如何确定回收对象（引用计数法、可达性算法）、回收算法（标记回收、标记整理、复制））；</li><li>垃圾收集器；</li><li>MySQL数据库讲一下；数据引擎、索引类型、索引方法（B+树、Hash）<a id="more"></a> </li></ul></blockquote></li><li>手写代码：根据前序遍历和中序遍历还原二叉树，根据获得的前序遍历和中序遍历结果输出一颗二叉树（输出后续遍历）（我问可以IDE吗？尽量别用）<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2></li><li><p>手写代码： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单链表操作：   </span><br><span class="line"> 输入：奇数位升序，偶数位降序  </span><br><span class="line"> 1 -&gt; 80 -&gt; 4 -&gt; 60 -&gt; 6 -&gt; 40 -&gt; 7 -&gt; 2    </span><br><span class="line">输出：升序单链表  </span><br><span class="line"> 1 -&gt; 2 -&gt; 4 -&gt; 6-&gt; 7 -&gt; 40 -&gt; 60 -&gt; 80  </span><br><span class="line">不允许使用其他数据结构。</span><br></pre></td></tr></table></figure></li><li><p>进程和线程的区别</p></li><li>HashMap</li><li>TCP/UDP<h2 id="三面-两道编程题："><a href="#三面-两道编程题：" class="headerlink" title="三面-两道编程题："></a>三面-两道编程题：</h2><ol><li>假定一张表的数据格式为 id,name,parentId，表的数据不大，1000条以内，得到这些数据的树型结构    输入：List<user> ， 输出：Node（手写代码）</user></li></ol></li><li>有2个文件，分别是A(3t大小)，B(2t)大小，A文件的组织形式为 uid, username,B文件的组织形式为 uid, age,找出A、B文件交集的数据放入一个文件，文件的数据格式为uid,username,age（讲讲思路）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;垃圾回收讲一下；&lt;/li&gt;
&lt;li&gt;java内存模型；&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;垃圾回收算法（如何确定回收对象（引用计数法、可达性算法）、回收算法（标记回收、标记整理、复制））；&lt;/li&gt;
&lt;li&gt;垃圾收集器；&lt;/li&gt;
&lt;li&gt;MySQL数据库讲一下；数据引擎、索引类型、索引方法（B+树、Hash）&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="工作" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="实习" scheme="http://yoursite.com/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="字节跳动" scheme="http://yoursite.com/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Deep Residual Learning for Image Recognition</title>
    <link href="http://yoursite.com/2019/03/06/Deep-Residual-Learning-for-Image-Recognition/"/>
    <id>http://yoursite.com/2019/03/06/Deep-Residual-Learning-for-Image-Recognition/</id>
    <published>2019-03-06T12:49:41.000Z</published>
    <updated>2019-03-07T03:12:31.558Z</updated>
    
    <content type="html"><![CDATA[<p>神经网络越深就越难训练，作者提出一种残差学习框架来降低网络训练的难度。<br><a id="more"></a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;神经网络越深就越难训练，作者提出一种残差学习框架来降低网络训练的难度。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="图像识别" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
      <category term="残差网络" scheme="http://yoursite.com/tags/%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9C/"/>
    
      <category term="神经网络" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="论文阅读" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper-分布式应用程序协调服务</title>
    <link href="http://yoursite.com/2019/03/06/ZooKeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/03/06/ZooKeeper-分布式应用程序协调服务/</id>
    <published>2019-03-06T06:51:32.000Z</published>
    <updated>2019-03-06T08:26:16.895Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://developer.51cto.com/art/201809/583184.htm" target="_blank" rel="noopener">参考链接</a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Apache ZooKeeper is an effort to develop and maintain an open-source server which enables highly reliable distributed coordination.</p><p>Apache ZooKeeper致力于开发和维护一个支持高度可靠的分布式协调的开源服务器。<br><a id="more"></a><br>Zookeeper是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于Zookeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。  </p><h2 id="Znode"><a href="#Znode" class="headerlink" title="Znode"></a>Znode</h2><p>在ZooKeeper中，“节点”分为两种类型：</p><ul><li>第一类是指构成集群的机器，称之为机器节点；</li><li>第二类则是指数据模型中的数据单元，我们称之为数据节点-Znode。</li></ul><p>ZooKeeper将所有的数据存储在内存中，数据模型是一棵树（Znode Tree）</p><h2 id="ZooKeeper集群介绍介绍"><a href="#ZooKeeper集群介绍介绍" class="headerlink" title="ZooKeeper集群介绍介绍"></a>ZooKeeper集群介绍介绍</h2><p>ZooKeeper集群中的所有机器通过Leader选举过程来选定一台称为“Leader”的机器，Leader既可以为客户端提供写服务又能提供读服务。出Leader外，Follower和Observer只能提供读服务。</p><p>Follower与Observer的唯一区别在于Observer机器不参与Leader的选举过程，也不参与写操作的“过半写成功”策略，因此Observer机器可以在不影响写性能的情况下提升集群的读性能。</p><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>ZAB（ZooKeeper Atomic Broadcast，ZooKeeper原子广播）协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的原子广播协议。</p><p>在ZooKeeper中，主要依赖ZAB协议来实现分布式数据一致性，基于该协议ZooKeeper实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p><p>ZAB协议包括两种基本模式，分别是崩溃恢复和消息广播。<br>当整个服务框架在启动过程中，或是当Leader服务器出现网络中断、崩溃退出与重启等异常情况是，ZAB协议就会进入恢复模式并选举出新的Leader服务器。<br>当选举产生的新的Leader服务器，同时集群中已经有过半的机器与新Leader服务器完成状态同步之后，ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，也就是保证集群中过半的机器与该Leader服务器的数据状态一致。<br>当集群中已经有过半的Follower服务器完成与Leader服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。<br>当一台同样遵守ZAB协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个Leader服务器在负责消息广播，那么新加入的服务器就会自觉地进去数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p><p>正如上文所述，ZooKeeper被设计成只允许唯一的Leader服务器进行事务请求的处理，Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议。如果集群中的其他机器接收到客户端事务请求，那么这些非Leader服务器会首先将这个事务转发给Leader服务器。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在我们的智慧教育示范应用中，主要是使用Kafka收集用户日志，而ZooKeeper就担任了服务生产者和消费者的注册中心。<br>服务生产者将自己提供的服务注册到ZooKeeper中心，服务消费者在进行服务调用的时候先到ZooKeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容和数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://developer.51cto.com/art/201809/583184.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;Apache ZooKeeper is an effort to develop and maintain an open-source server which enables highly reliable distributed coordination.&lt;/p&gt;
&lt;p&gt;Apache ZooKeeper致力于开发和维护一个支持高度可靠的分布式协调的开源服务器。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/categories/ZooKeeper/"/>
    
    
      <category term="开源软件" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>条件生成对抗网络的一系列问题</title>
    <link href="http://yoursite.com/2019/03/05/%E6%9D%A1%E4%BB%B6%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/05/条件生成对抗网络的一系列问题/</id>
    <published>2019-03-05T13:30:04.000Z</published>
    <updated>2019-03-06T05:18:26.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条件生成对抗网络中生成器的输入随机噪声z，文本特征-phi-t-作为条件，噪声输入有什么用？"><a href="#条件生成对抗网络中生成器的输入随机噪声z，文本特征-phi-t-作为条件，噪声输入有什么用？" class="headerlink" title="条件生成对抗网络中生成器的输入随机噪声z，文本特征$\phi(t)$作为条件，噪声输入有什么用？"></a>条件生成对抗网络中生成器的输入随机噪声<code>z</code>，文本特征$\phi(t)$作为条件，噪声输入有什么用？</h2><p><a href="https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/issues/152" target="_blank" rel="noopener">参考链接：https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/issues/152</a></p><p>其实没有噪声输入也可以，但是有时候需要同一个文本输入需要生成的样本更加多样，这时候随机噪声就有用了。<br><a id="more"></a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;条件生成对抗网络中生成器的输入随机噪声z，文本特征-phi-t-作为条件，噪声输入有什么用？&quot;&gt;&lt;a href=&quot;#条件生成对抗网络中生成器的输入随机噪声z，文本特征-phi-t-作为条件，噪声输入有什么用？&quot; class=&quot;headerlink&quot; title=&quot;条件生成对抗网络中生成器的输入随机噪声z，文本特征$\phi(t)$作为条件，噪声输入有什么用？&quot;&gt;&lt;/a&gt;条件生成对抗网络中生成器的输入随机噪声&lt;code&gt;z&lt;/code&gt;，文本特征$\phi(t)$作为条件，噪声输入有什么用？&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/issues/152&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接：https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/issues/152&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实没有噪声输入也可以，但是有时候需要同一个文本输入需要生成的样本更加多样，这时候随机噪声就有用了。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="论文阅读" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
      <category term="生成对抗网络" scheme="http://yoursite.com/tags/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据库范式</title>
    <link href="http://yoursite.com/2019/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/04/数据库范式/</id>
    <published>2019-03-04T13:36:33.000Z</published>
    <updated>2019-04-10T02:19:30.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h2><p>关系模型中实体的每个属性都是原子属性，即元组在每个属性上的取值是不可分的。也就是说这些属性的取值是单一的，不是集合、数组等非原子数据。当实体中的某个属性都多个值时，必须将该属性拆分为多个原子属性。</p><a id="more"></a> <h2 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h2><p><strong>关系模型中的所有非主属性都完全依赖于所有的候选键</strong>。2NF其实就是在1NF的基础上消除那些非主属性对所有候选键的部分函数依赖。<br>例如，关系（学号，课程号，教师，成绩，学院）中，教师部分依赖于课程号，因此这个关系不满足第二范式，所以需要把上述关系拆分成（学号，课程号，成绩）和（课程号，教师，学院）。</p><h2 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h2><p><strong>关系模型中的非主属性既不部分函数依赖也不传递函数依赖于关系中的所有候选键</strong>。也就是说3NF是在2NF的基础上消除了非主属性对候选键的传递依赖关系。</p><p>还是上面的例子，关系（课程号，教师，学院）中存在传递依赖关系课程号-&gt;教师，以及教师-&gt;学院，因此不满足3NF。所以将其分解为（课程号，教师）和（教师，学院）。</p><h2 id="巴斯-科德范式（BCNF）"><a href="#巴斯-科德范式（BCNF）" class="headerlink" title="巴斯-科德范式（BCNF）"></a>巴斯-科德范式（BCNF）</h2><p><strong>对于关系R上的任何非平凡函数依赖X-&gt;Y都有X必包含R的某个候选键</strong>，那么就称关系R满足BCNF。BCNF是在第三范式的基础上继续消除主属性对于键的部分依赖和传递依赖。  </p><p>举个例子来说，关系（课程名，班级，教师）中假定多名教师承担多个班级的教学任务，每个教师仅承担一个课程的教学任务，同时可以给多个班级上课，那么可以知道有函数依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(课程名，班级)-&gt;(教师)</span><br><span class="line">(教师)-&gt;(课程名)</span><br></pre></td></tr></table></figure><p>然而，上述关系中的主键是(课程名，班级)或者(教师，班级)。所以<code>(教师)-&gt;(课程名)</code>就是主属性对候选键的部分依赖，不满足BCNF。</p><h2 id="第四范式（4NF）"><a href="#第四范式（4NF）" class="headerlink" title="第四范式（4NF）"></a>第四范式（4NF）</h2><p>对于关系R中的非平凡多值依赖X-&gt;-&gt;Y，X必包含R的某个候选键，则称满足4NF。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一范式（1NF）&quot;&gt;&lt;a href=&quot;#第一范式（1NF）&quot; class=&quot;headerlink&quot; title=&quot;第一范式（1NF）&quot;&gt;&lt;/a&gt;第一范式（1NF）&lt;/h2&gt;&lt;p&gt;关系模型中实体的每个属性都是原子属性，即元组在每个属性上的取值是不可分的。也就是说这些属性的取值是单一的，不是集合、数组等非原子数据。当实体中的某个属性都多个值时，必须将该属性拆分为多个原子属性。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="范式" scheme="http://yoursite.com/tags/%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器</title>
    <link href="http://yoursite.com/2019/02/28/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2019/02/28/垃圾收集器/</id>
    <published>2019-02-28T02:28:49.000Z</published>
    <updated>2019-02-28T10:54:47.229Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾收集算法是内存回收的方法论，垃圾收集器是垃圾回收的具体实现。在JDK1.7 Update 14之后的HotSpot虚拟机所包含的收集器如下图所示：</p><p><img src="/2019/02/28/垃圾收集器/垃圾收集器1.jpg" alt="垃圾收集器"></p><a id="more"></a> <h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>Serial收集器是最基本、发展历史最悠久的收集器。这是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Serial收集器运行示意图如下：</p><p><img src="/2019/02/28/垃圾收集器/垃圾收集器2.jpg" alt="垃圾收集器"></p><p>也就是说，虚拟机在使用Serial垃圾收集器时会在用户不可见的情况下把所有用户正常工作的线程暂停，这种“Stop The World”操作在很多程序中是难以接受的，带给用户不良体验。<br>举个例子“你妈妈在打扫房间的时候，肯定也会让你老老实实待在椅子上或者房间外待着，如果她一边打扫，你一边丢垃圾，这房间还能打扫完？你妈妈不会崩溃？”，因此看起来“Stop The World”操作情有可原。<br>但是，从JDK1.3开始，HotSpot虚拟机开发团队一直在努力消除或减少工作线程因内存回收而导致的停顿，从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）乃至GC收集器最前沿的成果Garbage First（G1）收集器，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除垃圾回收带来的停顿。<br>Serial收集器虽然很老，可以说很陈旧，但是目前为止它依旧是虚拟机运行在Client模式下的默认新生代收集器。那是因为Serial收集器简单而高效，对于限定单个GPU的情况而言，Serial收集器由于没有线程交互的开销，专心进行垃圾收集自然可以获得最高的单线程收集效率。  </p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew收集器就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为包括Serial收集器的所有可用控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样。ParNew收集器进行垃圾收集的示意图如下：  </p><p><img src="/2019/02/28/垃圾收集器/垃圾收集器3.jpg" alt="垃圾收集器"></p><p>ParNew收集器除了多线程收集外，其他与Serial收集器相比没有太多创新之处，但它却是虚拟机运行在Server模式下的首选新生代收集器，其中一个与性能无关的重要原因是除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器也是新生代收集器，并且使用复制算法收集内存，同时还是并行的多线程收集器。这些特点都和ParNew收集器一样，但是Parallel Scavenge收集器的目标在于达到一个可控制的<strong>吞吐量</strong>（Throughput），所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码/(运行用户代码+垃圾收集时间)。这与CMS等收集器的目标不同，它们目标是尽可能地缩短垃圾收集时间用户线程的停顿时间。<br>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多的交互任务。<br>Parallel Scavenge收集器提供两个参数用于精准控制吞吐量，分别是控制最大垃圾收集时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。<br><strong>MaxGCPauseMillis</strong>参数允许的值是一个大于0的毫秒数，收集器将尽可能在规定时间内完成垃圾收集操作。但是不要认为这个参数越小，系统的垃圾收集速度就会越快，GC停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一点，收集300M新生代肯定比收集500M新生代快，这也将导致垃圾收集更频繁，原来每20s收集一次、一次100ms，现在每10s收集一次、一次70ms。停顿时间的确下降了，但吞吐量也降下来了。<br><strong>GCTimeRatio</strong>参数的值应当是一个大于0小于100的整数，如果把这个参数设置为19，那么允许最大GC时间就占总时间的5%（即1/(1+19)）。<br>Parallel Scavenge收集器还有一个参数-XX:+UseAdaptiveSizePolicy，这个参数打开之后就不需要手动指定新生代的大小（-Xmm）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最适合的停顿时间或者最大吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。  </p><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法，这个收集器的主要意义也是在于给Client模式下的虚拟机使用。<br>在Server模式下，它有两大用途：  </p><ul><li>在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用；</li><li>作为CMS收集器的后备方案，在并发收集发生Concurrent Mode Failure时使用。  </li></ul><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。在JDK1.6之前Parallel Scavenge只能与Serial Old收集器配合使用，由于老年代使用单线程收集内存无法充分利用服务器多CPU的处理能力，这个组合就导致无法达到高吞吐量。在JDK1.6开始提供了Parallel Old收集器和Parallel Scavenge收集器配合使用，从而可以应用在注重吞吐量以及CPU资源敏感的场合。</p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。从名字（包含“Mark Sweep”）就可以看出来，CMS收集器是基于“标记——清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p><ul><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ul><p>其中，初始标记、重新标记这；两个步骤仍需要“Stop The World”。初始标记是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段是为了修正并发标记阶段因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这一阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记阶段的时间短。整个过程中耗时最长的并发标记和并发清除阶段都是与用户线程一起工作，如下图所示：</p><p><img src="/2019/02/28/垃圾收集器/垃圾收集器5.png" alt="垃圾收集器"></p><p>CMS是一款优秀的收集器，它的主要优点是并发收集、低停顿，但是它还有以下三个明显缺点：</p><ul><li>CMS收集器对CPU资源非常敏感；</li><li>CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次的Full GC。</li><li>CMS收集器是基于“标记-清除”算法实现的，在收集结束会产生大量的空间碎片。为了解决这个问题，CMS收集器提供了一个-XX:+USeCMSCompactAtFullCollection开关参数用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程。</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1收集器是当前收集技术最前沿的成果之一，它被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。G1是一款面向服务端应用的垃圾收集器，与其他收集器相比，G1具备如下特点：</p><ul><li>并行与并发</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li></ul><p>在G1之前的其他收集器进行收集的范围是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大区别，它将整个Java堆划分成多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垃圾收集算法是内存回收的方法论，垃圾收集器是垃圾回收的具体实现。在JDK1.7 Update 14之后的HotSpot虚拟机所包含的收集器如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/02/28/垃圾收集器/垃圾收集器1.jpg&quot; alt=&quot;垃圾收集器&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="垃圾收集器" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
      <category term="垃圾收集算法" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程基础</title>
    <link href="http://yoursite.com/2019/02/27/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/02/27/Java并发编程基础/</id>
    <published>2019-02-27T13:49:16.000Z</published>
    <updated>2019-03-01T14:26:51.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>现代操作系统在运行一个程序的时候就会创建一个进程。线程是现在操作系统系统调度的最小单元，也称为轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，每个线程都有自己的程序计数器、堆栈和局部变量等属性，并且能够访问内存中共享的变量。</p><h3 id="使用多线程的原因"><a href="#使用多线程的原因" class="headerlink" title="使用多线程的原因"></a>使用多线程的原因</h3><ol><li>更多的处理器核心：随着处理器上的核心数量越来越多，以及超线程技术的广泛应用，现在的计算机比以往更加擅长并行计算；</li><li>更快的响应时间：当业务逻辑过于复杂，使用多线程技术，将对数据一致性要求不高的操作派发给多个线程处理，这样做能更快地处理完一个复杂任务，缩短响应时间，提升用户体验；</li><li>更好的编程模型：Java为多线程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决，即为所遇到的问题建立合适的模型，而不是绞尽脑汁地考虑如何将任务多线程化。</li></ol><a id="more"></a><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法修改线程的优先级，默认优先级为5，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞的线程则设置较低的优先级，保证处理器不会被独占。</p><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>Java线程在运行的生命周期可能处于6种不同的状态，在任意给定时刻线程只能处于其中的一种状态：</p><table><thead><tr><th>状态名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>NEW</td><td style="text-align:center">初始状态，线程被构建，但是还没有调用start()方法</td></tr><tr><td>RUNNABLE</td><td style="text-align:center">运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称为“运行中”</td></tr><tr><td>BLOCKED</td><td style="text-align:center">阻塞状态，表示线程阻塞于锁</td></tr><tr><td>WAITING</td><td style="text-align:center">等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td>TIME_WAITING</td><td style="text-align:center">超时等待状态，该状态不同于WAITING，它是可以在指定时间自行返回的</td></tr><tr><td>TERMINATED</td><td style="text-align:center">终止状态，表示当前线程已经执行完毕</td></tr></tbody></table><h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程时，Java虚拟机将会退出。可以在线程启动之前通过调用Thread.setDaemon(true)将线程设置为Daemon线程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h2&gt;&lt;p&gt;现代操作系统在运行一个程序的时候就会创建一个进程。线程是现在操作系统系统调度的最小单元，也称为轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，每个线程都有自己的程序计数器、堆栈和局部变量等属性，并且能够访问内存中共享的变量。&lt;/p&gt;
&lt;h3 id=&quot;使用多线程的原因&quot;&gt;&lt;a href=&quot;#使用多线程的原因&quot; class=&quot;headerlink&quot; title=&quot;使用多线程的原因&quot;&gt;&lt;/a&gt;使用多线程的原因&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;更多的处理器核心：随着处理器上的核心数量越来越多，以及超线程技术的广泛应用，现在的计算机比以往更加擅长并行计算；&lt;/li&gt;
&lt;li&gt;更快的响应时间：当业务逻辑过于复杂，使用多线程技术，将对数据一致性要求不高的操作派发给多个线程处理，这样做能更快地处理完一个复杂任务，缩短响应时间，提升用户体验；&lt;/li&gt;
&lt;li&gt;更好的编程模型：Java为多线程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决，即为所遇到的问题建立合适的模型，而不是绞尽脑汁地考虑如何将任务多线程化。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
      <category term="volatile" scheme="http://yoursite.com/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu配置shadowsocks科学上网</title>
    <link href="http://yoursite.com/2019/02/26/Ubuntu%E9%85%8D%E7%BD%AEshadowsocks%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://yoursite.com/2019/02/26/Ubuntu配置shadowsocks科学上网/</id>
    <published>2019-02-26T04:36:59.000Z</published>
    <updated>2019-02-26T12:08:14.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网1.png" alt="科学上网"></p><h2 id="showsocks配置"><a href="#showsocks配置" class="headerlink" title="showsocks配置"></a>showsocks配置</h2><ol><li>安装shadowsocks客户端,命令如下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install shadowsocks</span><br></pre></td></tr></table></figure><a id="more"></a> <ol start="2"><li>查看shadowsocks命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal --help</span><br></pre></td></tr></table></figure><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网2.png" alt="科学上网"></p><ol start="3"><li>启动shadowsocks两种方式：</li></ol><ul><li>通过设置各个参数，如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -s 11.22.33.44 -p 50003 -k &quot;123456&quot; -l 1080 -t 600 -m aes-256-cfb</span><br></pre></td></tr></table></figure><ul><li>或者，直接加载json配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c file_path/shadowsocks.json</span><br></pre></td></tr></table></figure><p>启动shadowsocks如下所示：</p><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网3.png" alt="科学上网"></p><p>配置好shadowsocks客户端后，我们介绍一下三种方式设置代理模式。</p><h2 id="方式一：不要关闭上面的终端，重新打开一个终端，配置全局变量："><a href="#方式一：不要关闭上面的终端，重新打开一个终端，配置全局变量：" class="headerlink" title="方式一：不要关闭上面的终端，重新打开一个终端，配置全局变量："></a>方式一：不要关闭上面的终端，重新打开一个终端，配置全局变量：</h2><p>使用<code>vim ~/.bashrc</code>添加语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias hp=&quot;http_proxy=http://localhost:8123&quot;</span><br></pre></td></tr></table></figure></p><p>使用<code>source ~/.bashrc</code>使更改生效。</p><ol start="5"><li>测试效果</li></ol><ul><li>使用命令<code>hp curl ip.gs</code>查看代理服务器网址，结果如下所示：</li></ul><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网4.png" alt="科学上网"></p><p>可以看出，<code>alias hp=&quot;http_proxy=http://localhost:8123&quot;</code>这句语句的作用就是用命令<code>hp</code>替换<code>http_proxy=http://localhost:8123</code>这一串长命令。</p><h2 id="那我们不想每条指令前面都加上命令hp怎么办，这就需要设置全局代理："><a href="#那我们不想每条指令前面都加上命令hp怎么办，这就需要设置全局代理：" class="headerlink" title="那我们不想每条指令前面都加上命令hp怎么办，这就需要设置全局代理："></a>那我们不想每条指令前面都加上命令<code>hp</code>怎么办，这就需要设置全局代理：</h2><h3 id="方式二：为当前窗口设置全局代理"><a href="#方式二：为当前窗口设置全局代理" class="headerlink" title="方式二：为当前窗口设置全局代理"></a>方式二：为当前窗口设置全局代理</h3><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://localhost:8123 # 当前终端使用代理</span><br><span class="line">unset http_proxy # 当前终端取消代理</span><br></pre></td></tr></table></figure></p><p>测试如下所示，可以看出上设置全局代理后，就不需要<code>hp</code>命令了，取消代理（<code>unset</code>）后可以看到<code>ip</code>变成了陕西西安。<br><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网5.png" alt="科学上网"></p><h3 id="方式三：设置当前用户的全局代理"><a href="#方式三：设置当前用户的全局代理" class="headerlink" title="方式三：设置当前用户的全局代理"></a>方式三：设置当前用户的全局代理</h3><p>在<code>~/.bashrc</code>中添加<code>export http_proxy=http://localhost:8123</code>命令设置当前用户的全局代理。别忘了使用<code>source ~/.bashrc</code>使更改生效。</p><p>如下所示，</p><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网6.png" alt="科学上网"></p><h2 id="经过测试，推荐方式二为当前窗口设置全局代理，命令如下："><a href="#经过测试，推荐方式二为当前窗口设置全局代理，命令如下：" class="headerlink" title="经过测试，推荐方式二为当前窗口设置全局代理，命令如下："></a>经过测试，推荐方式二为当前窗口设置全局代理，命令如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://localhost:8123 # 当前终端使用代理</span><br><span class="line">unset http_proxy # 当前终端取消代理</span><br></pre></td></tr></table></figure><p>这种方式可以开启一个窗口运行export作为科学上网窗口，而其他窗口依旧正常上网，这样可以<strong>节约流量</strong>。<br>除此之外，这是我测试的上述三种上网方式中最稳定的一种，建议使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>配置好之后，科学上网的过程，先打开一个终端窗口，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c file_path/shadowsocks.json</span><br></pre></td></tr></table></figure><p>再打开新窗口，运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://localhost:8123</span><br></pre></td></tr></table></figure></p><p>我使用R-3D中下载YouTube视频的代码作为测试，运行<code>python download_video.py</code>就可以看到下载视频并保存在当前目录的videos目录下。</p><p>示意结果如下，<code>sslocal -c shadowsocks.json</code>启动窗口下方会出现与<code>www.youtube.com</code>连接的日志信息：</p><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网7.png" alt="科学上网"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;系统环境&quot;&gt;&lt;a href=&quot;#系统环境&quot; class=&quot;headerlink&quot; title=&quot;系统环境&quot;&gt;&lt;/a&gt;系统环境&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网1.png&quot; alt=&quot;科学上网&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;showsocks配置&quot;&gt;&lt;a href=&quot;#showsocks配置&quot; class=&quot;headerlink&quot; title=&quot;showsocks配置&quot;&gt;&lt;/a&gt;showsocks配置&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装shadowsocks客户端,命令如下&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt install shadowsocks&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="工程" scheme="http://yoursite.com/categories/%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
      <category term="shadowsocks" scheme="http://yoursite.com/tags/shadowsocks/"/>
    
      <category term="科学上网" scheme="http://yoursite.com/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
      <category term="代理" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%90%86/"/>
    
      <category term="proxy" scheme="http://yoursite.com/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>面向切面编程</title>
    <link href="http://yoursite.com/2019/02/21/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/21/面向切面编程/</id>
    <published>2019-02-21T09:08:56.000Z</published>
    <updated>2019-03-09T14:10:14.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向切面编程（Aspect-Oriented-Programming，AOP）是什么？"><a href="#面向切面编程（Aspect-Oriented-Programming，AOP）是什么？" class="headerlink" title="面向切面编程（Aspect Oriented Programming，AOP）是什么？"></a>面向切面编程（Aspect Oriented Programming，AOP）是什么？</h2><ol><li>AOP是一种编程范式，不是编程语言；</li><li>AOP解决特定问题，但不能解决所有问题；</li><li>OOP的补充，而不是其替代。<a id="more"></a> </li></ol><h2 id="AOP为什么出现？"><a href="#AOP为什么出现？" class="headerlink" title="AOP为什么出现？"></a>AOP为什么出现？</h2><ol><li>提高代码重用性；</li><li>概念分离：分离功能性需求和非功能性需求。将功能性需求从非功能性需求中分离出来。</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>权限控制</li><li>缓存控制</li><li>事务控制</li><li>审计日志</li><li>性能监控</li><li>分布式追踪</li><li>异常处理</li></ol><h2 id="Spring-AOP的通过代理实现"><a href="#Spring-AOP的通过代理实现" class="headerlink" title="Spring AOP的通过代理实现"></a>Spring AOP的通过代理实现</h2><p>通过DefaultAopProxyFactory.java源码可以看到AOP由jdk和cglib两种方式实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        if (targetClass == null) &#123;</span><br><span class="line">            throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +</span><br><span class="line">                    &quot;Either an interface or a target is required for proxy creation.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            return new JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        return new ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return new JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Spring-AOP的使用"><a href="#Spring-AOP的使用" class="headerlink" title="Spring AOP的使用"></a>Spring AOP的使用</h2><p>在Spring中主要使用注解@Aspect、@Pointcut、@Before、@After、@AfterReturning、@AfterThrowing以及@Around进行面向切面编程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface Aspect &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Per clause expression, defaults to singleton aspect</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * Valid values are &quot;&quot; (singleton), &quot;perthis(...)&quot;, etc</span><br><span class="line">     */</span><br><span class="line">    public String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码是@Aspect注解的定义，ElementType.TYPE可以看出该注解作用目标是接口、类、枚举、注解，@Aspect注解，Spring通过@Aspect注解切面并把它应用到目标对象上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface Pointcut &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The pointcut expression</span><br><span class="line">     * We allow &quot;&quot; as default for abstract pointcut</span><br><span class="line">     */</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * When compiling without debug info, or when interpreting pointcuts at runtime,</span><br><span class="line">     * the names of any arguments used in the pointcut are not available.</span><br><span class="line">     * Under these circumstances only, it is necessary to provide the arg names in </span><br><span class="line">     * the annotation - these MUST duplicate the names used in the annotated method.</span><br><span class="line">     * Format is a simple comma-separated list.</span><br><span class="line">     */</span><br><span class="line">    String argNames() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码是@Pointcut注解的定义，value()用来定义切面所在的位置，定义方式有以下几种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// execution定义切面，匹配符合表达式的所有方法</span><br><span class="line">@Pointcut(&quot;execution(* com.xjtu.springbootstudy.aop.bymyself.service.ProgrammerService.work())&quot;)</span><br><span class="line">// within用于匹配类，对应类下的所有方法都执行切面方法；</span><br><span class="line">@Pointcut(&quot;within(com.xjtu.springbootstudy.aop.bymyself.service.*)&quot;)</span><br><span class="line">// @annotation用于匹配自定义注解，如下面的@SignLog注解，再将@SignLog放在想定义切面的方法</span><br><span class="line">@Pointcut(&quot;@annotation(com.xjtu.springbootstudy.aop.bymyself.annotation.SignLog)&quot;)</span><br><span class="line">// @within用于匹配自定义注解，如下面的@SignLog注解，再将@SignLog放在想定义切面的类上</span><br><span class="line">@Pointcut(&quot;@within(com.xjtu.springbootstudy.aop.bymyself.annotation.SignLog))&quot;)</span><br><span class="line">public void log()&#123; &#125;</span><br></pre></td></tr></table></figure></p><p>如上对log()添加注解，@Pointcut注解中value定义切面位置，使用execution、within、@annotation、@within等方式设置切面。</p><ul><li>@before在目标方法开始执行时执行；</li><li>@after在目标方法执行结束前执行；</li><li>@AfterReturning在目标方法执行正确返回前执行；</li><li>@AfterThrowing在目标方法执行异常时执行，</li><li>@Around环绕执行，一般是前4个无法实现期望功能时，才使用这个注解。</li></ul><p>我写了一个简单示意切面程序，如下所示，对应执行结果也展示下下方。有个疑问就是@after和@AfterReturning注解的方法谁<strong>先执行</strong>？根据执行结果也可以看出<br><strong>@after</strong>注解的方法<strong>先执行</strong>，@AfterReturning注解的方法后执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Before(value = &quot;log()&quot;)</span><br><span class="line">public void signIn(JoinPoint joinPoint)&#123;</span><br><span class="line">    logger.info(&quot;***********the people signs in******&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@After(value = &quot;log()&quot;)</span><br><span class="line">public void leaveWorkPlace(JoinPoint joinPoint)&#123;</span><br><span class="line">    logger.info(&quot;***********the people leaves workplace******&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@AfterReturning(value = &quot;log()&quot;)</span><br><span class="line">public void signOut(JoinPoint joinPoint)&#123;</span><br><span class="line">    logger.info(&quot;***********the people signs out successfully******&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@AfterThrowing(value = &quot;log()&quot;,throwing = &quot;throwable&quot;)</span><br><span class="line">public void happenAccidentWhenWorking(JoinPoint joinPoint,Throwable throwable)&#123;</span><br><span class="line">    logger.info(&quot;***********the people happens accident when working******&quot;);</span><br><span class="line">    logger.info(&quot;***********&quot;+throwable.getMessage()+&quot;***********&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Around(value = &quot;log()&quot;)</span><br><span class="line">public void happenAround(ProceedingJoinPoint joinPoint)&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        joinPoint.proceed(joinPoint.getArgs());</span><br><span class="line">    &#125; catch (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">***********the people signs in******                // @before</span><br><span class="line">I&apos;m working in workplace!                           // 这是目标方法的执行结果</span><br><span class="line">***********the people leaves workplace******        // @after</span><br><span class="line">***********the people signs out successfully******  // @afterReturning</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向切面编程（Aspect-Oriented-Programming，AOP）是什么？&quot;&gt;&lt;a href=&quot;#面向切面编程（Aspect-Oriented-Programming，AOP）是什么？&quot; class=&quot;headerlink&quot; title=&quot;面向切面编程（Aspect Oriented Programming，AOP）是什么？&quot;&gt;&lt;/a&gt;面向切面编程（Aspect Oriented Programming，AOP）是什么？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;AOP是一种编程范式，不是编程语言；&lt;/li&gt;
&lt;li&gt;AOP解决特定问题，但不能解决所有问题；&lt;/li&gt;
&lt;li&gt;OOP的补充，而不是其替代。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
      <category term="AOP" scheme="http://yoursite.com/tags/AOP/"/>
    
      <category term="面向切面编程" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象编程知识点</title>
    <link href="http://yoursite.com/2019/02/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2019/02/20/Java面向对象编程知识点/</id>
    <published>2019-02-20T02:40:58.000Z</published>
    <updated>2019-04-08T09:10:02.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象的三个基本特征和五种设计原则"><a href="#面向对象的三个基本特征和五种设计原则" class="headerlink" title="面向对象的三个基本特征和五种设计原则"></a>面向对象的三个基本特征和五种设计原则</h2><h3 id="三个基本特征"><a href="#三个基本特征" class="headerlink" title="三个基本特征"></a>三个基本特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏；</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重写原有类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“父类”或“基类”。继承的过程就是从一般到特殊的过程。<br>要实现继承可以通过“继承”和“组合”两种方式实现。在某些OOP语言中，一个子类可以继承多个基类，但一般情况下（Java语言），一个子类只有一个基类，实现多重继承可以通过多级继承来实现。<br><a id="more"></a><br>继承概念的实现方式有三类：  </p><ul><li>实现继承：指使用基类的属性和方法而无需额外编码的能力；</li><li>接口继承：指仅使用基类的属性和方法名称，但子类必须提供实现的能力；</li><li>可视继承：指子类使用基类的外观和实现代码的能力。<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4></li></ul><p>多态是允许你将父对象设置成为和一个或多个它的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同方式运作。简单地说就是：允许将子类类型的指针赋值给父类类型的指针。<br>实现多态有两种方式：覆盖和重载：  </p><ul><li>覆盖是指子类重新定义父类的虚函数的做法；</li><li>重载是指允许多个同名函数，这些函数的参数不同（参数个数不同，或参数类型不同，或两者都不同）。</li></ul><h3 id="五种设计原则"><a href="#五种设计原则" class="headerlink" title="五种设计原则"></a>五种设计原则</h3><h4 id="单一职责原则-Single-Responsibility-Principle，SRP"><a href="#单一职责原则-Single-Responsibility-Principle，SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle，SRP)"></a>单一职责原则(Single Responsibility Principle，SRP)</h4><p>单一职责原则是指一个类的功能要单一，不能包罗万象。一个类应该只有一个引起它变化的原因。</p><h4 id="开放封闭原则-Open－Close-Principle，OCP"><a href="#开放封闭原则-Open－Close-Principle，OCP" class="headerlink" title="开放封闭原则(Open－Close Principle，OCP)"></a>开放封闭原则(Open－Close Principle，OCP)</h4><p> 开放封闭原则指的是对扩展性的开放和对修改的封闭：</p><ul><li>对扩展性的开放：模块的行为应该是可扩展的，从而该模块可表现出行的行为以满足需求的变化；</li><li><p>对修改的封闭：模块自身的代码时不应该被修改的，扩展模块的一般途径是修改内部实现。</p><h4 id="里氏替换原则-the-Liskov-Substitution-Principle，LSP"><a href="#里氏替换原则-the-Liskov-Substitution-Principle，LSP" class="headerlink" title="里氏替换原则(the Liskov Substitution Principle，LSP)"></a>里氏替换原则(the Liskov Substitution Principle，LSP)</h4><p>子类型必须能够替换掉它们的父类型，并出现在父类能够出现的任何地方。</p></li></ul><h4 id="依赖倒置原则-the-Dependency-Inversion-Principle，PIP"><a href="#依赖倒置原则-the-Dependency-Inversion-Principle，PIP" class="headerlink" title="依赖倒置原则(the Dependency Inversion Principle，PIP)"></a>依赖倒置原则(the Dependency Inversion Principle，PIP)</h4><p>具体依赖抽象，上层依赖下层。</p><h4 id="接口隔离原则-the-Interface-Segregation-Principle，ISP"><a href="#接口隔离原则-the-Interface-Segregation-Principle，ISP" class="headerlink" title="接口隔离原则(the Interface Segregation Principle，ISP)"></a>接口隔离原则(the Interface Segregation Principle，ISP)</h4><p>模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来。</p><h2 id="Class-java类文件下getMethods-和getDeclaredMethods-的区别"><a href="#Class-java类文件下getMethods-和getDeclaredMethods-的区别" class="headerlink" title="Class.java类文件下getMethods()和getDeclaredMethods()的区别"></a><code>Class.java</code>类文件下<code>getMethods()</code>和<code>getDeclaredMethods()</code>的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public Method[] getMethods() throws SecurityException &#123;</span><br><span class="line">    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);</span><br><span class="line">    return copyMethods(privateGetPublicMethods());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@CallerSensitive</span><br><span class="line">public Method[] getDeclaredMethods() throws SecurityException &#123;</span><br><span class="line">    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);</span><br><span class="line">    return copyMethods(privateGetDeclaredMethods(false));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getMethods()</code>是获取对应类及其所有父类中的共有（public）方法；<code>getDeclaredMethods()</code>获取的是当前类中的所有方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向对象的三个基本特征和五种设计原则&quot;&gt;&lt;a href=&quot;#面向对象的三个基本特征和五种设计原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象的三个基本特征和五种设计原则&quot;&gt;&lt;/a&gt;面向对象的三个基本特征和五种设计原则&lt;/h2&gt;&lt;h3 id=&quot;三个基本特征&quot;&gt;&lt;a href=&quot;#三个基本特征&quot; class=&quot;headerlink&quot; title=&quot;三个基本特征&quot;&gt;&lt;/a&gt;三个基本特征&lt;/h3&gt;&lt;h4 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h4&gt;&lt;p&gt;封装就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏；&lt;/p&gt;
&lt;h4 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h4&gt;&lt;p&gt;继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重写原有类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“父类”或“基类”。继承的过程就是从一般到特殊的过程。&lt;br&gt;要实现继承可以通过“继承”和“组合”两种方式实现。在某些OOP语言中，一个子类可以继承多个基类，但一般情况下（Java语言），一个子类只有一个基类，实现多重继承可以通过多级继承来实现。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>StackGAN: Text to Photo-realistic Image Synthesis with Stacked Generative Adversarial Networks</title>
    <link href="http://yoursite.com/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/"/>
    <id>http://yoursite.com/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/</id>
    <published>2019-02-19T09:06:58.000Z</published>
    <updated>2019-02-20T08:12:42.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p><a href="https://github.com/hanzhanggit/StackGAN" target="_blank" rel="noopener">源码地址：https://github.com/hanzhanggit/StackGAN</a></p><p>这篇文章提出<code>Stacked Generative Adversarial Networks (StackGAN)</code>合成高分辨率（$256 \times 256$）的逼真图像。这个模型将困难的图像合成问题分成两个子问题：<code>Stage-I GAN</code>根据输入的文本描述合成对象的基本形状和颜色；<code>Stage-II GAN</code>根据<code>Stage-I GAN</code>以合成的图像结果和文本描述作为输入，丰富合成图像的细节，生成逼真的高分辨率图像。 </p><p><img src="/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/StackGAN0.png" alt="image"></p><a id="more"></a> <p>我们都知道生成对抗网络的训练过程存在不稳定性，作者提出了一种新的条件增强技术促进潜在条件流形（<code>latent conditioning manifold</code>）的平滑性，从而改善了合成图像的多样性和训练生成对抗网络过程的稳定性。</p><h2 id="Stacked-Generative-Adversarial-Networks"><a href="#Stacked-Generative-Adversarial-Networks" class="headerlink" title="Stacked Generative Adversarial Networks"></a>Stacked Generative Adversarial Networks</h2><p><img src="/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/StackGAN.png" alt="image"></p><p><code>Stacked Generative Adversarial Networks</code>的结构如下图所示分为<code>Stage-I GAN</code>和<code>Stage-II GAN</code>两个子网络：  </p><ul><li><code>Stage-I GAN</code>：以文本描述和噪声向量为输入，文本描述控制对象的基本形状和颜色，噪声控制背景布局，从而生成一张低分辨率图像；</li><li><code>Stage-II GAN</code>：纠正<code>Stage-I</code>生成的低分辨率图像的缺陷，再次通过读取文本描述来补全图像的细节，从而生成高分辨率的逼真图像。</li></ul><h3 id="Stage-I-GAN"><a href="#Stage-I-GAN" class="headerlink" title="Stage-I GAN"></a>Stage-I GAN</h3><h4 id="KL散度（Kullback–Leibler-divergence-KL-divergence）"><a href="#KL散度（Kullback–Leibler-divergence-KL-divergence）" class="headerlink" title="KL散度（Kullback–Leibler divergence,KL divergence）"></a>KL散度（<code>Kullback–Leibler divergence,KL divergence</code>）</h4><p>本文章中的条件增强技术中计算标准高斯分布和条件高斯分布之间的KL散度，所以先简单介绍KL散度。<br>KL散度又被称为相对熵（<code>relative entropy</code>）或者信息散度，是连个概率分布间差异的非对称性度量。  </p><p>$$<br>KL(p(x)||q(x))=\sum_x{p(x)\log{\frac{p(x)}{q(x)}}}\\<br>=\sum_x{p(x)\log{p(x)}-p(x)\log{q(x)}}<br>$$</p><p>KL散度是衡量两个分布之间的差异大小的，KL散度大于等于0，并且越接近0说明p与q这两个分布越像，当且仅当p与q相等时KL散度取0。</p><h4 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h4><p>对于生成器$G_0$，为了获得文本条件变量$\hat{c}_0$，文本嵌入$\varphi_t$首先通过全连接层生成$\mu_0$和$\delta_0$（$\delta_0$是$\sum_0$的对角线元素值）。$\hat{c}_0$由高斯分布$N(\mu(\varphi(t)),\sum_0(\varphi(t)))$抽样得到。$N_g$维的条件向量$\hat{c}_0$由公式$\hat{c}_0=\mu_0+\delta_0 \bigodot\epsilon$计算得到，其中$\bigodot$表示元素乘积（<code>element-wise multiplication</code>），$\epsilon\sim\N(0,I)$。之后，$\hat{c}_0$与$N_z$维的噪声向量拼接并通过一系列的上采样块生成尺寸为$W_0\times H_0$的图像。<br>对于判别器$D_0$,文本嵌入$\varphi(t)$通过全连接压缩为$N_d$维然后通过复制将其转换成$M_d \times M_d \times N_d$大小的张量。同时图像经过一系列下采样块，输出$M_d \times M_d$大小的张量。最后把图像和文本得到的张量拼接在一起，经过$1\times 1$的卷积层以及一个只有一个节点的全连接层，从而得到决策值。<br>Stage-I训练过程损失函数如下，目的在于最大化$L_{D_0}$以训练判别器，最小化$L_{G_0}$以训练生成器。</p><p>$$<br>L_{D_0}=E_{(I_0,t)\sim{p_{data}}}[\log D_0(I_0,\varphi_t)]<br>+E_{z\sim{p_z},t\sim p_{data}}[\log {(1-D_0(G_0(z,\hat{c}_0),\varphi_t)}]\\<br>L_{G_0}=E_{z\sim{p_z},t\sim p_{data}}[\log {(1-D_0(G_0(z,\hat{c}_0),\varphi_t)}]+\lambda{D_{KL}}(N(\mu_0(\varphi_t),\sum_0(\varphi_t)||N(0,I)),<br>$$</p><h3 id="Stage-II-GAN"><a href="#Stage-II-GAN" class="headerlink" title="Stage-II GAN"></a>Stage-II GAN</h3><p><code>Stage-II GAN</code>的模型框架和<code>Stage-I GAN</code>相似，只不过没有了噪声输入，换成了<code>Stage-I</code>合成的低分率图像。<br>Stage-II其损失函数如下，目的在于最大化$L_D$以训练判别器，最小化$L_G$以训练生成器。  </p><p>$$<br>L_D=E_{(I,t)\sim{p_{data}}}[\log D(I,\varphi_t)]<br>+E_{s_0\sim{p_{G_0}},t\sim p_{data}}[\log {(1-D(G(s_0,\hat{c}),\varphi_t)}]\\<br>L_G=E_{s_0\sim{p_{G_0}},t\sim p_{data}}[\log {(1-D(G(s_0,\hat{c}),\varphi_t)}]+\lambda{D_{KL}}(N(\mu(\varphi_t),\sum(\varphi_t)||N(0,I)),<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/hanzhanggit/StackGAN&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码地址：https://github.com/hanzhanggit/StackGAN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章提出&lt;code&gt;Stacked Generative Adversarial Networks (StackGAN)&lt;/code&gt;合成高分辨率（$256 \times 256$）的逼真图像。这个模型将困难的图像合成问题分成两个子问题：&lt;code&gt;Stage-I GAN&lt;/code&gt;根据输入的文本描述合成对象的基本形状和颜色；&lt;code&gt;Stage-II GAN&lt;/code&gt;根据&lt;code&gt;Stage-I GAN&lt;/code&gt;以合成的图像结果和文本描述作为输入，丰富合成图像的细节，生成逼真的高分辨率图像。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/StackGAN0.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="论文阅读" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="text2image" scheme="http://yoursite.com/tags/text2image/"/>
    
      <category term="图像合成" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/"/>
    
      <category term="生成对抗网络" scheme="http://yoursite.com/tags/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型（二）</title>
    <link href="http://yoursite.com/2019/02/19/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/19/Java内存模型（二）/</id>
    <published>2019-02-19T07:05:28.000Z</published>
    <updated>2019-02-19T08:35:29.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的手段。</p><h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>如果两个操作访问同一个变量，且这两个操作中有一为写操作，此时这两个操作时间就存在数据依赖性。数据依赖分为三种类型：写后读、写后写、读后写。<br>上述三种情况，只要重排序这两个操作的执行顺序，程序的执行结果就会改变。因此编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作顺序。<br>这类所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。<br><a id="more"></a> </p><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a><code>as-if-serial</code>语义</h3><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不会被改变。as-if-serial语义把单线程程序保护起来，遵循as-if-serial语义的编译器、runtime和处理器保证单线程程序执行的结果与其按照顺序执行的结果一致。</p><h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;           //A</span><br><span class="line">double r = 1.0;             //B</span><br><span class="line">double area = pi * r * r;   //C</span><br></pre></td></tr></table></figure><p>根据happens-before的程序顺序规则，上面计算圆面积的示例代码存在3个happens-before关系：  </p><ul><li><code>A happens-before B</code></li><li><code>B happens-before C</code></li><li><code>A happens-before C</code></li></ul><p>这里<code>A happens-before B</code>，但在实际执行时B却可以在A之前执行。如果<code>A happens-before B</code>，JMM并不一定要求A在B之前执行。JMM仅仅要求前一个操作对后一个操作可见，且前一个操作按顺序排在后一操作之前。这里操作A的执行结果并不需要对操作B可见；而且重排序操作A和操作B后的执行结果，与操作A和操作B按照<code>A happens-before B</code>顺序执行的结果一致。在这种情况下，JMM会认为这种重排序不非法（not illegal）,JMM允许这种重排序。<br>在计算机中，软件技术和硬件技术有一个共同目的：在不改变程序执行结果的前提下，尽可能提高并行度。</p><h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><p>多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><h3 id="数据竞争与顺序一致性"><a href="#数据竞争与顺序一致性" class="headerlink" title="数据竞争与顺序一致性"></a>数据竞争与顺序一致性</h3><p>当程序未正确同步时，就可能会存在数据竞争。Java内存模型规范对数据竞争的定义如下：  </p><ul><li>在一个线程中写入一个变量；</li><li>在另一个线程中读同一个变量；</li><li>而且写和读没有通过同步来排序。  </li></ul><p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果。如果一个多线程程序能够同步，这个程序将是一个没有数据竞争的程序。JMM对正确同步的多线程程序的内存一致性做了如下保证：<br>如果程序时正确同步的，程序的执行将具有顺序一致性——即程序的执行结果与改程序在顺序一致性内存模型中的执行结果相同。</p><h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>顺序一致性内存模型是一个被计算机科学家理想化的理论参考模型。它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：  </p><ul><li>一个线程中的所有操作都必须按照程序的顺序来执行；</li><li>（不管线程是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;h2 id=&quot;重排序&quot;&gt;&lt;a href=&quot;#重排序&quot; class=&quot;headerlink&quot; title=&quot;重排序&quot;&gt;&lt;/a&gt;重排序&lt;/h2&gt;&lt;p&gt;重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的手段。&lt;/p&gt;
&lt;h3 id=&quot;数据依赖性&quot;&gt;&lt;a href=&quot;#数据依赖性&quot; class=&quot;headerlink&quot; title=&quot;数据依赖性&quot;&gt;&lt;/a&gt;数据依赖性&lt;/h3&gt;&lt;p&gt;如果两个操作访问同一个变量，且这两个操作中有一为写操作，此时这两个操作时间就存在数据依赖性。数据依赖分为三种类型：写后读、写后写、读后写。&lt;br&gt;上述三种情况，只要重排序这两个操作的执行顺序，程序的执行结果就会改变。因此编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作顺序。&lt;br&gt;这类所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="重排序" scheme="http://yoursite.com/tags/%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    
      <category term="数据依赖性" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E6%80%A7/"/>
    
      <category term="顺序一致性" scheme="http://yoursite.com/tags/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
</feed>
