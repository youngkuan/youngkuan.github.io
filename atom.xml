<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yangkuan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-30T13:33:43.966Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yang Kuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字节跳动实习生面试</title>
    <link href="http://yoursite.com/2019/03/30/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/03/30/字节跳动实习生面试/</id>
    <published>2019-03-30T13:20:08.000Z</published>
    <updated>2019-03-30T13:33:43.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ol><li>垃圾回收讲一下；</li><li>java内存模型；<blockquote><ul><li>垃圾回收算法（如何确定回收对象（引用计数法、可达性算法）、回收算法（标记回收、标记整理、复制））；</li><li>垃圾收集器；</li><li>MySQL数据库讲一下；数据引擎、索引类型、索引方法（B+树、Hash）<a id="more"></a> </li></ul></blockquote></li><li>手写代码：根据前序遍历和中序遍历还原二叉树，根据获得的前序遍历和中序遍历结果输出一颗二叉树（输出后续遍历）（我问可以IDE吗？尽量别用）<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2></li><li><p>手写代码： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单链表操作：   </span><br><span class="line"> 输入：奇数位升序，偶数位降序  </span><br><span class="line"> 1 -&gt; 80 -&gt; 4 -&gt; 60 -&gt; 6 -&gt; 40 -&gt; 7 -&gt; 2    </span><br><span class="line">输出：升序单链表  </span><br><span class="line"> 1 -&gt; 2 -&gt; 4 -&gt; 6-&gt; 7 -&gt; 40 -&gt; 60 -&gt; 80  </span><br><span class="line">不允许使用其他数据结构。</span><br></pre></td></tr></table></figure></li><li><p>进程和线程的区别</p></li><li>HashMap</li><li>TCP/UDP<h2 id="三面-两道编程题："><a href="#三面-两道编程题：" class="headerlink" title="三面-两道编程题："></a>三面-两道编程题：</h2><ol><li>假定一张表的数据格式为 id,name,parentId，表的数据不大，1000条以内，得到这些数据的树型结构    输入：List<user> ， 输出：Node（手写代码）</user></li></ol></li><li>有2个文件，分别是A(3t大小)，B(2t)大小，A文件的组织形式为 uid, username,B文件的组织形式为 uid, age,找出A、B文件交集的数据放入一个文件，文件的数据格式为uid,username,age（讲讲思路）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;垃圾回收讲一下；&lt;/li&gt;
&lt;li&gt;java内存模型；&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;垃圾回收算法（如何确定回收对象（引用计数法、可达性算法）、回收算法（标记回收、标记整理、复制））；&lt;/li&gt;
&lt;li&gt;垃圾收集器；&lt;/li&gt;
&lt;li&gt;MySQL数据库讲一下；数据引擎、索引类型、索引方法（B+树、Hash）&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="工作" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="实习" scheme="http://yoursite.com/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="字节跳动" scheme="http://yoursite.com/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Deep Residual Learning for Image Recognition</title>
    <link href="http://yoursite.com/2019/03/06/Deep-Residual-Learning-for-Image-Recognition/"/>
    <id>http://yoursite.com/2019/03/06/Deep-Residual-Learning-for-Image-Recognition/</id>
    <published>2019-03-06T12:49:41.000Z</published>
    <updated>2019-03-07T03:12:31.558Z</updated>
    
    <content type="html"><![CDATA[<p>神经网络越深就越难训练，作者提出一种残差学习框架来降低网络训练的难度。<br><a id="more"></a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;神经网络越深就越难训练，作者提出一种残差学习框架来降低网络训练的难度。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="图像识别" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
      <category term="残差网络" scheme="http://yoursite.com/tags/%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9C/"/>
    
      <category term="神经网络" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="论文阅读" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper-分布式应用程序协调服务</title>
    <link href="http://yoursite.com/2019/03/06/ZooKeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/03/06/ZooKeeper-分布式应用程序协调服务/</id>
    <published>2019-03-06T06:51:32.000Z</published>
    <updated>2019-03-06T08:26:16.895Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://developer.51cto.com/art/201809/583184.htm" target="_blank" rel="noopener">参考链接</a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Apache ZooKeeper is an effort to develop and maintain an open-source server which enables highly reliable distributed coordination.</p><p>Apache ZooKeeper致力于开发和维护一个支持高度可靠的分布式协调的开源服务器。<br><a id="more"></a><br>Zookeeper是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于Zookeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。  </p><h2 id="Znode"><a href="#Znode" class="headerlink" title="Znode"></a>Znode</h2><p>在ZooKeeper中，“节点”分为两种类型：</p><ul><li>第一类是指构成集群的机器，称之为机器节点；</li><li>第二类则是指数据模型中的数据单元，我们称之为数据节点-Znode。</li></ul><p>ZooKeeper将所有的数据存储在内存中，数据模型是一棵树（Znode Tree）</p><h2 id="ZooKeeper集群介绍介绍"><a href="#ZooKeeper集群介绍介绍" class="headerlink" title="ZooKeeper集群介绍介绍"></a>ZooKeeper集群介绍介绍</h2><p>ZooKeeper集群中的所有机器通过Leader选举过程来选定一台称为“Leader”的机器，Leader既可以为客户端提供写服务又能提供读服务。出Leader外，Follower和Observer只能提供读服务。</p><p>Follower与Observer的唯一区别在于Observer机器不参与Leader的选举过程，也不参与写操作的“过半写成功”策略，因此Observer机器可以在不影响写性能的情况下提升集群的读性能。</p><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>ZAB（ZooKeeper Atomic Broadcast，ZooKeeper原子广播）协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的原子广播协议。</p><p>在ZooKeeper中，主要依赖ZAB协议来实现分布式数据一致性，基于该协议ZooKeeper实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p><p>ZAB协议包括两种基本模式，分别是崩溃恢复和消息广播。<br>当整个服务框架在启动过程中，或是当Leader服务器出现网络中断、崩溃退出与重启等异常情况是，ZAB协议就会进入恢复模式并选举出新的Leader服务器。<br>当选举产生的新的Leader服务器，同时集群中已经有过半的机器与新Leader服务器完成状态同步之后，ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，也就是保证集群中过半的机器与该Leader服务器的数据状态一致。<br>当集群中已经有过半的Follower服务器完成与Leader服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。<br>当一台同样遵守ZAB协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个Leader服务器在负责消息广播，那么新加入的服务器就会自觉地进去数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p><p>正如上文所述，ZooKeeper被设计成只允许唯一的Leader服务器进行事务请求的处理，Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议。如果集群中的其他机器接收到客户端事务请求，那么这些非Leader服务器会首先将这个事务转发给Leader服务器。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在我们的智慧教育示范应用中，主要是使用Kafka收集用户日志，而ZooKeeper就担任了服务生产者和消费者的注册中心。<br>服务生产者将自己提供的服务注册到ZooKeeper中心，服务消费者在进行服务调用的时候先到ZooKeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容和数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://developer.51cto.com/art/201809/583184.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;Apache ZooKeeper is an effort to develop and maintain an open-source server which enables highly reliable distributed coordination.&lt;/p&gt;
&lt;p&gt;Apache ZooKeeper致力于开发和维护一个支持高度可靠的分布式协调的开源服务器。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/categories/ZooKeeper/"/>
    
    
      <category term="开源软件" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>条件生成对抗网络的一系列问题</title>
    <link href="http://yoursite.com/2019/03/05/%E6%9D%A1%E4%BB%B6%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/05/条件生成对抗网络的一系列问题/</id>
    <published>2019-03-05T13:30:04.000Z</published>
    <updated>2019-03-06T05:18:26.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条件生成对抗网络中生成器的输入随机噪声z，文本特征-phi-t-作为条件，噪声输入有什么用？"><a href="#条件生成对抗网络中生成器的输入随机噪声z，文本特征-phi-t-作为条件，噪声输入有什么用？" class="headerlink" title="条件生成对抗网络中生成器的输入随机噪声z，文本特征$\phi(t)$作为条件，噪声输入有什么用？"></a>条件生成对抗网络中生成器的输入随机噪声<code>z</code>，文本特征$\phi(t)$作为条件，噪声输入有什么用？</h2><p><a href="https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/issues/152" target="_blank" rel="noopener">参考链接：https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/issues/152</a></p><p>其实没有噪声输入也可以，但是有时候需要同一个文本输入需要生成的样本更加多样，这时候随机噪声就有用了。<br><a id="more"></a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;条件生成对抗网络中生成器的输入随机噪声z，文本特征-phi-t-作为条件，噪声输入有什么用？&quot;&gt;&lt;a href=&quot;#条件生成对抗网络中生成器的输入随机噪声z，文本特征-phi-t-作为条件，噪声输入有什么用？&quot; class=&quot;headerlink&quot; title=&quot;条件生成对抗网络中生成器的输入随机噪声z，文本特征$\phi(t)$作为条件，噪声输入有什么用？&quot;&gt;&lt;/a&gt;条件生成对抗网络中生成器的输入随机噪声&lt;code&gt;z&lt;/code&gt;，文本特征$\phi(t)$作为条件，噪声输入有什么用？&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/issues/152&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接：https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/issues/152&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实没有噪声输入也可以，但是有时候需要同一个文本输入需要生成的样本更加多样，这时候随机噪声就有用了。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="论文阅读" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="生成对抗网络" scheme="http://yoursite.com/tags/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/"/>
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数据库范式</title>
    <link href="http://yoursite.com/2019/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/04/数据库范式/</id>
    <published>2019-03-04T13:36:33.000Z</published>
    <updated>2019-03-04T14:17:06.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h2><p>关系模型中实体的每个属性都是原子属性，即元组在每个属性上的取值是不可分的。也就是说这些属性的取值是单一的，不是集合、数组等非原子数据。当实体中的某个属性都多个值时，必须将该属性拆分为多个原子属性。</p><a id="more"></a> <h2 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h2><p><strong>关系模型中的所有非主属性都完全依赖于所有的候选键</strong>。2NF其实就是在1NF的基础上消除那些非主属性对所有候选键的部分函数依赖。<br>例如，关系（学号，课程号，教师，成绩，学院）中，教师部分依赖于课程号，因此这个关系不满足第二范式，所以需要把上述关系拆分成（学号，课程号，成绩）和（课程号，教师，学院）。</p><h2 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h2><p><strong>关系模型中的非主属性既不部分函数依赖也不传递函数依赖于关系中的所有候选键</strong>。也就是说3NF是在2NF的基础上消除了非主属性对候选键的传递依赖关系。</p><p>还是上面的例子，关系（课程号，教师，学院）中存在传递依赖关系课程号-&gt;教师，以及教师-&gt;学院，因此不满足3NF。所以将其分解为（课程号，教师）和（教师，学院）。</p><h2 id="巴斯-科德范式（BCNF）"><a href="#巴斯-科德范式（BCNF）" class="headerlink" title="巴斯-科德范式（BCNF）"></a>巴斯-科德范式（BCNF）</h2><p><strong>对于关系R上的任何非平凡函数依赖X-&gt;Y都有X必包含R的某个候选键</strong>，那么就称关系R满足BCNF。BCNF是在第三范式的基础上继续消除主属性对于键的部分依赖和传递依赖。  </p><p>举个例子来说，关系（课程名，班级，教师）中假定多名教师承担多个班级的教学任务，每个教师仅承担一个课程的教学任务，同时可以给多个班级上课，那么可以知道有函数依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(课程名，班级)-&gt;(教师)</span><br><span class="line">(教师)-&gt;(课程名)</span><br></pre></td></tr></table></figure><p>然而，上述关系中的主键是(课程名，班级)或者(教师，班级)。所以<code>(教师)-&gt;(课程名)</code>就是主属性对候选键的部分依赖，不满足BCNF。</p><h2 id="第四范式（4NF）"><a href="#第四范式（4NF）" class="headerlink" title="第四范式（4NF）"></a>第四范式（4NF）</h2><p>对于关系R中的非平凡多值依赖X-&gt;-&gt;Y，X必包含R的某个候选键，则称满足4NF。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一范式（1NF）&quot;&gt;&lt;a href=&quot;#第一范式（1NF）&quot; class=&quot;headerlink&quot; title=&quot;第一范式（1NF）&quot;&gt;&lt;/a&gt;第一范式（1NF）&lt;/h2&gt;&lt;p&gt;关系模型中实体的每个属性都是原子属性，即元组在每个属性上的取值是不可分的。也就是说这些属性的取值是单一的，不是集合、数组等非原子数据。当实体中的某个属性都多个值时，必须将该属性拆分为多个原子属性。&lt;/p&gt;
    
    </summary>
    
      <category term="工程" scheme="http://yoursite.com/categories/%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="范式" scheme="http://yoursite.com/tags/%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器</title>
    <link href="http://yoursite.com/2019/02/28/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2019/02/28/垃圾收集器/</id>
    <published>2019-02-28T02:28:49.000Z</published>
    <updated>2019-02-28T10:54:47.229Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾收集算法是内存回收的方法论，垃圾收集器是垃圾回收的具体实现。在JDK1.7 Update 14之后的HotSpot虚拟机所包含的收集器如下图所示：</p><p><img src="/2019/02/28/垃圾收集器/垃圾收集器1.jpg" alt="垃圾收集器"></p><a id="more"></a> <h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>Serial收集器是最基本、发展历史最悠久的收集器。这是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Serial收集器运行示意图如下：</p><p><img src="/2019/02/28/垃圾收集器/垃圾收集器2.jpg" alt="垃圾收集器"></p><p>也就是说，虚拟机在使用Serial垃圾收集器时会在用户不可见的情况下把所有用户正常工作的线程暂停，这种“Stop The World”操作在很多程序中是难以接受的，带给用户不良体验。<br>举个例子“你妈妈在打扫房间的时候，肯定也会让你老老实实待在椅子上或者房间外待着，如果她一边打扫，你一边丢垃圾，这房间还能打扫完？你妈妈不会崩溃？”，因此看起来“Stop The World”操作情有可原。<br>但是，从JDK1.3开始，HotSpot虚拟机开发团队一直在努力消除或减少工作线程因内存回收而导致的停顿，从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）乃至GC收集器最前沿的成果Garbage First（G1）收集器，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除垃圾回收带来的停顿。<br>Serial收集器虽然很老，可以说很陈旧，但是目前为止它依旧是虚拟机运行在Client模式下的默认新生代收集器。那是因为Serial收集器简单而高效，对于限定单个GPU的情况而言，Serial收集器由于没有线程交互的开销，专心进行垃圾收集自然可以获得最高的单线程收集效率。  </p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew收集器就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为包括Serial收集器的所有可用控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样。ParNew收集器进行垃圾收集的示意图如下：  </p><p><img src="/2019/02/28/垃圾收集器/垃圾收集器3.jpg" alt="垃圾收集器"></p><p>ParNew收集器除了多线程收集外，其他与Serial收集器相比没有太多创新之处，但它却是虚拟机运行在Server模式下的首选新生代收集器，其中一个与性能无关的重要原因是除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器也是新生代收集器，并且使用复制算法收集内存，同时还是并行的多线程收集器。这些特点都和ParNew收集器一样，但是Parallel Scavenge收集器的目标在于达到一个可控制的<strong>吞吐量</strong>（Throughput），所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码/(运行用户代码+垃圾收集时间)。这与CMS等收集器的目标不同，它们目标是尽可能地缩短垃圾收集时间用户线程的停顿时间。<br>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多的交互任务。<br>Parallel Scavenge收集器提供两个参数用于精准控制吞吐量，分别是控制最大垃圾收集时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。<br><strong>MaxGCPauseMillis</strong>参数允许的值是一个大于0的毫秒数，收集器将尽可能在规定时间内完成垃圾收集操作。但是不要认为这个参数越小，系统的垃圾收集速度就会越快，GC停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一点，收集300M新生代肯定比收集500M新生代快，这也将导致垃圾收集更频繁，原来每20s收集一次、一次100ms，现在每10s收集一次、一次70ms。停顿时间的确下降了，但吞吐量也降下来了。<br><strong>GCTimeRatio</strong>参数的值应当是一个大于0小于100的整数，如果把这个参数设置为19，那么允许最大GC时间就占总时间的5%（即1/(1+19)）。<br>Parallel Scavenge收集器还有一个参数-XX:+UseAdaptiveSizePolicy，这个参数打开之后就不需要手动指定新生代的大小（-Xmm）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最适合的停顿时间或者最大吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。  </p><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法，这个收集器的主要意义也是在于给Client模式下的虚拟机使用。<br>在Server模式下，它有两大用途：  </p><ul><li>在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用；</li><li>作为CMS收集器的后备方案，在并发收集发生Concurrent Mode Failure时使用。  </li></ul><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。在JDK1.6之前Parallel Scavenge只能与Serial Old收集器配合使用，由于老年代使用单线程收集内存无法充分利用服务器多CPU的处理能力，这个组合就导致无法达到高吞吐量。在JDK1.6开始提供了Parallel Old收集器和Parallel Scavenge收集器配合使用，从而可以应用在注重吞吐量以及CPU资源敏感的场合。</p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。从名字（包含“Mark Sweep”）就可以看出来，CMS收集器是基于“标记——清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p><ul><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ul><p>其中，初始标记、重新标记这；两个步骤仍需要“Stop The World”。初始标记是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段是为了修正并发标记阶段因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这一阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记阶段的时间短。整个过程中耗时最长的并发标记和并发清除阶段都是与用户线程一起工作，如下图所示：</p><p><img src="/2019/02/28/垃圾收集器/垃圾收集器5.png" alt="垃圾收集器"></p><p>CMS是一款优秀的收集器，它的主要优点是并发收集、低停顿，但是它还有以下三个明显缺点：</p><ul><li>CMS收集器对CPU资源非常敏感；</li><li>CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次的Full GC。</li><li>CMS收集器是基于“标记-清除”算法实现的，在收集结束会产生大量的空间碎片。为了解决这个问题，CMS收集器提供了一个-XX:+USeCMSCompactAtFullCollection开关参数用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程。</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1收集器是当前收集技术最前沿的成果之一，它被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。G1是一款面向服务端应用的垃圾收集器，与其他收集器相比，G1具备如下特点：</p><ul><li>并行与并发</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li></ul><p>在G1之前的其他收集器进行收集的范围是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大区别，它将整个Java堆划分成多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垃圾收集算法是内存回收的方法论，垃圾收集器是垃圾回收的具体实现。在JDK1.7 Update 14之后的HotSpot虚拟机所包含的收集器如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/02/28/垃圾收集器/垃圾收集器1.jpg&quot; alt=&quot;垃圾收集器&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="垃圾收集器" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
      <category term="垃圾收集算法" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程基础</title>
    <link href="http://yoursite.com/2019/02/27/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/02/27/Java并发编程基础/</id>
    <published>2019-02-27T13:49:16.000Z</published>
    <updated>2019-03-01T14:26:51.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>现代操作系统在运行一个程序的时候就会创建一个进程。线程是现在操作系统系统调度的最小单元，也称为轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，每个线程都有自己的程序计数器、堆栈和局部变量等属性，并且能够访问内存中共享的变量。</p><h3 id="使用多线程的原因"><a href="#使用多线程的原因" class="headerlink" title="使用多线程的原因"></a>使用多线程的原因</h3><ol><li>更多的处理器核心：随着处理器上的核心数量越来越多，以及超线程技术的广泛应用，现在的计算机比以往更加擅长并行计算；</li><li>更快的响应时间：当业务逻辑过于复杂，使用多线程技术，将对数据一致性要求不高的操作派发给多个线程处理，这样做能更快地处理完一个复杂任务，缩短响应时间，提升用户体验；</li><li>更好的编程模型：Java为多线程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决，即为所遇到的问题建立合适的模型，而不是绞尽脑汁地考虑如何将任务多线程化。</li></ol><a id="more"></a><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法修改线程的优先级，默认优先级为5，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞的线程则设置较低的优先级，保证处理器不会被独占。</p><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>Java线程在运行的生命周期可能处于6种不同的状态，在任意给定时刻线程只能处于其中的一种状态：</p><table><thead><tr><th>状态名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>NEW</td><td style="text-align:center">初始状态，线程被构建，但是还没有调用start()方法</td></tr><tr><td>RUNNABLE</td><td style="text-align:center">运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称为“运行中”</td></tr><tr><td>BLOCKED</td><td style="text-align:center">阻塞状态，表示线程阻塞于锁</td></tr><tr><td>WAITING</td><td style="text-align:center">等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td>TIME_WAITING</td><td style="text-align:center">超时等待状态，该状态不同于WAITING，它是可以在指定时间自行返回的</td></tr><tr><td>TERMINATED</td><td style="text-align:center">终止状态，表示当前线程已经执行完毕</td></tr></tbody></table><h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程时，Java虚拟机将会退出。可以在线程启动之前通过调用Thread.setDaemon(true)将线程设置为Daemon线程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h2&gt;&lt;p&gt;现代操作系统在运行一个程序的时候就会创建一个进程。线程是现在操作系统系统调度的最小单元，也称为轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，每个线程都有自己的程序计数器、堆栈和局部变量等属性，并且能够访问内存中共享的变量。&lt;/p&gt;
&lt;h3 id=&quot;使用多线程的原因&quot;&gt;&lt;a href=&quot;#使用多线程的原因&quot; class=&quot;headerlink&quot; title=&quot;使用多线程的原因&quot;&gt;&lt;/a&gt;使用多线程的原因&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;更多的处理器核心：随着处理器上的核心数量越来越多，以及超线程技术的广泛应用，现在的计算机比以往更加擅长并行计算；&lt;/li&gt;
&lt;li&gt;更快的响应时间：当业务逻辑过于复杂，使用多线程技术，将对数据一致性要求不高的操作派发给多个线程处理，这样做能更快地处理完一个复杂任务，缩短响应时间，提升用户体验；&lt;/li&gt;
&lt;li&gt;更好的编程模型：Java为多线程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决，即为所遇到的问题建立合适的模型，而不是绞尽脑汁地考虑如何将任务多线程化。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
      <category term="volatile" scheme="http://yoursite.com/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu配置shadowsocks科学上网</title>
    <link href="http://yoursite.com/2019/02/26/Ubuntu%E9%85%8D%E7%BD%AEshadowsocks%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://yoursite.com/2019/02/26/Ubuntu配置shadowsocks科学上网/</id>
    <published>2019-02-26T04:36:59.000Z</published>
    <updated>2019-02-26T12:08:14.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网1.png" alt="科学上网"></p><h2 id="showsocks配置"><a href="#showsocks配置" class="headerlink" title="showsocks配置"></a>showsocks配置</h2><ol><li>安装shadowsocks客户端,命令如下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install shadowsocks</span><br></pre></td></tr></table></figure><a id="more"></a> <ol start="2"><li>查看shadowsocks命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal --help</span><br></pre></td></tr></table></figure><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网2.png" alt="科学上网"></p><ol start="3"><li>启动shadowsocks两种方式：</li></ol><ul><li>通过设置各个参数，如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -s 11.22.33.44 -p 50003 -k &quot;123456&quot; -l 1080 -t 600 -m aes-256-cfb</span><br></pre></td></tr></table></figure><ul><li>或者，直接加载json配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c file_path/shadowsocks.json</span><br></pre></td></tr></table></figure><p>启动shadowsocks如下所示：</p><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网3.png" alt="科学上网"></p><p>配置好shadowsocks客户端后，我们介绍一下三种方式设置代理模式。</p><h2 id="方式一：不要关闭上面的终端，重新打开一个终端，配置全局变量："><a href="#方式一：不要关闭上面的终端，重新打开一个终端，配置全局变量：" class="headerlink" title="方式一：不要关闭上面的终端，重新打开一个终端，配置全局变量："></a>方式一：不要关闭上面的终端，重新打开一个终端，配置全局变量：</h2><p>使用<code>vim ~/.bashrc</code>添加语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias hp=&quot;http_proxy=http://localhost:8123&quot;</span><br></pre></td></tr></table></figure></p><p>使用<code>source ~/.bashrc</code>使更改生效。</p><ol start="5"><li>测试效果</li></ol><ul><li>使用命令<code>hp curl ip.gs</code>查看代理服务器网址，结果如下所示：</li></ul><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网4.png" alt="科学上网"></p><p>可以看出，<code>alias hp=&quot;http_proxy=http://localhost:8123&quot;</code>这句语句的作用就是用命令<code>hp</code>替换<code>http_proxy=http://localhost:8123</code>这一串长命令。</p><h2 id="那我们不想每条指令前面都加上命令hp怎么办，这就需要设置全局代理："><a href="#那我们不想每条指令前面都加上命令hp怎么办，这就需要设置全局代理：" class="headerlink" title="那我们不想每条指令前面都加上命令hp怎么办，这就需要设置全局代理："></a>那我们不想每条指令前面都加上命令<code>hp</code>怎么办，这就需要设置全局代理：</h2><h3 id="方式二：为当前窗口设置全局代理"><a href="#方式二：为当前窗口设置全局代理" class="headerlink" title="方式二：为当前窗口设置全局代理"></a>方式二：为当前窗口设置全局代理</h3><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://localhost:8123 # 当前终端使用代理</span><br><span class="line">unset http_proxy # 当前终端取消代理</span><br></pre></td></tr></table></figure></p><p>测试如下所示，可以看出上设置全局代理后，就不需要<code>hp</code>命令了，取消代理（<code>unset</code>）后可以看到<code>ip</code>变成了陕西西安。<br><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网5.png" alt="科学上网"></p><h3 id="方式三：设置当前用户的全局代理"><a href="#方式三：设置当前用户的全局代理" class="headerlink" title="方式三：设置当前用户的全局代理"></a>方式三：设置当前用户的全局代理</h3><p>在<code>~/.bashrc</code>中添加<code>export http_proxy=http://localhost:8123</code>命令设置当前用户的全局代理。别忘了使用<code>source ~/.bashrc</code>使更改生效。</p><p>如下所示，</p><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网6.png" alt="科学上网"></p><h2 id="经过测试，推荐方式二为当前窗口设置全局代理，命令如下："><a href="#经过测试，推荐方式二为当前窗口设置全局代理，命令如下：" class="headerlink" title="经过测试，推荐方式二为当前窗口设置全局代理，命令如下："></a>经过测试，推荐方式二为当前窗口设置全局代理，命令如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://localhost:8123 # 当前终端使用代理</span><br><span class="line">unset http_proxy # 当前终端取消代理</span><br></pre></td></tr></table></figure><p>这种方式可以开启一个窗口运行export作为科学上网窗口，而其他窗口依旧正常上网，这样可以<strong>节约流量</strong>。<br>除此之外，这是我测试的上述三种上网方式中最稳定的一种，建议使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>配置好之后，科学上网的过程，先打开一个终端窗口，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c file_path/shadowsocks.json</span><br></pre></td></tr></table></figure><p>再打开新窗口，运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://localhost:8123</span><br></pre></td></tr></table></figure></p><p>我使用R-3D中下载YouTube视频的代码作为测试，运行<code>python download_video.py</code>就可以看到下载视频并保存在当前目录的videos目录下。</p><p>示意结果如下，<code>sslocal -c shadowsocks.json</code>启动窗口下方会出现与<code>www.youtube.com</code>连接的日志信息：</p><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网7.png" alt="科学上网"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;系统环境&quot;&gt;&lt;a href=&quot;#系统环境&quot; class=&quot;headerlink&quot; title=&quot;系统环境&quot;&gt;&lt;/a&gt;系统环境&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网1.png&quot; alt=&quot;科学上网&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;showsocks配置&quot;&gt;&lt;a href=&quot;#showsocks配置&quot; class=&quot;headerlink&quot; title=&quot;showsocks配置&quot;&gt;&lt;/a&gt;showsocks配置&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装shadowsocks客户端,命令如下&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt install shadowsocks&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="工程" scheme="http://yoursite.com/categories/%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
      <category term="shadowsocks" scheme="http://yoursite.com/tags/shadowsocks/"/>
    
      <category term="科学上网" scheme="http://yoursite.com/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
      <category term="代理" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%90%86/"/>
    
      <category term="proxy" scheme="http://yoursite.com/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>面向切面编程</title>
    <link href="http://yoursite.com/2019/02/21/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/21/面向切面编程/</id>
    <published>2019-02-21T09:08:56.000Z</published>
    <updated>2019-03-09T14:10:14.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向切面编程（Aspect-Oriented-Programming，AOP）是什么？"><a href="#面向切面编程（Aspect-Oriented-Programming，AOP）是什么？" class="headerlink" title="面向切面编程（Aspect Oriented Programming，AOP）是什么？"></a>面向切面编程（Aspect Oriented Programming，AOP）是什么？</h2><ol><li>AOP是一种编程范式，不是编程语言；</li><li>AOP解决特定问题，但不能解决所有问题；</li><li>OOP的补充，而不是其替代。<a id="more"></a> </li></ol><h2 id="AOP为什么出现？"><a href="#AOP为什么出现？" class="headerlink" title="AOP为什么出现？"></a>AOP为什么出现？</h2><ol><li>提高代码重用性；</li><li>概念分离：分离功能性需求和非功能性需求。将功能性需求从非功能性需求中分离出来。</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>权限控制</li><li>缓存控制</li><li>事务控制</li><li>审计日志</li><li>性能监控</li><li>分布式追踪</li><li>异常处理</li></ol><h2 id="Spring-AOP的通过代理实现"><a href="#Spring-AOP的通过代理实现" class="headerlink" title="Spring AOP的通过代理实现"></a>Spring AOP的通过代理实现</h2><p>通过DefaultAopProxyFactory.java源码可以看到AOP由jdk和cglib两种方式实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        if (targetClass == null) &#123;</span><br><span class="line">            throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +</span><br><span class="line">                    &quot;Either an interface or a target is required for proxy creation.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            return new JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        return new ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return new JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Spring-AOP的使用"><a href="#Spring-AOP的使用" class="headerlink" title="Spring AOP的使用"></a>Spring AOP的使用</h2><p>在Spring中主要使用注解@Aspect、@Pointcut、@Before、@After、@AfterReturning、@AfterThrowing以及@Around进行面向切面编程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface Aspect &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Per clause expression, defaults to singleton aspect</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * Valid values are &quot;&quot; (singleton), &quot;perthis(...)&quot;, etc</span><br><span class="line">     */</span><br><span class="line">    public String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码是@Aspect注解的定义，ElementType.TYPE可以看出该注解作用目标是接口、类、枚举、注解，@Aspect注解，Spring通过@Aspect注解切面并把它应用到目标对象上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface Pointcut &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The pointcut expression</span><br><span class="line">     * We allow &quot;&quot; as default for abstract pointcut</span><br><span class="line">     */</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * When compiling without debug info, or when interpreting pointcuts at runtime,</span><br><span class="line">     * the names of any arguments used in the pointcut are not available.</span><br><span class="line">     * Under these circumstances only, it is necessary to provide the arg names in </span><br><span class="line">     * the annotation - these MUST duplicate the names used in the annotated method.</span><br><span class="line">     * Format is a simple comma-separated list.</span><br><span class="line">     */</span><br><span class="line">    String argNames() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码是@Pointcut注解的定义，value()用来定义切面所在的位置，定义方式有以下几种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// execution定义切面，匹配符合表达式的所有方法</span><br><span class="line">@Pointcut(&quot;execution(* com.xjtu.springbootstudy.aop.bymyself.service.ProgrammerService.work())&quot;)</span><br><span class="line">// within用于匹配类，对应类下的所有方法都执行切面方法；</span><br><span class="line">@Pointcut(&quot;within(com.xjtu.springbootstudy.aop.bymyself.service.*)&quot;)</span><br><span class="line">// @annotation用于匹配自定义注解，如下面的@SignLog注解，再将@SignLog放在想定义切面的方法</span><br><span class="line">@Pointcut(&quot;@annotation(com.xjtu.springbootstudy.aop.bymyself.annotation.SignLog)&quot;)</span><br><span class="line">// @within用于匹配自定义注解，如下面的@SignLog注解，再将@SignLog放在想定义切面的类上</span><br><span class="line">@Pointcut(&quot;@within(com.xjtu.springbootstudy.aop.bymyself.annotation.SignLog))&quot;)</span><br><span class="line">public void log()&#123; &#125;</span><br></pre></td></tr></table></figure></p><p>如上对log()添加注解，@Pointcut注解中value定义切面位置，使用execution、within、@annotation、@within等方式设置切面。</p><ul><li>@before在目标方法开始执行时执行；</li><li>@after在目标方法执行结束前执行；</li><li>@AfterReturning在目标方法执行正确返回前执行；</li><li>@AfterThrowing在目标方法执行异常时执行，</li><li>@Around环绕执行，一般是前4个无法实现期望功能时，才使用这个注解。</li></ul><p>我写了一个简单示意切面程序，如下所示，对应执行结果也展示下下方。有个疑问就是@after和@AfterReturning注解的方法谁<strong>先执行</strong>？根据执行结果也可以看出<br><strong>@after</strong>注解的方法<strong>先执行</strong>，@AfterReturning注解的方法后执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Before(value = &quot;log()&quot;)</span><br><span class="line">public void signIn(JoinPoint joinPoint)&#123;</span><br><span class="line">    logger.info(&quot;***********the people signs in******&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@After(value = &quot;log()&quot;)</span><br><span class="line">public void leaveWorkPlace(JoinPoint joinPoint)&#123;</span><br><span class="line">    logger.info(&quot;***********the people leaves workplace******&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@AfterReturning(value = &quot;log()&quot;)</span><br><span class="line">public void signOut(JoinPoint joinPoint)&#123;</span><br><span class="line">    logger.info(&quot;***********the people signs out successfully******&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@AfterThrowing(value = &quot;log()&quot;,throwing = &quot;throwable&quot;)</span><br><span class="line">public void happenAccidentWhenWorking(JoinPoint joinPoint,Throwable throwable)&#123;</span><br><span class="line">    logger.info(&quot;***********the people happens accident when working******&quot;);</span><br><span class="line">    logger.info(&quot;***********&quot;+throwable.getMessage()+&quot;***********&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Around(value = &quot;log()&quot;)</span><br><span class="line">public void happenAround(ProceedingJoinPoint joinPoint)&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        joinPoint.proceed(joinPoint.getArgs());</span><br><span class="line">    &#125; catch (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">***********the people signs in******                // @before</span><br><span class="line">I&apos;m working in workplace!                           // 这是目标方法的执行结果</span><br><span class="line">***********the people leaves workplace******        // @after</span><br><span class="line">***********the people signs out successfully******  // @afterReturning</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向切面编程（Aspect-Oriented-Programming，AOP）是什么？&quot;&gt;&lt;a href=&quot;#面向切面编程（Aspect-Oriented-Programming，AOP）是什么？&quot; class=&quot;headerlink&quot; title=&quot;面向切面编程（Aspect Oriented Programming，AOP）是什么？&quot;&gt;&lt;/a&gt;面向切面编程（Aspect Oriented Programming，AOP）是什么？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;AOP是一种编程范式，不是编程语言；&lt;/li&gt;
&lt;li&gt;AOP解决特定问题，但不能解决所有问题；&lt;/li&gt;
&lt;li&gt;OOP的补充，而不是其替代。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
      <category term="AOP" scheme="http://yoursite.com/tags/AOP/"/>
    
      <category term="面向切面编程" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象编程知识点</title>
    <link href="http://yoursite.com/2019/02/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2019/02/20/Java面向对象编程知识点/</id>
    <published>2019-02-20T02:40:58.000Z</published>
    <updated>2019-03-30T13:21:21.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象的三个基本特征和五种设计原则"><a href="#面向对象的三个基本特征和五种设计原则" class="headerlink" title="面向对象的三个基本特征和五种设计原则"></a>面向对象的三个基本特征和五种设计原则</h2><h3 id="三个基本特征"><a href="#三个基本特征" class="headerlink" title="三个基本特征"></a>三个基本特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏；</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重写原有类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“父类”或“基类”。继承的过程就是从一般到特殊的过程。<br>要实现继承可以通过“继承”和“组合”两种方式实现。在某些OOP语言中，一个子类可以继承多个基类，但一般情况下（Java语言），一个子类只有一个基类，实现多重继承可以通过多级继承来实现。<br><a id="more"></a><br>继承概念的实现方式有三类：  </p><ul><li>实现继承：指使用基类的属性和方法而无需额外编码的能力；</li><li>接口继承：指仅使用基类的属性和方法名称，但子类必须提供实现的能力；</li><li>可视继承：指子类使用基类的外观和实现代码的能力。<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4></li></ul><p>多态是允许你将父对象设置成为和一个或多个它的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同方式运作。简单地说就是：允许将子类类型的指针赋值给父类类型的指针。<br>实现多态有两种方式：覆盖和重载：  </p><ul><li>覆盖是指子类重新定义父类的虚函数的做法；</li><li>重载是指允许多个同名函数，这些函数的参数不同（参数个数不同，或参数类型不同，或两者都不同）。</li></ul><h3 id="五种设计原则"><a href="#五种设计原则" class="headerlink" title="五种设计原则"></a>五种设计原则</h3><h4 id="单一职责原则-Single-Responsibility-Principle，SRP"><a href="#单一职责原则-Single-Responsibility-Principle，SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle，SRP)"></a>单一职责原则(Single Responsibility Principle，SRP)</h4><p>单一职责原则是指一个类的功能要单一，不能包罗万象。一个类应该只有一个引起它变化的原因。</p><h4 id="开放封闭原则-Open－Close-Principle，OCP"><a href="#开放封闭原则-Open－Close-Principle，OCP" class="headerlink" title="开放封闭原则(Open－Close Principle，OCP)"></a>开放封闭原则(Open－Close Principle，OCP)</h4><p> 开放封闭原则指的是对扩展性的开放和对修改的封闭：</p><ul><li>对扩展性的开放：模块的行为应该是可扩展的，从而该模块可表现出行的行为以满足需求的变化；</li><li><p>对修改的封闭：模块自身的代码时不应该被修改的，扩展模块的一般途径是修改内部实现。</p><h4 id="里氏替换原则-the-Liskov-Substitution-Principle，LSP"><a href="#里氏替换原则-the-Liskov-Substitution-Principle，LSP" class="headerlink" title="里氏替换原则(the Liskov Substitution Principle，LSP)"></a>里氏替换原则(the Liskov Substitution Principle，LSP)</h4><p>子类型必须能够替换掉它们的父类型，并出现在父类能够出现的任何地方。</p></li></ul><h4 id="依赖倒置原则-the-Dependency-Inversion-Principle，PIP"><a href="#依赖倒置原则-the-Dependency-Inversion-Principle，PIP" class="headerlink" title="依赖倒置原则(the Dependency Inversion Principle，PIP)"></a>依赖倒置原则(the Dependency Inversion Principle，PIP)</h4><p>具体依赖抽象，上层依赖下层。</p><h4 id="接口隔离原则-the-Interface-Segregation-Principle，ISP"><a href="#接口隔离原则-the-Interface-Segregation-Principle，ISP" class="headerlink" title="接口隔离原则(the Interface Segregation Principle，ISP)"></a>接口隔离原则(the Interface Segregation Principle，ISP)</h4><p>模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来。</p><h2 id="Class-java类文件下getMethods-和getDeclaredMethods-的区别"><a href="#Class-java类文件下getMethods-和getDeclaredMethods-的区别" class="headerlink" title="Class.java类文件下getMethods()和getDeclaredMethods()的区别"></a><code>Class.java</code>类文件下<code>getMethods()</code>和<code>getDeclaredMethods()</code>的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public Method[] getMethods() throws SecurityException &#123;</span><br><span class="line">    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);</span><br><span class="line">    return copyMethods(privateGetPublicMethods());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@CallerSensitive</span><br><span class="line">public Method[] getDeclaredMethods() throws SecurityException &#123;</span><br><span class="line">    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);</span><br><span class="line">    return copyMethods(privateGetDeclaredMethods(false));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getMethods()</code>是获取对应类及其所有父类中的共有（public）方法；<code>getDeclaredMethods()</code>获取的是当前类中的所有方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向对象的三个基本特征和五种设计原则&quot;&gt;&lt;a href=&quot;#面向对象的三个基本特征和五种设计原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象的三个基本特征和五种设计原则&quot;&gt;&lt;/a&gt;面向对象的三个基本特征和五种设计原则&lt;/h2&gt;&lt;h3 id=&quot;三个基本特征&quot;&gt;&lt;a href=&quot;#三个基本特征&quot; class=&quot;headerlink&quot; title=&quot;三个基本特征&quot;&gt;&lt;/a&gt;三个基本特征&lt;/h3&gt;&lt;h4 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h4&gt;&lt;p&gt;封装就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏；&lt;/p&gt;
&lt;h4 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h4&gt;&lt;p&gt;继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重写原有类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“父类”或“基类”。继承的过程就是从一般到特殊的过程。&lt;br&gt;要实现继承可以通过“继承”和“组合”两种方式实现。在某些OOP语言中，一个子类可以继承多个基类，但一般情况下（Java语言），一个子类只有一个基类，实现多重继承可以通过多级继承来实现。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>StackGAN: Text to Photo-realistic Image Synthesis with Stacked Generative Adversarial Networks</title>
    <link href="http://yoursite.com/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/"/>
    <id>http://yoursite.com/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/</id>
    <published>2019-02-19T09:06:58.000Z</published>
    <updated>2019-02-20T08:12:42.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p><a href="https://github.com/hanzhanggit/StackGAN" target="_blank" rel="noopener">源码地址：https://github.com/hanzhanggit/StackGAN</a></p><p>这篇文章提出<code>Stacked Generative Adversarial Networks (StackGAN)</code>合成高分辨率（$256 \times 256$）的逼真图像。这个模型将困难的图像合成问题分成两个子问题：<code>Stage-I GAN</code>根据输入的文本描述合成对象的基本形状和颜色；<code>Stage-II GAN</code>根据<code>Stage-I GAN</code>以合成的图像结果和文本描述作为输入，丰富合成图像的细节，生成逼真的高分辨率图像。 </p><p><img src="/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/StackGAN0.png" alt="image"></p><a id="more"></a> <p>我们都知道生成对抗网络的训练过程存在不稳定性，作者提出了一种新的条件增强技术促进潜在条件流形（<code>latent conditioning manifold</code>）的平滑性，从而改善了合成图像的多样性和训练生成对抗网络过程的稳定性。</p><h2 id="Stacked-Generative-Adversarial-Networks"><a href="#Stacked-Generative-Adversarial-Networks" class="headerlink" title="Stacked Generative Adversarial Networks"></a>Stacked Generative Adversarial Networks</h2><p><img src="/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/StackGAN.png" alt="image"></p><p><code>Stacked Generative Adversarial Networks</code>的结构如下图所示分为<code>Stage-I GAN</code>和<code>Stage-II GAN</code>两个子网络：  </p><ul><li><code>Stage-I GAN</code>：以文本描述和噪声向量为输入，文本描述控制对象的基本形状和颜色，噪声控制背景布局，从而生成一张低分辨率图像；</li><li><code>Stage-II GAN</code>：纠正<code>Stage-I</code>生成的低分辨率图像的缺陷，再次通过读取文本描述来补全图像的细节，从而生成高分辨率的逼真图像。</li></ul><h3 id="Stage-I-GAN"><a href="#Stage-I-GAN" class="headerlink" title="Stage-I GAN"></a>Stage-I GAN</h3><h4 id="KL散度（Kullback–Leibler-divergence-KL-divergence）"><a href="#KL散度（Kullback–Leibler-divergence-KL-divergence）" class="headerlink" title="KL散度（Kullback–Leibler divergence,KL divergence）"></a>KL散度（<code>Kullback–Leibler divergence,KL divergence</code>）</h4><p>本文章中的条件增强技术中计算标准高斯分布和条件高斯分布之间的KL散度，所以先简单介绍KL散度。<br>KL散度又被称为相对熵（<code>relative entropy</code>）或者信息散度，是连个概率分布间差异的非对称性度量。  </p><p>$$<br>KL(p(x)||q(x))=\sum_x{p(x)\log{\frac{p(x)}{q(x)}}}\\<br>=\sum_x{p(x)\log{p(x)}-p(x)\log{q(x)}}<br>$$</p><p>KL散度是衡量两个分布之间的差异大小的，KL散度大于等于0，并且越接近0说明p与q这两个分布越像，当且仅当p与q相等时KL散度取0。</p><h4 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h4><p>对于生成器$G_0$，为了获得文本条件变量$\hat{c}_0$，文本嵌入$\varphi_t$首先通过全连接层生成$\mu_0$和$\delta_0$（$\delta_0$是$\sum_0$的对角线元素值）。$\hat{c}_0$由高斯分布$N(\mu(\varphi(t)),\sum_0(\varphi(t)))$抽样得到。$N_g$维的条件向量$\hat{c}_0$由公式$\hat{c}_0=\mu_0+\delta_0 \bigodot\epsilon$计算得到，其中$\bigodot$表示元素乘积（<code>element-wise multiplication</code>），$\epsilon\sim\N(0,I)$。之后，$\hat{c}_0$与$N_z$维的噪声向量拼接并通过一系列的上采样块生成尺寸为$W_0\times H_0$的图像。<br>对于判别器$D_0$,文本嵌入$\varphi(t)$通过全连接压缩为$N_d$维然后通过复制将其转换成$M_d \times M_d \times N_d$大小的张量。同时图像经过一系列下采样块，输出$M_d \times M_d$大小的张量。最后把图像和文本得到的张量拼接在一起，经过$1\times 1$的卷积层以及一个只有一个节点的全连接层，从而得到决策值。<br>Stage-I训练过程损失函数如下，目的在于最大化$L_{D_0}$以训练判别器，最小化$L_{G_0}$以训练生成器。</p><p>$$<br>L_{D_0}=E_{(I_0,t)\sim{p_{data}}}[\log D_0(I_0,\varphi_t)]<br>+E_{z\sim{p_z},t\sim p_{data}}[\log {(1-D_0(G_0(z,\hat{c}_0),\varphi_t)}]\\<br>L_{G_0}=E_{z\sim{p_z},t\sim p_{data}}[\log {(1-D_0(G_0(z,\hat{c}_0),\varphi_t)}]+\lambda{D_{KL}}(N(\mu_0(\varphi_t),\sum_0(\varphi_t)||N(0,I)),<br>$$</p><h3 id="Stage-II-GAN"><a href="#Stage-II-GAN" class="headerlink" title="Stage-II GAN"></a>Stage-II GAN</h3><p><code>Stage-II GAN</code>的模型框架和<code>Stage-I GAN</code>相似，只不过没有了噪声输入，换成了<code>Stage-I</code>合成的低分率图像。<br>Stage-II其损失函数如下，目的在于最大化$L_D$以训练判别器，最小化$L_G$以训练生成器。  </p><p>$$<br>L_D=E_{(I,t)\sim{p_{data}}}[\log D(I,\varphi_t)]<br>+E_{s_0\sim{p_{G_0}},t\sim p_{data}}[\log {(1-D(G(s_0,\hat{c}),\varphi_t)}]\\<br>L_G=E_{s_0\sim{p_{G_0}},t\sim p_{data}}[\log {(1-D(G(s_0,\hat{c}),\varphi_t)}]+\lambda{D_{KL}}(N(\mu(\varphi_t),\sum(\varphi_t)||N(0,I)),<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/hanzhanggit/StackGAN&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码地址：https://github.com/hanzhanggit/StackGAN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章提出&lt;code&gt;Stacked Generative Adversarial Networks (StackGAN)&lt;/code&gt;合成高分辨率（$256 \times 256$）的逼真图像。这个模型将困难的图像合成问题分成两个子问题：&lt;code&gt;Stage-I GAN&lt;/code&gt;根据输入的文本描述合成对象的基本形状和颜色；&lt;code&gt;Stage-II GAN&lt;/code&gt;根据&lt;code&gt;Stage-I GAN&lt;/code&gt;以合成的图像结果和文本描述作为输入，丰富合成图像的细节，生成逼真的高分辨率图像。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/StackGAN0.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="论文阅读" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="text2image" scheme="http://yoursite.com/tags/text2image/"/>
    
      <category term="图像合成" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/"/>
    
      <category term="生成对抗网络" scheme="http://yoursite.com/tags/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型（二）</title>
    <link href="http://yoursite.com/2019/02/19/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/19/Java内存模型（二）/</id>
    <published>2019-02-19T07:05:28.000Z</published>
    <updated>2019-02-19T08:35:29.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的手段。</p><h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>如果两个操作访问同一个变量，且这两个操作中有一为写操作，此时这两个操作时间就存在数据依赖性。数据依赖分为三种类型：写后读、写后写、读后写。<br>上述三种情况，只要重排序这两个操作的执行顺序，程序的执行结果就会改变。因此编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作顺序。<br>这类所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。<br><a id="more"></a> </p><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a><code>as-if-serial</code>语义</h3><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不会被改变。as-if-serial语义把单线程程序保护起来，遵循as-if-serial语义的编译器、runtime和处理器保证单线程程序执行的结果与其按照顺序执行的结果一致。</p><h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;           //A</span><br><span class="line">double r = 1.0;             //B</span><br><span class="line">double area = pi * r * r;   //C</span><br></pre></td></tr></table></figure><p>根据happens-before的程序顺序规则，上面计算圆面积的示例代码存在3个happens-before关系：  </p><ul><li><code>A happens-before B</code></li><li><code>B happens-before C</code></li><li><code>A happens-before C</code></li></ul><p>这里<code>A happens-before B</code>，但在实际执行时B却可以在A之前执行。如果<code>A happens-before B</code>，JMM并不一定要求A在B之前执行。JMM仅仅要求前一个操作对后一个操作可见，且前一个操作按顺序排在后一操作之前。这里操作A的执行结果并不需要对操作B可见；而且重排序操作A和操作B后的执行结果，与操作A和操作B按照<code>A happens-before B</code>顺序执行的结果一致。在这种情况下，JMM会认为这种重排序不非法（not illegal）,JMM允许这种重排序。<br>在计算机中，软件技术和硬件技术有一个共同目的：在不改变程序执行结果的前提下，尽可能提高并行度。</p><h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><p>多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><h3 id="数据竞争与顺序一致性"><a href="#数据竞争与顺序一致性" class="headerlink" title="数据竞争与顺序一致性"></a>数据竞争与顺序一致性</h3><p>当程序未正确同步时，就可能会存在数据竞争。Java内存模型规范对数据竞争的定义如下：  </p><ul><li>在一个线程中写入一个变量；</li><li>在另一个线程中读同一个变量；</li><li>而且写和读没有通过同步来排序。  </li></ul><p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果。如果一个多线程程序能够同步，这个程序将是一个没有数据竞争的程序。JMM对正确同步的多线程程序的内存一致性做了如下保证：<br>如果程序时正确同步的，程序的执行将具有顺序一致性——即程序的执行结果与改程序在顺序一致性内存模型中的执行结果相同。</p><h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>顺序一致性内存模型是一个被计算机科学家理想化的理论参考模型。它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：  </p><ul><li>一个线程中的所有操作都必须按照程序的顺序来执行；</li><li>（不管线程是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;h2 id=&quot;重排序&quot;&gt;&lt;a href=&quot;#重排序&quot; class=&quot;headerlink&quot; title=&quot;重排序&quot;&gt;&lt;/a&gt;重排序&lt;/h2&gt;&lt;p&gt;重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的手段。&lt;/p&gt;
&lt;h3 id=&quot;数据依赖性&quot;&gt;&lt;a href=&quot;#数据依赖性&quot; class=&quot;headerlink&quot; title=&quot;数据依赖性&quot;&gt;&lt;/a&gt;数据依赖性&lt;/h3&gt;&lt;p&gt;如果两个操作访问同一个变量，且这两个操作中有一为写操作，此时这两个操作时间就存在数据依赖性。数据依赖分为三种类型：写后读、写后写、读后写。&lt;br&gt;上述三种情况，只要重排序这两个操作的执行顺序，程序的执行结果就会改变。因此编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作顺序。&lt;br&gt;这类所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="重排序" scheme="http://yoursite.com/tags/%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    
      <category term="数据依赖性" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E6%80%A7/"/>
    
      <category term="顺序一致性" scheme="http://yoursite.com/tags/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型（一）</title>
    <link href="http://yoursite.com/2019/02/18/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/18/Java内存模型（一）/</id>
    <published>2019-02-18T06:54:08.000Z</published>
    <updated>2019-02-18T08:13:46.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="Java内存模型的基础"><a href="#Java内存模型的基础" class="headerlink" title="Java内存模型的基础"></a>Java内存模型的基础</h2><h3 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h3><ol><li>线程之间如何通信？</li><li>线程之间如何同步？</li></ol><p>通信是指线程之间以何种机制交换信息，在命令式编程中线程之间的通信机制有两种：共享内存和消息传递。在共享内存模型中，线程之间共享程序的公共状态，通过读写内存中的公共状态进行隐式通信；而在消息传递的并发模型中，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。<br><a id="more"></a><br>同步是指程序中用来控制不同线程间操作发生的相对顺序的机制。在共享内存并发模型中，同步是显式进行的。程序员必须显式指定某个方法或某个代码段需要在线程之间互斥执行。在消息传递的并发模型中，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。<br>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行的，整个通信过程对于程序员完全透明。</p><h3 id="Java内存模型的抽象结构"><a href="#Java内存模型的抽象结构" class="headerlink" title="Java内存模型的抽象结构"></a>Java内存模型的抽象结构</h3><p>在Java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。局部变量（Local Variables），方法定义参数（Formal Method Parameters）和异常处理器参数（Exception Handler Parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。<br>Java线程之间的通信由Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程读写共享变量的副本。本地内存是JMM的一个抽象概念，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><p><img src="/2019/02/18/Java内存模型（一）/jmm1.png" alt="image"></p><p>由上图看出线程A和线程B之间要通信的话，必须经历以下两个步骤：<br>1）.线程A把本地内存A中更新过的共享变量 刷新到主内存中去；<br>2）.线程B到主内存中去读取线程A之前已更新过的共享变量。</p><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为3种类型。<br>1）编译器优化的重排序。编译器再不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。<br>2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<br>3）内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是乱序执行。</p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作，既可以在一个线程之内，也可以在不同线程之间。<br>与程序员密切相关的happens-before规则如下：  </p><ul><li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。（也就是说一个线程中的每个操作的结果对于该线程中的其他操作都是可见的）</li><li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。（也就是说一个锁的解锁操作需要对该锁的解锁操作可见）</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果<code>A happens-before B</code>，且<code>B happens-before C</code>，那么<code>A happens-before C</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;h2 id=&quot;Java内存模型的基础&quot;&gt;&lt;a href=&quot;#Java内存模型的基础&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型的基础&quot;&gt;&lt;/a&gt;Java内存模型的基础&lt;/h2&gt;&lt;h3 id=&quot;并发编程模型的两个关键问题&quot;&gt;&lt;a href=&quot;#并发编程模型的两个关键问题&quot; class=&quot;headerlink&quot; title=&quot;并发编程模型的两个关键问题&quot;&gt;&lt;/a&gt;并发编程模型的两个关键问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;线程之间如何通信？&lt;/li&gt;
&lt;li&gt;线程之间如何同步？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通信是指线程之间以何种机制交换信息，在命令式编程中线程之间的通信机制有两种：共享内存和消息传递。在共享内存模型中，线程之间共享程序的公共状态，通过读写内存中的公共状态进行隐式通信；而在消息传递的并发模型中，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java内存模型" scheme="http://yoursite.com/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="共享内存" scheme="http://yoursite.com/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    
      <category term="happens-before" scheme="http://yoursite.com/tags/happens-before/"/>
    
      <category term="指令重排序" scheme="http://yoursite.com/tags/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发机制的底层实现原理</title>
    <link href="http://yoursite.com/2019/01/21/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/01/21/并发机制的底层实现原理/</id>
    <published>2019-01-21T02:22:24.000Z</published>
    <updated>2019-01-21T13:02:52.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发机制的底层实现原理"><a href="#并发机制的底层实现原理" class="headerlink" title="并发机制的底层实现原理"></a>并发机制的底层实现原理</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>在多线程并发编程中synchronized和volatile关键字都扮演着重要角色，volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外的线程可以读到修改后的值。volatile的恰当使用能比synchronized关键字的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。<br><a id="more"></a><br><strong>定义</strong>：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。<br>Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。<br>在X86处理器下通过工具获取JIT编译器生成的汇编指令，查看对volatile变量进行写操作时，对应CPU的操作，例子如下：</p><ul><li><p>Java代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = new Singleton();    //instance是volatile变量</span><br></pre></td></tr></table></figure></li><li><p>转化为汇编代码，如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x01a3de1d: movb $0x0,ox1104800(%esi);0x01a3de24: lock addl $0x0,(%esp);</span><br></pre></td></tr></table></figure></li></ul><p>有volatile变量修饰的共享变量进行写操作时会多出两行汇编代码，通过查看IA-32架构软件开发者手册可知，Lock前缀的指令在多核处理器中会发生以下两件事情。  </p><ol><li>将当前处理器的缓存行的数据写回到系统内存；</li><li>这个写回内存的操作会是其他CPU里缓存了该内存地址的数据无效。</li></ol><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>在多线程并发编程中synchronized一直是元老级角色，很多人称呼它为重量级锁。Java SE1.6对synchronized进行了各种优化，为减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。<br>synchronized实现同步的基础：Java中的每一个对象都可以作为锁，具体表现为一些3种形式：  </p><ul><li>对于普通同步方法，锁是当前实例对象；</li><li>对于静态同步方法，锁是当前类的Class对象；</li><li>对于同步代码块，锁是Synchronized括号里配置的对象。  </li></ul><p>当一个线程师徒访问同步代码块时，它首先必须得到锁，退出或者抛出异常时必须释放锁。<br>从JVM规范中可以看到Synchronized在JVM里实现的原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者实现细节不同。代码块同步用monitorenter和monitorexit指令实现，而方法同步是使用另一种方式实现的，细节没有在JVM规范中提及。但方法的同步同样可以使用上述两个指令实现。<br>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有之后，它将处于被锁状态。线程执行到monitor指令时，将尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。  </p><h3 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h3><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，在Java SE 1.6中，锁一共有4个状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态随着竞争情况逐渐升级。锁可以升级但不可以降级，意味着偏向锁升级为轻量级锁后不能降级为偏向锁。这种锁只能升级不能降级的策略是为了提高获得锁和释放锁的效率。</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作（atomic operation）指的是不可被中断的一个或者一系列操作。<br>处理器保证从系统内存中读取或写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。但是负责的内存操作处理器是不能自动保证原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来保证复杂内存操作的原子性。</p><ul><li>总线锁是指使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器就可以独占共享内存。但是总线锁定把CPU和内存之间的通信锁定了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定开销比较大。</li><li>缓存锁定是指内存区域如果被缓存在处理器的缓存行中，并且在LOCK操作期间被锁定，那么当它执行写操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效  </li></ul><p>CAS实现原子操作的三大问题：</p><ol><li>ABA问题；</li><li>循环时间长开销大；</li><li>只能保证一个共享变量的原子操作。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发机制的底层实现原理&quot;&gt;&lt;a href=&quot;#并发机制的底层实现原理&quot; class=&quot;headerlink&quot; title=&quot;并发机制的底层实现原理&quot;&gt;&lt;/a&gt;并发机制的底层实现原理&lt;/h1&gt;&lt;h2 id=&quot;volatile&quot;&gt;&lt;a href=&quot;#volatile&quot; class=&quot;headerlink&quot; title=&quot;volatile&quot;&gt;&lt;/a&gt;volatile&lt;/h2&gt;&lt;p&gt;在多线程并发编程中synchronized和volatile关键字都扮演着重要角色，volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外的线程可以读到修改后的值。volatile的恰当使用能比synchronized关键字的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
      <category term="volatile" scheme="http://yoursite.com/tags/volatile/"/>
    
      <category term="原子操作" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>并发编程的挑战</title>
    <link href="http://yoursite.com/2019/01/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98/"/>
    <id>http://yoursite.com/2019/01/20/并发编程的挑战/</id>
    <published>2019-01-20T12:06:28.000Z</published>
    <updated>2019-01-21T02:25:24.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h1><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>在多线程执行代码的过程中，CPU为每个线程分配CPU时间片保证线程的执行，时间片很短，一般是几十毫秒（ms）。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存前一个任务的状态，以便下次切换回这个任务的时候可以再加载这个任务。任务从保存到再加载的过程就是一次上下文切换。<br><a id="more"></a><br>多线程由于上下文切换的存在使得其不一定比单线程快，一般减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。  </p><ul><li><strong>无锁并发编程</strong>：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些方法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同线程处理不同段的数据；</li><li><strong>CAS算法</strong>：Java的Atomic包使用CAS算法来更新数据，而不需要加锁；</li><li><strong>使用最少线程</strong>：避免创建不需要的线程，比如任务少时，创建很多线程会造成大量线程都处于等待状态；</li><li><strong>使用协程</strong>：在单线程中实现多任务的调度，并在单线程里维持多个任务间的切换。<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2>死锁是指由于两个或者多个任务互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。</li></ul><h3 id="线程死锁产生的四个必要条件"><a href="#线程死锁产生的四个必要条件" class="headerlink" title="线程死锁产生的四个必要条件"></a>线程死锁产生的四个必要条件</h3><ol><li><strong>互斥条件</strong>：某种资源一次只允许一个线程访问，即该资源一旦分配给某个线程，其他线程就不能再访问，直到该进程访问结束并释放；</li><li><strong>请求和保持条件</strong>：指线程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它线程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放；</li><li><strong>不剥夺条件</strong>：指线程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放；</li><li><strong>环路(循环)等待条件</strong>：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合<code>{t0，t1，t2，···，tn}</code>中的t0正在等待一个t1占用的资源；t1正在等待t2占用的资源，……，tn正在等待已被t0占用的资源。</li></ol><h3 id="避免死锁的几个常用方法"><a href="#避免死锁的几个常用方法" class="headerlink" title="避免死锁的几个常用方法"></a>避免死锁的几个常用方法</h3><ul><li>避免一个线程同时获得多个锁；</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源；</li><li>尝试使用定时锁，使用<code>lock。tryLock(timeout)</code>来替代使用内部锁机制；</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li></ul><h2 id="资源限制的挑战"><a href="#资源限制的挑战" class="headerlink" title="资源限制的挑战"></a>资源限制的挑战</h2><p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。例如，网络带宽的限制、硬盘读写速度的限制、CPU计算速度的限制、数据库的连接数和socket连接数限制等。</p><h3 id="资源限制引发的问题"><a href="#资源限制引发的问题" class="headerlink" title="资源限制引发的问题"></a>资源限制引发的问题</h3><p>在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变为并发执行，但如果将某段串行代码并发执行，因为资源受限，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。</p><h3 id="资源限制的解决"><a href="#资源限制的解决" class="headerlink" title="资源限制的解决"></a>资源限制的解决</h3><p>对应硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机上运行。比如用<code>ODPS</code>、<code>Hadoop</code>或者自己搭建服务器集群，不同的机器处理不同的数据。<br>对于软件资源限制，可以考虑使用资源池复用资源。比如使用连接池将数据库和Socket连接复用，或者在调用对方webservice接口获取数据时，只建立一个连接。</p><h3 id="资源限制下的并发编程"><a href="#资源限制下的并发编程" class="headerlink" title="资源限制下的并发编程"></a>资源限制下的并发编程</h3><p>根据不同的资源限制调整程序的并发度，比如下载文件程序依赖于两个资源——带宽和硬盘读写速度。有数据库操作时，涉及数据库连接数，如果SQL语句执行非常快，而线程的数量比数据库连接数大很多，就会导致某些线程被阻塞，等待数据库连接，因此这个时候就应该降低线程数量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程的挑战&quot;&gt;&lt;a href=&quot;#并发编程的挑战&quot; class=&quot;headerlink&quot; title=&quot;并发编程的挑战&quot;&gt;&lt;/a&gt;并发编程的挑战&lt;/h1&gt;&lt;h2 id=&quot;上下文切换&quot;&gt;&lt;a href=&quot;#上下文切换&quot; class=&quot;headerlink&quot; title=&quot;上下文切换&quot;&gt;&lt;/a&gt;上下文切换&lt;/h2&gt;&lt;p&gt;在多线程执行代码的过程中，CPU为每个线程分配CPU时间片保证线程的执行，时间片很短，一般是几十毫秒（ms）。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存前一个任务的状态，以便下次切换回这个任务的时候可以再加载这个任务。任务从保存到再加载的过程就是一次上下文切换。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="上下文切换" scheme="http://yoursite.com/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
    
      <category term="死锁" scheme="http://yoursite.com/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Kafka-分布式流平台</title>
    <link href="http://yoursite.com/2019/01/16/Kafka-%E5%88%86%E5%B8%83%E5%BC%8F%E6%B5%81%E5%B9%B3%E5%8F%B0/"/>
    <id>http://yoursite.com/2019/01/16/Kafka-分布式流平台/</id>
    <published>2019-01-16T09:20:56.000Z</published>
    <updated>2019-03-06T06:57:16.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka-分布式流平台"><a href="#Kafka-分布式流平台" class="headerlink" title="Kafka:分布式流平台"></a>Kafka:分布式流平台</h1><p><a href="https://kafka.apache.org/intro" target="_blank" rel="noopener">参考链接：Kafka官网</a></p><p>Apache Kafka是一个分布式流平台，具有以下三个关键能力：</p><ul><li>发布和订阅记录流（<code>streams of records</code>），类似于一个消息队列或者是企业消息系统；</li><li>以具有容错性和持久性的方式存储记录流；</li><li><p>即时处理记录流</p><a id="more"></a> <p>Kafka通常被用在两大类应用中：</p></li><li><p>构建可在系统或应用程序之间可靠获取数据的实时流数据管道</p></li><li>构建转换或响应数据流的实时流应用</li></ul><p>一些概念：</p><ul><li>Kafka作为一个集群可以运行在一个或多个服务器上，这些服务器可跨多个数据中心；</li><li>Kafka集群存储在类别中的记录流称为主题（topics）；</li><li>每个记录包含一个键（key）、一个值（value）以及一个时间戳（timestamp）；</li></ul><p>Kafka有四个核心API：</p><ul><li>生产者（Producer）API允许一个应用将记录流发布到一个或多个Kafka主题（topics）上；</li><li>消费者（Consumer）API允许一个应用去订阅一个或者多个主题（topics），并处理这些给它们生产的记录流；</li><li>流（Streams）API允许一个应用扮演流处理器的角色，从一个或多个主题消费一个输入流，然后向一个或多个主题输出流，高效地进行输入流到输出流的转换；</li><li>连接（Connector）API允许创建或者运行可重用的生产者或消费者，并与将Kafka主题与现有的应用或数据系统连接。例如关系数据库的连接器可以捕获对表的每个更改。</li></ul><p><img src="/2019/01/16/Kafka-分布式流平台/kafka1.png" alt="四个核心API"></p><h2 id="主题（Topics）和记录（Logs）"><a href="#主题（Topics）和记录（Logs）" class="headerlink" title="主题（Topics）和记录（Logs）"></a>主题（Topics）和记录（Logs）</h2><p>一个主题是发布记录的一个类别或订阅源名称。 Kafka中主题总是多订阅用户; 也就是说，一个主题可以有零个，一个或多个消费者订阅写入它的数据。<br>对于每个主题，Kafka群集都维护一个如下所示的分区日志（partitioned log）：</p><p><img src="/2019/01/16/Kafka-分布式流平台/kafka2.png" alt="主题解剖">  </p><p>每个分区（partition）都是有序的，不可变的记录序列，这些记录不断添加到结构化的提交日志中。分区中的每个记录都被分配一个称为偏移的序列id，这些id唯一标识了分区中的每个记录。<br>Kafka集群使用可配置的保留期，持久保存所有已发布的记录，无论这些记录是否已被使用。 例如，如果保留策略被设置为两天，那么在发布记录后的两天内，记录都可以被消费，之后将被丢弃以释放空间。 Kafka的性能不受数据大小的影响，因此长时间存储数据不是问题。<br>实际上，基于每个消费者保留的唯一元数据是该消费者在日志中的偏移或位置。 这种偏移由消费者控制：通常消费者会线性地提高其偏移量从而读取记录，但事实上，由于该位置由消费者控制，因此它可以按照自己喜欢的任何顺序去消费记录。 例如，消费者可以重置为较旧的偏移量去重新处理过去的数据，或者跳到最近的记录并从“现在”开始消费。</p><p><img src="/2019/01/16/Kafka-分布式流平台/kafka3.png" alt="主题解剖">  </p><p>这些特性的组合意味着Kafka消费者非常方便，消费者的加入移除对集群或其他消费者没有太大影响。 例如，您可以使用我们的命令行工具“拖尾（tail，此处不太理解）”任何主题的内容，而无需更改任何现有使用者所消耗的内容。</p><p>日志中的分区有多种用途。 首先，它们允许日志扩展到超出适合单个服务器的规模。 每个独立分区必须适合托管它的服务器，但一个主题可能有多个分区，因此它可以处理任意数量的数据。 其次，分区充当了并行性的单元。</p><h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><ol><li>Consumer Group：逻辑概念，对于同一个topic，会广播给不同的group。同一个group中只有一个consumer可以消费该topic。</li><li>Broker：物理概念，Kafka集群中的每个Kafka节点。</li><li>Partition：物理概念，Kafka下数据存储的基本单元。一个Topic数据，会被分散存储到多个Partition，每个Partition是有序的。</li><li>Replication：同一个Partition可能会有多个副本（replication），多个副本之间数据是一致的。</li><li>Replication Leader：一个Partition的多个副本需要选举一个leader负责partition上与Producer和Consumer消息传递。</li><li>ReplicaManager：负责管理当前Broker所有分区和副本的信息，处理KafkaController发起的请求，如副本状态的切换（重新选举Replication Leader）、添加消息、消费消息等。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kafka-分布式流平台&quot;&gt;&lt;a href=&quot;#Kafka-分布式流平台&quot; class=&quot;headerlink&quot; title=&quot;Kafka:分布式流平台&quot;&gt;&lt;/a&gt;Kafka:分布式流平台&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://kafka.apache.org/intro&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接：Kafka官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Apache Kafka是一个分布式流平台，具有以下三个关键能力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发布和订阅记录流（&lt;code&gt;streams of records&lt;/code&gt;），类似于一个消息队列或者是企业消息系统；&lt;/li&gt;
&lt;li&gt;以具有容错性和持久性的方式存储记录流；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;即时处理记录流&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="kafka" scheme="http://yoursite.com/categories/kafka/"/>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
      <category term="开源软件" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>图片服务器搭建</title>
    <link href="http://yoursite.com/2019/01/14/%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/01/14/图片服务器搭建/</id>
    <published>2019-01-14T09:17:23.000Z</published>
    <updated>2019-01-18T04:40:31.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图片服务器搭建"><a href="#图片服务器搭建" class="headerlink" title="图片服务器搭建"></a>图片服务器搭建</h1><p><strong>环境</strong>：window server 2016 Datacenter</p><ol><li>首先下载<code>nginx</code>软件包，我下在的版本是<code>nginx-1.15.8</code>，下载链接和英文安装教程如下:</li></ol><ul><li><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">nginx下载地址</a> </li><li><a href="http://nginx.org/en/docs/windows.html" target="_blank" rel="noopener">nginx英文安装教程</a> <a id="more"></a> </li></ul><ol start="2"><li>解压<code>nginx-1.15.8.zip</code>，目录结构如下图所示：  </li></ol><p><img src="/2019/01/14/图片服务器搭建/1.png" alt="image"></p><ol start="3"><li>运行<code>nginx.exe</code>,并查看通过命令查看运行状态，如下所示：  </li></ol><p><img src="/2019/01/14/图片服务器搭建/2.png" alt="image"></p><p>如果没有运行成功，可以通过打开<code>logs\error.log</code>查看错误记录。</p><ol start="4"><li>打开浏览器，输入<code>localhost</code>测试是否成功，如下图所示：</li></ol><p><img src="/2019/01/14/图片服务器搭建/3.png" alt="image"></p><ol start="5"><li>搭建图片服务器</li></ol><p>首先打开<code>conf</code>目录下的<code>nginx.conf</code>配置文件，修改如下：</p><p><img src="/2019/01/14/图片服务器搭建/4.png" alt="image"></p><ol start="6"><li>重新启动<code>nginx</code>，一些命令如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop   fast shutdown</span><br><span class="line">nginx -s quit   graceful shutdown</span><br><span class="line">nginx -s reload   changing configuration, starting new worker processes with a new configuration, graceful shutdown of old worker processes</span><br><span class="line">nginx -s reopen   re-opening log files</span><br></pre></td></tr></table></figure><ol start="7"><li>此时在<code>images</code>文件夹下放一张随意图片（我放了一张<code>nginx</code>网站的截图），打开浏览器，输入链接<code>http://47.95.145.72:8090/1.png</code>，就可以看到我们的图片，如下所示：</li></ol><p><img src="/2019/01/14/图片服务器搭建/5.png" alt="image"></p><p><strong>到这里，图片服务器就搭建完成了！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图片服务器搭建&quot;&gt;&lt;a href=&quot;#图片服务器搭建&quot; class=&quot;headerlink&quot; title=&quot;图片服务器搭建&quot;&gt;&lt;/a&gt;图片服务器搭建&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;环境&lt;/strong&gt;：window server 2016 Datacenter&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先下载&lt;code&gt;nginx&lt;/code&gt;软件包，我下在的版本是&lt;code&gt;nginx-1.15.8&lt;/code&gt;，下载链接和英文安装教程如下:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://nginx.org/en/download.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nginx下载地址&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://nginx.org/en/docs/windows.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nginx英文安装教程&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="工程" scheme="http://yoursite.com/categories/%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集（二）</title>
    <link href="http://yoursite.com/2019/01/14/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/01/14/垃圾收集（二）/</id>
    <published>2019-01-14T02:25:44.000Z</published>
    <updated>2019-01-18T04:40:40.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h1><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>算法分为标记阶段和清除阶段 ，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程就是引用计数法或者可达性算法判断对象是否存活的过程。<br>不足：  </p><ol><li>效率问题，标记和清除两个阶段的效率都不高；</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序运行过程中需要分配较大对象时，无法找到足够的内存碎片而不得不提前出发一次垃圾收集动作。<br>标记清除算法的执行过程如下图所示：  </li></ol><p><img src="/2019/01/14/垃圾收集（二）/gc1.png" alt="image"><br><a id="more"></a> </p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，一种“复制”的垃圾收集算法出现了，它将可用的内存分成大小相等的两个区域，每次只使用其中的一块区域。当这块区域用完之后，就将还存活着的对象复制到另一块内存区域上，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行垃圾回收，内存分配时也就不用再考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法每次只能使用一半的内存，相当于将内存缩小为原来的一半，代价太高。复制算法的执行过程如下图所示：</p><p><img src="/2019/01/14/垃圾收集（二）/gc2.png" alt="image"></p><p>目前的商业虚拟机都是采用复制算法回收新生代，但是并不按照<code>1:1</code>划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的<code>Survivor</code>空间，每次使用<code>Eden</code>和其中一块<code>Survivor</code>。当回收时，将Eden和Survivor中还存活的对象一次性复制到另一块<code>Survivor</code>空间上，最后清理掉Eden和刚才用过的Survivor空间。<code>HotSpot</code>虚拟机默认<code>Eden：Survivor=8:1</code>，也就是每次新生代中可用内存空间为整个新生代容量的<code>90%</code>，只有<code>10%</code>的内存被“浪费”。当然在大多数（<code>98%</code>）情况下，只有不超过<code>10%</code>的对象存活，而当超过<code>10%</code>时，也就意味着<code>Survivor</code>空间不够用，这个时候就需要依赖老年代进行分配担保（无法再<code>Survivor</code>区存放的对象直接进入老年代）。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制算法在对象存活率较高的情况下就会进行较多的复制操作，效率将会变低，而且还需要额外的内存空间进行分配担保，以应对内存（<code>Survivor</code>空间）不够容纳存活对象的极端情况。<br>因此，老年代一般不采用复制算法，而采用“标记-整理”（<code>Mark-Compact</code>）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让存活对象都向一端移动，然后直接清理掉端边界以外的内存，标记-整理算法的示意图如下：</p><p><img src="/2019/01/14/垃圾收集（二）/gc3.png" alt="image"></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”（<code>Generational Collection</code>）算法，这种算法根据对象存活周期的不同将内存划分为几块。一般是把Java堆划分成新生代和老生代，从而根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集都会发现大量的对象死去，只有少量对象存活，因此采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；在老年代中因为对象存活率高、没有额外的空间对它进行分配担保，就必须采用“标记-清理”或者“标记-整理”算法进行回收。</p><h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>从可达性分析中从<code>GC Roots</code>节点找到引用链这个操作为例，可作为<code>GC Roots</code>的加点主要在全局性的引用（例如常量或类静态变量）与执行上下文（例如栈帧中的本地变量表）中，现在的很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。<br>另外，可达性分析对执行时间的敏感还体现在<code>GC</code>停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行——这里的“一致性”的意思是在真个分析过程中整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致在<code>GC</code>进行时必须停止多有<code>Java</code>执行线程的其中一个重要原因。即时在号称（几乎）不会发生停顿的<code>CMS</code>收集器中，枚举根节点时也是必须要停顿的。<br>由于目前主流的<code>Java</code>虚拟机使用的都是准确式<code>GC</code>，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在<code>HotSpot</code>的实现中，是使用一组称为<code>OopMap</code>的数据结构来达到这个目的，在类加载完成时，<code>HotSpot</code>就把对象内什么偏移量上是什么类型的数据计算出来，在<code>JIT</code>编译过程中，也会在特定位置记录下栈和寄存器哪些位置是引用。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>在<code>OopMap</code>的协助下，<code>HotSpot</code>可以快速且准确地完成<code>GC Roots</code>枚举，但一个很现实的问题随之而来：可能导致引用关系发生变化，或者说<code>OopMap</code>内容变化的指令非常多，如果每一条指令都生成对应的<code>OopMap</code>，那将会需要大量的额外空间，这样<code>GC</code>的空间成本就会变得很高。<br>实际上，<code>HotSpot</code>也的确没有为每条指令都生成<code>OopMap</code>，前面已经提到只是在“特定的位置”记录这些信息，这些位置称为安全点（<code>Safepoint</code>），即程序执行时并非在所有的地方都能停顿下来开始GC，只有到达安全点时才能暂停。<code>Safepoint</code>的选定既不能太少以致于GC等待时间过长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的————因为每一条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”最明显的特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才回产生<code>Safepoint</code>。<br>对于<code>Safepoint</code>，另一个需要考虑的问题就是如何在GC发生时让所有的线程都“跑”到最近的安全点上停顿下来。这里有两种方案可以选择:抢先式中断（<code>Preemptive Suspension</code>）和主动式中断（<code>Voluntary Suspension</code>），其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有的线程全部中断，如果发现线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而相应GC时间。<br>而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</p><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>使用<code>Safepoint</code>似乎已经完美解决了如何进入<code>GC</code>的问题，但实际情况却并不一定。<code>Safepoint</code>机制保证了程序执行时，在不太长的时间内就会遇到可进入<code>GC</code>的<code>Safepoint</code>。但是程序不执行的时候，<code>CPU</code>没有分配时间给程序，典型例子就是线程处于<code>Sleep</code>或者<code>Blocked</code>状态，这时线程无法响应<code>JVM</code>的中断请求，“走”到安全的地方去挂起中断，<code>JVM</code>也不太可能等待这些线程重新分配<code>CPU</code>时间。<br>对于这种情况就需要安全区域（<code>Safe Region</code>）来解决。安全区域是指在一段代码片段中，引用关系不会发生变化。在这个区域中的任何地方开始GC都是安全的。<br>在线程执行到<code>Saferegion</code>中的代码时，首先标志自己进入了<code>Saferegion</code>，那样当在这段时间里<code>JVM</code>要发起<code>GC</code>时，就不用管标志自己为<code>Saferegion</code>状态的线程了。在线程要离开<code>Saferegion</code>时，它要检查系统是否已经完成了根节点枚举（或者整个<code>GC</code>过程），如果完成了那么线程继续执行，否则它就要等待直到收到可以安全离开<code>Saferegion</code>的信号为止。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;垃圾收集&quot;&gt;&lt;a href=&quot;#垃圾收集&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集&quot;&gt;&lt;/a&gt;垃圾收集&lt;/h1&gt;&lt;h2 id=&quot;垃圾收集算法&quot;&gt;&lt;a href=&quot;#垃圾收集算法&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集算法&quot;&gt;&lt;/a&gt;垃圾收集算法&lt;/h2&gt;&lt;h3 id=&quot;标记-清除算法&quot;&gt;&lt;a href=&quot;#标记-清除算法&quot; class=&quot;headerlink&quot; title=&quot;标记-清除算法&quot;&gt;&lt;/a&gt;标记-清除算法&lt;/h3&gt;&lt;p&gt;算法分为标记阶段和清除阶段 ，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程就是引用计数法或者可达性算法判断对象是否存活的过程。&lt;br&gt;不足：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;效率问题，标记和清除两个阶段的效率都不高；&lt;/li&gt;
&lt;li&gt;空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序运行过程中需要分配较大对象时，无法找到足够的内存碎片而不得不提前出发一次垃圾收集动作。&lt;br&gt;标记清除算法的执行过程如下图所示：  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/2019/01/14/垃圾收集（二）/gc1.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="垃圾收集器" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
      <category term="垃圾收集算法" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="安全点" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E7%82%B9/"/>
    
      <category term="安全区域" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集(一)</title>
    <link href="http://yoursite.com/2019/01/12/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2019/01/12/垃圾收集/</id>
    <published>2019-01-12T03:50:08.000Z</published>
    <updated>2019-01-18T04:40:35.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h1><p>垃圾回收需要关注的事情：  </p><ol><li>哪些内存需要回收？ Java堆和方法区</li><li>什么时候回收？</li><li>如何回收？  <a id="more"></a> java内存运行时各个区域，其中程序计数器、java虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地进行出栈和入栈操作。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收器所关注的就是这部分内存。</li></ol><h2 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h2><h3 id="引用计数法（Reference-Counting）"><a href="#引用计数法（Reference-Counting）" class="headerlink" title="引用计数法（Reference Counting）"></a>引用计数法（Reference Counting）</h3><p>算法描述：给对象中添加一个引用计数器，每当有一个引用指向这个对象，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器值为0的对象就不可能再被使用。<br>引用计数法存在一个问题：它很难解决对象之间的相互循环引用问题，举个例子，示例代码如下。对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">/**</span><br><span class="line"> * 对象objA和objB存在相互引用</span><br><span class="line"> * @author yangkuan</span><br><span class="line"> */</span><br><span class="line">public class ReferenceCounteringGC &#123;</span><br><span class="line">    public Object instance = null;</span><br><span class="line"></span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line">    /**</span><br><span class="line">     * 这个成员变量的意义是通过其占用的内存，通过GC日志查看对象是否被回收</span><br><span class="line">     */</span><br><span class="line">    private byte[] bigSize = new byte[2 * _1MB];</span><br><span class="line"></span><br><span class="line">    public static void testGC()&#123;</span><br><span class="line">        ReferenceCounteringGC objA = new ReferenceCounteringGC();</span><br><span class="line">        ReferenceCounteringGC objB = new ReferenceCounteringGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = null;</span><br><span class="line">        objB = null;</span><br><span class="line"></span><br><span class="line">        // 假设此处发生垃圾回收，如果回收算法是引用计数法，那么objA和objB将不会被回收</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="可达性分析算法（Reachability-Analysis）"><a href="#可达性分析算法（Reachability-Analysis）" class="headerlink" title="可达性分析算法（Reachability Analysis）"></a>可达性分析算法（Reachability Analysis）</h3><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>这个算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（即该对象到GC Roots不可达）时，则证明这个对象不可用。那这些不可达的对象就可以判定为可回收对象。<br>可作为GC Roots的对象包括以下几种：  </p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（即Native方法）引用的对象。</li></ul><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ol><li><strong>强引用（Strong Reference）</strong><br>强引用就是指在程序代码之中普遍存在的，类似<code>Object obj = new Object()</code>这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li><strong>软引用（Soft Reference）</strong><br>软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收之后还没有足够的内存，那么程序就会抛出内存溢出异常。</li><li><strong>弱引用（Weak Reference）</strong><br>弱引用也是用来描述非必须对象的，但是它的强度比软引用还要更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前。当垃圾收集器工作时，无论当内存是否足够，都会回收掉只被弱引用关联的对象。</li><li><strong>虚引用（Phantom Reference）</strong><br>虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成威胁，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ol><h4 id="对象的两次标记过程"><a href="#对象的两次标记过程" class="headerlink" title="对象的两次标记过程"></a>对象的两次标记过程</h4><ol><li>如果对象再进行可达性分析的时候发现其与<code>GC Roots</code>之间不可达，那么它将会被第一次标记并进行下一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。当对象没有覆盖<code>finalize()</code>方法或者<code>finalize()</code>方法已经被虚拟机执行过，都会被认为没有必要执行。</li><li>如果这个对象被虚拟机认为有必要执行<code>finalize()</code>方法，那么这个对象将会放置在一个叫<code>F-Queue</code>的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的<code>Finalizer</code>线程去执行它。如果对象想要拯救自己，那么覆盖<code>finalize()</code>方法在方法中重新将自身与引用链上的任意一个对象关联起来就可以避免自己被回收。</li></ol><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区（永久代）的垃圾回收主要包括两个部分：废弃常量和无用的类。</p><ul><li>废弃常量指的是没有任何地方引用这个常量，这个常量会被系统清理出常量池；</li><li>无用的类需要同时满足以下三个条件：<blockquote><ol><li>该类的所有实例都已经被回收，也就是<code>Java</code>堆中不存在该类的任何实例；</li><li>加载该类的<code>ClassLoader</code>已经被回收；</li><li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。</li></ol></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;垃圾收集&quot;&gt;&lt;a href=&quot;#垃圾收集&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集&quot;&gt;&lt;/a&gt;垃圾收集&lt;/h1&gt;&lt;p&gt;垃圾回收需要关注的事情：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;哪些内存需要回收？ Java堆和方法区&lt;/li&gt;
&lt;li&gt;什么时候回收？&lt;/li&gt;
&lt;li&gt;如何回收？&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="内存分配策略" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    
      <category term="引用计数法" scheme="http://yoursite.com/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95/"/>
    
      <category term="可达性算法" scheme="http://yoursite.com/tags/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域</title>
    <link href="http://yoursite.com/2019/01/10/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/01/10/Java内存区域/</id>
    <published>2019-01-10T04:04:56.000Z</published>
    <updated>2019-01-18T04:19:10.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><p>Java虚拟机在执行Java程序的过程中，把其所管理的内存划分成多个区域，如下图所示。每个数据区域都有各自的用途，有的区域随着虚拟机进程的启动而存在，是线程公有的；有些区域依赖于特定的线程而存在，是线程私有的。<br><img src="/2019/01/10/Java内存区域/运行时内存.png" alt="image"><br><a id="more"></a></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一小块内存区域，可以看作是当前线程执行的字节码的行号指示器。每条线程都独立拥有一个程序计数器，因此程序计数器是线程私有的。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧（stack frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从被调用开始执行到执行完成返回的过程，就对应这一个栈帧在虚拟机栈中入栈和出栈的过程。Java内存区域经常被简单地划分为堆内存和栈内存，其中的栈内存粗略来讲就是指的Java虚拟机栈，当然实际上内存划分肯定更加复杂。虚拟机栈与程序计数器一样的线程私有的。<br>局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，直观上相当于C语言中的指针，存放的是对象地址）。64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个Slot。<br>与Java虚拟机栈相关的两个异常：如果线程请求的栈深度大于虚拟机所允许的深度，就会抛出StackOverflowError异常，一般Java程序中递归调用一个方法而不设置终止条件就会出现这个异常，例如下面样例程序求解斐波那契数列，注释了终止条件就会出现异常；如果虚拟机栈可以动态扩展，但是扩展时无法申请到足够的内存空间，就会抛出OutOfMemoryError异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int getFibonacci(int n) &#123;</span><br><span class="line">    // if(n == 0||n == 1)&#123;</span><br><span class="line">    //     return n;</span><br><span class="line">    // &#125;</span><br><span class="line">    return getFibonacciByRecursion(n-1)+getFibonacciByRecursion(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用相似，只不过区别在于虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机中使用到的Native方法服务。有的虚拟机，如Sun HotSpot虚拟机将本地方法栈和虚拟机栈合二为一。<br>那什么是Native方法呢？简单来讲，一个native method就是一个java调用非java代码的接口，也就是该方法由非java语言实现，比如C语言。那么可以知道，在定义一个native方法时，不需要提供实现，只需要定义方法名，参数以及返回类型，如下面实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class IHaveNatives &#123;</span><br><span class="line">    native public void Native1( int x ) ;</span><br><span class="line">    native static public long Native2() ;</span><br><span class="line">    native synchronized private float Native3( Object o ) ;</span><br><span class="line">    native void Native4( int[] ary ) throws Exception ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆（Java Heap）一般是Java虚拟机所管理的内存中最大的一块，被Java虚拟机进程下的所有线程共享的一块内存区域。Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都要在堆上分配内存。Java虚拟机规范中描述：所有的对象实例以及数组都要在堆上分配（The heap is the runtime data area from which memory for all class instances and arrays is allocated），但是随着JIT编译器的发展以及逃逸分析技术的成熟，栈上分配、标量替换优化技术使得所有对象在堆上分配内存就变得不那么“绝对”。<br>Java堆是垃圾收集器管理的主要区域，很多时候也被称之为“GC 堆（Garbage Collected Heap）”。从垃圾回收的角度来看，目前垃圾收集器都采用分代算法，所以Java堆还细分为：新生代和老年代，其中新生代又可以分为Eden空间、From Survivor空间、To Survivor空间，HotSpot虚拟机默认Eden和Survivor的大小比例是8:1。<br>根据Java虚拟机规范规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑连续就行了。目前主流的虚拟机都可以通过命令来自主设置Java堆的大小，其中命令-Xms1024m指的是Java堆的初始大小，-Xmx2048m指的是分配给Java堆的最大内存。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区和Java堆一样也是所有线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。有些在HotSpot虚拟机上开发、部署程序的开发者习惯称方法区为“永久代（Permanent Generation）”，这是由于HotSpot虚拟机的垃圾收集器可以像管理Java堆一样管理方法区这块内存区域，省去了专门为方法区编写内存管理代码的工作。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。<br>运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，比如String类中的intern()方法。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁使用。<br>自从JDK1.4中引入NIO（New Input/Output）类，提出一种基于通道（Channel）和缓冲区（Buffer）的I/O方式，它可以使用Native方法直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p><h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><p>虚拟机遇到一条new指令，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有就必须先执行相关的类加载过程。<br>在类加载检查通过之后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后就可以完全确定，为对象分配空间的任务就是把一块确定大小的内存从Java堆中划分出来。<br>假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那么分配内存就是把指针往空闲内存的方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞（Bump the Pointer）”；如果Java堆中的内存不规整，那么虚拟机就必须维护一个列表，记录哪些内存块可用，在为对象分配内存的时候就从列表中寻找一块足够大的空间划分给对象实例，并更新表上的记录，这种分配方式称为“空闲列表（Free List）”。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存区域&quot;&gt;&lt;a href=&quot;#Java内存区域&quot; class=&quot;headerlink&quot; title=&quot;Java内存区域&quot;&gt;&lt;/a&gt;Java内存区域&lt;/h1&gt;&lt;p&gt;Java虚拟机在执行Java程序的过程中，把其所管理的内存划分成多个区域，如下图所示。每个数据区域都有各自的用途，有的区域随着虚拟机进程的启动而存在，是线程公有的；有些区域依赖于特定的线程而存在，是线程私有的。&lt;br&gt;&lt;img src=&quot;/2019/01/10/Java内存区域/运行时内存.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Java堆" scheme="http://yoursite.com/tags/Java%E5%A0%86/"/>
    
      <category term="方法区" scheme="http://yoursite.com/tags/%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    
      <category term="Java虚拟机栈" scheme="http://yoursite.com/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    
  </entry>
  
</feed>
