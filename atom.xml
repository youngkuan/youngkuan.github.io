<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yangkuan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-14T08:33:30.955Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yang Kuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>垃圾收集（二）</title>
    <link href="http://yoursite.com/2019/01/14/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/01/14/垃圾收集（二）/</id>
    <published>2019-01-14T02:25:44.000Z</published>
    <updated>2019-01-14T08:33:30.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h1><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>算法分为标记阶段和清除阶段 ，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程就是引用计数法或者可达性算法判断对象是否存活的过程。<br>不足：  </p><ol><li>效率问题，标记和清除两个阶段的效率都不高；</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序运行过程中需要分配较大对象时，无法找到足够的内存碎片而不得不提前出发一次垃圾收集动作。<br>标记清除算法的执行过程如下图所示：  </li></ol><p><img src="/2019/01/14/垃圾收集（二）/gc1.png" alt="image"></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，一种“复制”的垃圾收集算法出现了，它将可用的内存分成大小相等的两个区域，每次只使用其中的一块区域。当这块区域用完之后，就将还存活着的对象复制到另一块内存区域上，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行垃圾回收，内存分配时也就不用再考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法每次只能使用一半的内存，相当于将内存缩小为原来的一半，代价太高。复制算法的执行过程如下图所示：</p><p><img src="/2019/01/14/垃圾收集（二）/gc2.png" alt="image"></p><p>目前的商业虚拟机都是采用复制算法回收新生代，但是并不按照<code>1:1</code>划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的<code>Survivor</code>空间，每次使用<code>Eden</code>和其中一块<code>Survivor</code>。当回收时，将Eden和Survivor中还存活的对象一次性复制到另一块<code>Survivor</code>空间上，最后清理掉Eden和刚才用过的Survivor空间。<code>HotSpot</code>虚拟机默认<code>Eden：Survivor=8:1</code>，也就是每次新生代中可用内存空间为整个新生代容量的<code>90%</code>，只有<code>10%</code>的内存被“浪费”。当然在大多数（<code>98%</code>）情况下，只有不超过<code>10%</code>的对象存活，而当超过<code>10%</code>时，也就意味着<code>Survivor</code>空间不够用，这个时候就需要依赖老年代进行分配担保（无法再<code>Survivor</code>区存放的对象直接进入老年代）。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制算法在对象存活率较高的情况下就会进行较多的复制操作，效率将会变低，而且还需要额外的内存空间进行分配担保，以应对内存（<code>Survivor</code>空间）不够容纳存活对象的极端情况。<br>因此，老年代一般不采用复制算法，而采用“标记-整理”（<code>Mark-Compact</code>）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让存活对象都向一端移动，然后直接清理掉端边界以外的内存，标记-整理算法的示意图如下：</p><p><img src="/2019/01/14/垃圾收集（二）/gc3.png" alt="image"></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”（<code>Generational Collection</code>）算法，这种算法根据对象存活周期的不同将内存划分为几块。一般是把Java堆划分成新生代和老生代，从而根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集都会发现大量的对象死去，只有少量对象存活，因此采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；在老年代中因为对象存活率高、没有额外的空间对它进行分配担保，就必须采用“标记-清理”或者“标记-整理”算法进行回收。</p><h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>从可达性分析中从<code>GC Roots</code>节点找到引用链这个操作为例，可作为<code>GC Roots</code>的加点主要在全局性的引用（例如常量或类静态变量）与执行上下文（例如栈帧中的本地变量表）中，现在的很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。<br>另外，可达性分析对执行时间的敏感还体现在<code>GC</code>停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行——这里的“一致性”的意思是在真个分析过程中整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致在<code>GC</code>进行时必须停止多有<code>Java</code>执行线程的其中一个重要原因。即时在号称（几乎）不会发生停顿的<code>CMS</code>收集器中，枚举根节点时也是必须要停顿的。<br>由于目前主流的<code>Java</code>虚拟机使用的都是准确式<code>GC</code>，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在<code>HotSpot</code>的实现中，是使用一组称为<code>OopMap</code>的数据结构来达到这个目的，在类加载完成时，<code>HotSpot</code>就把对象内什么偏移量上是什么类型的数据计算出来，在<code>JIT</code>编译过程中，也会在特定位置记录下栈和寄存器哪些位置是引用。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>在<code>OopMap</code>的协助下，<code>HotSpot</code>可以快速且准确地完成<code>GC Roots</code>枚举，但一个很现实的问题随之而来：可能导致引用关系发生变化，或者说<code>OopMap</code>内容变化的指令非常多，如果每一条指令都生成对应的<code>OopMap</code>，那将会需要大量的额外空间，这样<code>GC</code>的空间成本就会变得很高。<br>实际上，<code>HotSpot</code>也的确没有为每条指令都生成<code>OopMap</code>，前面已经提到只是在“特定的位置”记录这些信息，这些位置称为安全点（<code>Safepoint</code>），即程序执行时并非在所有的地方都能停顿下来开始GC，只有到达安全点时才能暂停。<code>Safepoint</code>的选定既不能太少以致于GC等待时间过长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的————因为每一条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”最明显的特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才回产生<code>Safepoint</code>。<br>对于<code>Safepoint</code>，另一个需要考虑的问题就是如何在GC发生时让所有的线程都“跑”到最近的安全点上停顿下来。这里有两种方案可以选择:抢先式中断（<code>Preemptive Suspension</code>）和主动式中断（<code>Voluntary Suspension</code>），其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有的线程全部中断，如果发现线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而相应GC时间。<br>而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</p><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>使用<code>Safepoint</code>似乎已经完美解决了如何进入<code>GC</code>的问题，但实际情况却并不一定。<code>Safepoint</code>机制保证了程序执行时，在不太长的时间内就会遇到可进入<code>GC</code>的<code>Safepoint</code>。但是程序不执行的时候，<code>CPU</code>没有分配时间给程序，典型例子就是线程处于<code>Sleep</code>或者<code>Blocked</code>状态，这时线程无法响应<code>JVM</code>的中断请求，“走”到安全的地方去挂起中断，<code>JVM</code>也不太可能等待这些线程重新分配<code>CPU</code>时间。<br>对于这种情况就需要安全区域（<code>Safe Region</code>）来解决。安全区域是指在一段代码片段中，引用关系不会发生变化。在这个区域中的任何地方开始GC都是安全的。<br>在线程执行到<code>Saferegion</code>中的代码时，首先标志自己进入了<code>Saferegion</code>，那样当在这段时间里<code>JVM</code>要发起<code>GC</code>时，就不用管标志自己为<code>Saferegion</code>状态的线程了。在线程要离开<code>Saferegion</code>时，它要检查系统是否已经完成了根节点枚举（或者整个<code>GC</code>过程），如果完成了那么线程继续执行，否则它就要等待直到收到可以安全离开<code>Saferegion</code>的信号为止。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;垃圾收集&quot;&gt;&lt;a href=&quot;#垃圾收集&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集&quot;&gt;&lt;/a&gt;垃圾收集&lt;/h1&gt;&lt;h2 id=&quot;垃圾收集算法&quot;&gt;&lt;a href=&quot;#垃圾收集算法&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集算
      
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="垃圾收集算法" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="垃圾收集器" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
      <category term="安全点" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E7%82%B9/"/>
    
      <category term="安全区域" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集(一)</title>
    <link href="http://yoursite.com/2019/01/12/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2019/01/12/垃圾收集/</id>
    <published>2019-01-12T03:50:08.000Z</published>
    <updated>2019-01-12T11:46:35.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h1><p>垃圾回收需要关注的事情：  </p><ol><li>哪些内存需要回收？ Java堆和方法区</li><li>什么时候回收？</li><li>如何回收？  </li></ol><p>java内存运行时各个区域，其中程序计数器、java虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地进行出栈和入栈操作。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收器所关注的就是这部分内存。</p><h2 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h2><h3 id="引用计数法（Reference-Counting）"><a href="#引用计数法（Reference-Counting）" class="headerlink" title="引用计数法（Reference Counting）"></a>引用计数法（Reference Counting）</h3><p>算法描述：给对象中添加一个引用计数器，每当有一个引用指向这个对象，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器值为0的对象就不可能再被使用。<br>引用计数法存在一个问题：它很难解决对象之间的相互循环引用问题，举个例子，示例代码如下。对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">/**</span><br><span class="line"> * 对象objA和objB存在相互引用</span><br><span class="line"> * @author yangkuan</span><br><span class="line"> */</span><br><span class="line">public class ReferenceCounteringGC &#123;</span><br><span class="line">    public Object instance = null;</span><br><span class="line"></span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line">    /**</span><br><span class="line">     * 这个成员变量的意义是通过其占用的内存，通过GC日志查看对象是否被回收</span><br><span class="line">     */</span><br><span class="line">    private byte[] bigSize = new byte[2 * _1MB];</span><br><span class="line"></span><br><span class="line">    public static void testGC()&#123;</span><br><span class="line">        ReferenceCounteringGC objA = new ReferenceCounteringGC();</span><br><span class="line">        ReferenceCounteringGC objB = new ReferenceCounteringGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = null;</span><br><span class="line">        objB = null;</span><br><span class="line"></span><br><span class="line">        // 假设此处发生垃圾回收，如果回收算法是引用计数法，那么objA和objB将不会被回收</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="可达性分析算法（Reachability-Analysis）"><a href="#可达性分析算法（Reachability-Analysis）" class="headerlink" title="可达性分析算法（Reachability Analysis）"></a>可达性分析算法（Reachability Analysis）</h3><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>这个算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（即该对象到GC Roots不可达）时，则证明这个对象不可用。那这些不可达的对象就可以判定为可回收对象。<br>可作为GC Roots的对象包括以下几种：  </p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（即Native方法）引用的对象。</li></ul><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ol><li><strong>强引用（Strong Reference）</strong><br>强引用就是指在程序代码之中普遍存在的，类似<code>Object obj = new Object()</code>这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li><strong>软引用（Soft Reference）</strong><br>软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收之后还没有足够的内存，那么程序就会抛出内存溢出异常。</li><li><strong>弱引用（Weak Reference）</strong><br>弱引用也是用来描述非必须对象的，但是它的强度比软引用还要更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前。当垃圾收集器工作时，无论当内存是否足够，都会回收掉只被弱引用关联的对象。</li><li><strong>虚引用（Phantom Reference）</strong><br>虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成威胁，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ol><h4 id="对象的两次标记过程"><a href="#对象的两次标记过程" class="headerlink" title="对象的两次标记过程"></a>对象的两次标记过程</h4><ol><li>如果对象再进行可达性分析的时候发现其与<code>GC Roots</code>之间不可达，那么它将会被第一次标记并进行下一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。当对象没有覆盖<code>finalize()</code>方法或者<code>finalize()</code>方法已经被虚拟机执行过，都会被认为没有必要执行。</li><li>如果这个对象被虚拟机认为有必要执行<code>finalize()</code>方法，那么这个对象将会放置在一个叫<code>F-Queue</code>的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的<code>Finalizer</code>线程去执行它。如果对象想要拯救自己，那么覆盖<code>finalize()</code>方法在方法中重新将自身与引用链上的任意一个对象关联起来就可以避免自己被回收。</li></ol><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区（永久代）的垃圾回收主要包括两个部分：废弃常量和无用的类。</p><ul><li>废弃常量指的是没有任何地方引用这个常量，这个常量会被系统清理出常量池；</li><li>无用的类需要同时满足以下三个条件：<blockquote><ol><li>该类的所有实例都已经被回收，也就是<code>Java</code>堆中不存在该类的任何实例；</li><li>加载该类的<code>ClassLoader</code>已经被回收；</li><li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。</li></ol></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;垃圾收集&quot;&gt;&lt;a href=&quot;#垃圾收集&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集&quot;&gt;&lt;/a&gt;垃圾收集&lt;/h1&gt;&lt;p&gt;垃圾回收需要关注的事情：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;哪些内存需要回收？ Java堆和方法区&lt;/li&gt;
&lt;li&gt;什么时候回
      
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="内存分配策略" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    
      <category term="引用计数法" scheme="http://yoursite.com/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95/"/>
    
      <category term="可达性算法" scheme="http://yoursite.com/tags/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域</title>
    <link href="http://yoursite.com/2019/01/10/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/01/10/Java内存区域/</id>
    <published>2019-01-10T04:04:56.000Z</published>
    <updated>2019-01-10T08:03:58.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><p>Java虚拟机在执行Java程序的过程中，把其所管理的内存划分成多个区域，如下图所示。每个数据区域都有各自的用途，有的区域随着虚拟机进程的启动而存在，是线程公有的；有些区域依赖于特定的线程而存在，是线程私有的。<br><img src="/2019/01/10/Java内存区域/运行时内存.png" alt="image"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一小块内存区域，可以看作是当前线程执行的字节码的行号指示器。每条线程都独立拥有一个程序计数器，因此程序计数器是线程私有的。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧（stack frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从被调用开始执行到执行完成返回的过程，就对应这一个栈帧在虚拟机栈中入栈和出栈的过程。Java内存区域经常被简单地划分为堆内存和栈内存，其中的栈内存粗略来讲就是指的Java虚拟机栈，当然实际上内存划分肯定更加复杂。虚拟机栈与程序计数器一样的线程私有的。<br>局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，直观上相当于C语言中的指针，存放的是对象地址）。64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个Slot。<br>与Java虚拟机栈相关的两个异常：如果线程请求的栈深度大于虚拟机所允许的深度，就会抛出StackOverflowError异常，一般Java程序中递归调用一个方法而不设置终止条件就会出现这个异常，例如下面样例程序求解斐波那契数列，注释了终止条件就会出现异常；如果虚拟机栈可以动态扩展，但是扩展时无法申请到足够的内存空间，就会抛出OutOfMemoryError异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int getFibonacci(int n) &#123;</span><br><span class="line">    // if(n == 0||n == 1)&#123;</span><br><span class="line">    //     return n;</span><br><span class="line">    // &#125;</span><br><span class="line">    return getFibonacciByRecursion(n-1)+getFibonacciByRecursion(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用相似，只不过区别在于虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机中使用到的Native方法服务。有的虚拟机，如Sun HotSpot虚拟机将本地方法栈和虚拟机栈合二为一。<br>那什么是Native方法呢？简单来讲，一个native method就是一个java调用非java代码的接口，也就是该方法由非java语言实现，比如C语言。那么可以知道，在定义一个native方法时，不需要提供实现，只需要定义方法名，参数以及返回类型，如下面实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class IHaveNatives &#123;</span><br><span class="line">    native public void Native1( int x ) ;</span><br><span class="line">    native static public long Native2() ;</span><br><span class="line">    native synchronized private float Native3( Object o ) ;</span><br><span class="line">    native void Native4( int[] ary ) throws Exception ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆（Java Heap）一般是Java虚拟机所管理的内存中最大的一块，被Java虚拟机进程下的所有线程共享的一块内存区域。Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都要在堆上分配内存。Java虚拟机规范中描述：所有的对象实例以及数组都要在堆上分配（The heap is the runtime data area from which memory for all class instances and arrays is allocated），但是随着JIT编译器的发展以及逃逸分析技术的成熟，栈上分配、标量替换优化技术使得所有对象在堆上分配内存就变得不那么“绝对”。<br>Java堆是垃圾收集器管理的主要区域，很多时候也被称之为“GC 堆（Garbage Collected Heap）”。从垃圾回收的角度来看，目前垃圾收集器都采用分代算法，所以Java堆还细分为：新生代和老年代，其中新生代又可以分为Eden空间、From Survivor空间、To Survivor空间，HotSpot虚拟机默认Eden和Survivor的大小比例是8:1。<br>根据Java虚拟机规范规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑连续就行了。目前主流的虚拟机都可以通过命令来自主设置Java堆的大小，其中命令-Xms1024m指的是Java堆的初始大小，-Xmx2048m指的是分配给Java堆的最大内存。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区和Java堆一样也是所有线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。有些在HotSpot虚拟机上开发、部署程序的开发者习惯称方法区为“永久代（Permanent Generation）”，这是由于HotSpot虚拟机的垃圾收集器可以像管理Java堆一样管理方法区这块内存区域，省去了专门为方法区编写内存管理代码的工作。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。<br>运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，比如String类中的intern()方法。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁使用。<br>自从JDK1.4中引入NIO（New Input/Output）类，提出一种基于通道（Channel）和缓冲区（Buffer）的I/O方式，它可以使用Native方法直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p><h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><p>虚拟机遇到一条new指令，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有就必须先执行相关的类加载过程。<br>在类加载检查通过之后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后就可以完全确定，为对象分配空间的任务就是把一块确定大小的内存从Java堆中划分出来。<br>假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那么分配内存就是把指针往空闲内存的方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞（Bump the Pointer）”；如果Java堆中的内存不规整，那么虚拟机就必须维护一个列表，记录哪些内存块可用，在为对象分配内存的时候就从列表中寻找一块足够大的空间划分给对象实例，并更新表上的记录，这种分配方式称为“空闲列表（Free List）”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java内存区域&quot;&gt;&lt;a href=&quot;#Java内存区域&quot; class=&quot;headerlink&quot; title=&quot;Java内存区域&quot;&gt;&lt;/a&gt;Java内存区域&lt;/h1&gt;&lt;p&gt;Java虚拟机在执行Java程序的过程中，把其所管理的内存划分成多个区域，如下图所示。每个数
      
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Java堆" scheme="http://yoursite.com/tags/Java%E5%A0%86/"/>
    
      <category term="方法区" scheme="http://yoursite.com/tags/%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    
      <category term="Java虚拟机栈" scheme="http://yoursite.com/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>cuda安装</title>
    <link href="http://yoursite.com/2019/01/08/cuda%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/01/08/cuda安装/</id>
    <published>2019-01-08T13:38:04.000Z</published>
    <updated>2019-01-08T13:49:54.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cuda安装"><a href="#cuda安装" class="headerlink" title="cuda安装"></a>cuda安装</h1><h2 id="cuda和cudnn版本查看"><a href="#cuda和cudnn版本查看" class="headerlink" title="cuda和cudnn版本查看"></a>cuda和cudnn版本查看</h2><ol><li>cuda版本</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/local/cuda/version.txt</span><br></pre></td></tr></table></figure><ol start="2"><li>cudnn版本</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2</span><br></pre></td></tr></table></figure><h2 id="cuda8-0卸载"><a href="#cuda8-0卸载" class="headerlink" title="cuda8.0卸载"></a>cuda8.0卸载</h2><ol><li>卸载</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt autoremove cuda</span><br></pre></td></tr></table></figure><ol start="2"><li>清除残留文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">rm -rf cuda-8.0/</span><br></pre></td></tr></table></figure><h2 id="cuda9-0及对应cudnn安装"><a href="#cuda9-0及对应cudnn安装" class="headerlink" title="cuda9.0及对应cudnn安装"></a>cuda9.0及对应cudnn安装</h2><h3 id="cuda9-0安装"><a href="#cuda9-0安装" class="headerlink" title="cuda9.0安装"></a>cuda9.0安装</h3><p><a href="https://developer.nvidia.com/cuda-90-download-archive" target="_blank" rel="noopener">cuda9.0官方网站</a></p><ol><li>运行压缩.run</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh cuda_9.0.176_384.81_linux.run</span><br></pre></td></tr></table></figure><ul><li>一般在不需要图形驱动（Grphics Driver）和 样例（cuda samples）</li></ul><p><img src="/2019/01/08/cuda安装/cuda0.png" alt="image"></p><p><a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">cudnn官方网站</a></p><p>2.~/.bashrc配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export CUDA_HOME=/usr/local/cuda</span><br><span class="line">export LD_LIBRARY_PATH=$&#123;CUDA_HOME&#125;/lib64</span><br><span class="line">export PATH=$&#123;CUDA_HOME&#125;/bin:$&#123;PATH&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>刷新使得配置生效</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="cudnn安装"><a href="#cudnn安装" class="headerlink" title="cudnn安装"></a>cudnn安装</h3><p>本次版本是<strong>cuDNN v7.4.2 (Dec 14, 2018), for CUDA 9.0</strong>，选择<strong>cuDNN Library for Linux</strong>。</p><ol><li>解压cudnn-9.0-linux-x64-v7.4.2.24.tgz压缩包</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf cudnn-9.0-linux-x64-v7.4.2.24.tgz</span><br></pre></td></tr></table></figure><p><img src="/2019/01/08/cuda安装/cuda1.png" alt="image"></p><ol start="2"><li>复制文件到cuda库下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp cuda/lib64/* /usr/local/cuda-9.0/lib64/</span><br><span class="line">cp cuda/include/* /usr/local/cuda-9.0/include/</span><br></pre></td></tr></table></figure><ol start="3"><li>查看cudnn版本信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2</span><br></pre></td></tr></table></figure><h3 id="cuda切换"><a href="#cuda切换" class="headerlink" title="cuda切换"></a>cuda切换</h3><p>当一台服务器上既安装了cuda8.0和cuda9.0，使用ls命令查看/usr/local下的文件包含三个文件夹cuda、cuda8.0和cuda9.0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /usr/local/</span><br></pre></td></tr></table></figure><p><img src="/2019/01/08/cuda安装/cuda3.png" alt="image"></p><ol><li>可以看到，当前cuda文件夹链接到cuda-9.0,当需要切换到cuda8.0时，使用以下命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /usr/local/cuda #删除之前创建的软链接</span><br><span class="line">sudo ln -s /usr/local/cuda-8.0/ /usr/local/cuda</span><br><span class="line">nvcc --version #查看当前 cuda 版本</span><br></pre></td></tr></table></figure><p><a href="http://geyao1995.com/CUDA8_CUDA9/" target="_blank" rel="noopener">参考博客：http://geyao1995.com/CUDA8_CUDA9/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cuda安装&quot;&gt;&lt;a href=&quot;#cuda安装&quot; class=&quot;headerlink&quot; title=&quot;cuda安装&quot;&gt;&lt;/a&gt;cuda安装&lt;/h1&gt;&lt;h2 id=&quot;cuda和cudnn版本查看&quot;&gt;&lt;a href=&quot;#cuda和cudnn版本查看&quot; class=&quot;
      
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="环境配置" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="软件安装" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Hierarchical Object Detection with Deep Reinforcement Learning</title>
    <link href="http://yoursite.com/2019/01/08/Hierarchical-Object-Detection-with-Deep-Reinforcement-Learning/"/>
    <id>http://yoursite.com/2019/01/08/Hierarchical-Object-Detection-with-Deep-Reinforcement-Learning/</id>
    <published>2019-01-08T13:31:17.000Z</published>
    <updated>2019-01-08T13:34:20.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hierarchical-Object-Detection-with-Deep-Reinforcement-Learning"><a href="#Hierarchical-Object-Detection-with-Deep-Reinforcement-Learning" class="headerlink" title="Hierarchical Object Detection with Deep Reinforcement Learning"></a>Hierarchical Object Detection with Deep Reinforcement Learning</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><blockquote><p>关键的思想在于关注图像中包含更丰富信息的那些部分并放大它们。</p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol><li>考虑区域之间的联系，</li><li>利用top-down的扫描方式，首先获取整个图像，关注局部区域的相关信息，</li><li>基于增强学习训练的代理（agent）有能力检测图像中的对象</li></ol><h2 id="Hierarchical-Object-Detection-Model"><a href="#Hierarchical-Object-Detection-Model" class="headerlink" title="Hierarchical Object Detection Model"></a>Hierarchical Object Detection Model</h2><h6 id="1-Markov-Decision-Process（马尔科夫决策过程）"><a href="#1-Markov-Decision-Process（马尔科夫决策过程）" class="headerlink" title="1. Markov Decision Process（马尔科夫决策过程）"></a><strong>1. Markov Decision Process（马尔科夫决策过程）</strong></h6><blockquote><p>State:当前区域描述符（the descriptor of current region）和记忆向量（memory vector）</p></blockquote><blockquote><p>Actions:move actions和terminal actions</p></blockquote><blockquote><p>Reward:<br>保证move action都是朝着更靠近ground truth的方向移动；<br>当IOU超过threshold，则终止移动。</p></blockquote><h6 id="2-Q-learning"><a href="#2-Q-learning" class="headerlink" title="2. Q-learning"></a><strong>2. Q-learning</strong></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q(s,a) = r+\lambda&#123;max&#125;_&#123;a&apos;&#125;Q(s&apos;,a&apos;)</span><br></pre></td></tr></table></figure><h6 id="3-Model"><a href="#3-Model" class="headerlink" title="3. Model"></a><strong>3. Model</strong></h6><ul><li><p>the Image-Zooms model</p><blockquote><p>使用VGG-16提取图像区域特征向量<code>$(7*7*512)$</code>,<br>拼接区域特征向量与记忆向量（memory vector）<code>$(7*7*512+24=25088+24)$</code>,<br>经过两个1024维的全连接层，输出6个可能的动作（actions），<br>反复迭代，直到终止动作</p></blockquote></li><li><p>the Pool45-Crops model<br><img src="/2019/01/08/Hierarchical-Object-Detection-with-Deep-Reinforcement-Learning/Hierarchical-Object-Detection-Models.png" alt="image"></p></li></ul><h6 id="4-Training"><a href="#4-Training" class="headerlink" title="4. Training"></a><strong>4. Training</strong></h6><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h6 id="1-Qualitative-Results"><a href="#1-Qualitative-Results" class="headerlink" title="1. Qualitative Results"></a><strong>1. Qualitative Results</strong></h6><p><img src="/2019/01/08/Hierarchical-Object-Detection-with-Deep-Reinforcement-Learning/aeroplane20180626.png" alt="image"></p><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><a href="https://github.com/imatge-upc/detection-2016-nipsws" target="_blank" rel="noopener">Implementation</a></h2><h6 id="1-keras实现"><a href="#1-keras实现" class="headerlink" title="1. keras实现"></a><strong>1. keras实现</strong></h6><ul><li>提取区域特征</li></ul><p><img src="/2019/01/08/Hierarchical-Object-Detection-with-Deep-Reinforcement-Learning/vgg16.png" alt="image"></p><ul><li><p>state不断更新，并作为model的输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(7*7*512)</span><br></pre></td></tr></table></figure></li><li></li></ul><h2 id="代码问题总结"><a href="#代码问题总结" class="headerlink" title="代码问题总结"></a>代码问题总结</h2><ol><li>数据类型错误<strong>TypeError: slice indices must be integers or None or have an <strong>index</strong> method</strong></li></ol><p>这是由于数组，矩阵等类型数据的下标是整数，而在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">region_mask[offset[0]:offset[0] + size_mask[0]</span><br><span class="line">                         , offset[1]:offset[1] + size_mask[1]] = 1</span><br></pre></td></tr></table></figure><p>offset是float类型，所以报错，解决方法就是数据类型转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">region_mask[int(offset[0]):int(offset[0] + size_mask[0])</span><br><span class="line">                          , int(offset[1]):int(offset[1] + size_mask[1])] = 1</span><br></pre></td></tr></table></figure><ol start="2"><li>VGG16提取图像特征尺寸不对</li></ol><p><img src="/2019/01/08/Hierarchical-Object-Detection-with-Deep-Reinforcement-Learning/error1.png" alt="image"></p><p>解决方法：在图片提取特征之前，对图像进行resize；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">im = images[z].resize((224, 224))</span><br></pre></td></tr></table></figure><ol start="3"><li>除0错误</li></ol><p><img src="/2019/01/08/Hierarchical-Object-Detection-with-Deep-Reinforcement-Learning/error2.png" alt="image"></p><p>对图像进行resize的位置错误</p><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><ol><li>问题：记忆向量的哪儿来的？</li><li>问题：哪6个动作？<blockquote><p>move actions:左上、右上、左下、右下和中；<br>terminal actions</p></blockquote></li><li>问题：每个类训练一个模型？<blockquote><p>是的，这篇文章中只训练了飞机类（aeroplane）的检测模型</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hierarchical-Object-Detection-with-Deep-Reinforcement-Learning&quot;&gt;&lt;a href=&quot;#Hierarchical-Object-Detection-with-Deep-Reinforcement-Lear
      
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="对象检测" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Yotta系统错误记录及性能优化</title>
    <link href="http://yoursite.com/2019/01/07/Yotta%E7%B3%BB%E7%BB%9F%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/01/07/Yotta系统错误记录及性能优化/</id>
    <published>2019-01-07T03:28:21.000Z</published>
    <updated>2019-01-08T10:29:32.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h2><ol><li>在日志系统运行期间，每隔几天kafka平台就会自动崩溃，控制台窗口关闭，并且重新启动kafka平台也会出现日志文件冲突问题，从而导致日志系统无法正常记录用户行为日志。</li></ol><p>解决方法：</p><ul><li>首先，我们查阅了官网的各种文档，在全面了解kafka的实现原理与应用之后仍然没有找到解决问题的方法。然后我们在StackOverflow和Quora上进行了相关问题的查看，尝试后发现类似问题解决方法，将kafka平台对应的日志文件删除就可以正常启动kafka平台。虽然通过删除日志文件的方式使得日志记录正常进行，但是依旧没有解决每隔几天kafka平台就会自动崩溃的问题，频繁人工启动不稳定的服务耗费人力开销。</li><li>为了彻底解决这个问题，我们维护人员仔细阅读kafka生成的日志文件，了解到崩溃的发生是因为日志文件大小达到阈值时kafka程序会对日志文件重命名，而此时日志文件又被自身所占用，就产生了程序异常，在Apache官网issues下发现这是此版本kafka在windows下的一个错误，所以我们将日志系统整体迁移到linux系统下，将问题完美解决。</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li>Optimizing MySQL LIKE ‘%string%’ queries</li></ol><ul><li>方法1：建立fulltext索引，全文索引只能用于数据库引擎为MYISAM的数据表，但是全文索引不支持中文；</li><li>方法2：</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;错误记录&quot;&gt;&lt;a href=&quot;#错误记录&quot; class=&quot;headerlink&quot; title=&quot;错误记录&quot;&gt;&lt;/a&gt;错误记录&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在日志系统运行期间，每隔几天kafka平台就会自动崩溃，控制台窗口关闭，并且重新启动kafka平台也会出现日志文
      
    
    </summary>
    
      <category term="工程" scheme="http://yoursite.com/categories/%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="yotta系统" scheme="http://yoursite.com/tags/yotta%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>图像文本匹配相关工作</title>
    <link href="http://yoursite.com/2018/11/07/%E5%9B%BE%E5%83%8F%E6%96%87%E6%9C%AC%E5%8C%B9%E9%85%8D%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/11/07/图像文本匹配相关工作/</id>
    <published>2018-11-07T11:36:07.000Z</published>
    <updated>2019-01-09T11:41:29.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像文本匹配相关工作"><a href="#图像文本匹配相关工作" class="headerlink" title="图像文本匹配相关工作"></a>图像文本匹配相关工作</h1><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><ol><li>什么是图像文本匹配？<br>计算机视觉任务逐渐不在满足于简单的图像分类、或者为图像分配一个或几个标签的任务，越来越多的研究者希望能够通过匹配图像和文本，为图像生成丰富的文本描述，从而更好地理解图像的语义。</li><li>已经有大量的研究工作，这些工作的方法怎么做的？</li><li>我的工作在别人的工作上有什么改进？有什么优点、贡献？</li></ol><ul><li>通过生成网络生成更多的正例(positive fact), 从而扩充训练数据集;</li><li>设计了一个高效的训练算法，交替优化生成网络和判别网络的参数，得到强判别器；</li><li>在多个数据集上实现了与其他方法可比较甚至更优异的结果。</li></ul><h2 id="related-work"><a href="#related-work" class="headerlink" title="related work"></a>related work</h2><h4 id="1-CCA"><a href="#1-CCA" class="headerlink" title="1. CCA"></a>1. CCA</h4><ul><li>Canonical Correlation Analysis (CCA)</li><li>Kernel Canonical Correlation Analysis (KCCA)</li><li>deep CCA</li><li>Sparse Kernel CCA</li><li>Randomized CCA</li><li>Nonparametric CCA <h4 id="2-ranking-based-method"><a href="#2-ranking-based-method" class="headerlink" title="2. ranking based method"></a>2. ranking based method</h4></li><li>Y. Verma and C. Jawahar, “Im2text and text2im: Associating images and texts for cross-modal retrieval,” in British Machine Vision Conference (BMVC), vol. 1, 2014, p. 2.</li><li>R. Socher, A. Karpathy, Q. V. Le, C. D. Manning, and A. Y. Ng, “Grounded compositional semantics for finding and describing images with sentences,” Transactions of the Association for Computational Linguistics, vol. 2, pp. 207–218, 2014.  <strong><em>OK</em></strong></li><li>A. Karpathy, A. Joulin, and F. F. F. Li, “Deep fragment embeddings for bidirectional image sentence mapping,” in Neural Information Processing Systems (NIPS), 2014, pp. 1889–1897. <strong><em>OK</em></strong></li><li>R. Kiros, R. Salakhutdinov, and R. S. Zemel, “Unifying visual-semantic embeddings with multimodal neural language models,” arXiv preprint arXiv:1411.2539, 2014. <strong><em>OK</em></strong></li><li>L. Wang, Y. Li, and S. Lazebnik, “Learning deep structure-preserving image-text embeddings,” in Computer Vision and Pattern Recognition (CVPR), 2016, pp. 5005–5013.</li><li>“Learning two-branch neural networks for image-text matching tasks,” arXiv preprint arXiv:1704.03470, 2017.</li><li>Huang Y, Wang W, Wang L. Instance-aware image and sentence matching with selective multimodal lstm[C]//The IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2017, 2(6): 7.</li><li>Huang Y, Wu Q, Wang L. Learning semantic concepts and order for image and sentence matching[C]//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018: 6163-6171.</li></ul><h4 id="3-Generative-Adversarial-Networks-GANs"><a href="#3-Generative-Adversarial-Networks-GANs" class="headerlink" title="3.Generative Adversarial Networks(GANs)"></a>3.Generative Adversarial Networks(GANs)</h4><ul><li>@inproceedings{goodfellow2014generative,<br>title={Generative adversarial nets},<br>author={Goodfellow, Ian and Pouget-Abadie, Jean and Mirza, Mehdi and Xu, Bing and Warde-Farley, David and Ozair, Sherjil and Courville, Aaron and Bengio, Yoshua},<br>booktitle={Advances in neural information processing systems},<br>pages={2672–2680},<br>year={2014}<br>}</li><li>@article{mirza2014conditional,<br>title={Conditional generative adversarial nets},<br>author={Mirza, Mehdi and Osindero, Simon},<br>journal={arXiv preprint arXiv:1411.1784},<br>year={2014}<br>}</li><li>@article{radford2015unsupervised,<br>title={Unsupervised representation learning with deep convolutional generative adversarial networks},<br>author={Radford, Alec and Metz, Luke and Chintala, Soumith},<br>journal={arXiv preprint arXiv:1511.06434},<br>year={2015}<br>}</li><li>@article{reed2016generative,<br>title={Generative adversarial text to image synthesis},<br>author={Reed, Scott and Akata, Zeynep and Yan, Xinchen and Logeswaran, Lajanugen and Schiele, Bernt and Lee, Honglak},<br>journal={arXiv preprint arXiv:1605.05396},<br>year={2016}<br>}</li><li>@inproceedings{wang2017irgan,<br>title={Irgan: A minimax game for unifying generative and discriminative information retrieval models},<br>author={Wang, Jun and Yu, Lantao and Zhang, Weinan and Gong, Yu and Xu, Yinghui and Wang, Benyou and Zhang, Peng and Zhang, Dell},<br>booktitle={Proceedings of the 40th International ACM SIGIR conference on Research and Development in Information Retrieval},<br>pages={515–524},<br>year={2017},<br>organization={ACM}<br>}</li><li>@article{cai2017kbgan,<br>title={Kbgan: Adversarial learning for knowledge graph embeddings},<br>author={Cai, Liwei and Wang, William Yang},<br>journal={arXiv preprint arXiv:1711.04071},<br>year={2017}<br>}</li></ul><h2 id="experiment"><a href="#experiment" class="headerlink" title="experiment"></a>experiment</h2><ol><li>数据集的扩充：<br>对每一张图片进行裁剪，4个角以及中间，并将这5个裁剪的图翻转，一张图片扩充得到10张尺寸为<code>$128 \times 128$</code>的图片。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图像文本匹配相关工作&quot;&gt;&lt;a href=&quot;#图像文本匹配相关工作&quot; class=&quot;headerlink&quot; title=&quot;图像文本匹配相关工作&quot;&gt;&lt;/a&gt;图像文本匹配相关工作&lt;/h1&gt;&lt;h2 id=&quot;introduction&quot;&gt;&lt;a href=&quot;#introduct
      
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="图文匹配" scheme="http://yoursite.com/tags/%E5%9B%BE%E6%96%87%E5%8C%B9%E9%85%8D/"/>
    
      <category term="典型相关分析" scheme="http://yoursite.com/tags/%E5%85%B8%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90/"/>
    
      <category term="排序损失" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E6%8D%9F%E5%A4%B1/"/>
    
      <category term="数据集" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>研究生数学建模：恐怖袭击事件分级</title>
    <link href="http://yoursite.com/2018/09/15/%E7%A0%94%E7%A9%B6%E7%94%9F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%EF%BC%9A%E6%81%90%E6%80%96%E8%A2%AD%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E7%BA%A7/"/>
    <id>http://yoursite.com/2018/09/15/研究生数学建模：恐怖袭击事件分级/</id>
    <published>2018-09-15T13:21:13.000Z</published>
    <updated>2019-01-08T13:26:04.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="研究生数学建模：恐怖袭击事件分级"><a href="#研究生数学建模：恐怖袭击事件分级" class="headerlink" title="研究生数学建模：恐怖袭击事件分级"></a>研究生数学建模：恐怖袭击事件分级</h1><p><strong>特征：人员伤亡、经济损失、时间、地点（人口容量、GDP）等</strong></p><h3 id="财产损失"><a href="#财产损失" class="headerlink" title="财产损失"></a>财产损失</h3><h4 id="特征："><a href="#特征：" class="headerlink" title="特征："></a><strong>特征：</strong></h4><p>攻击类型、武器类型、受害子类型、国家、地区、入选标准（1、2、3、doubtterr）</p><h6 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a><strong>攻击类型</strong></h6><ol><li>暗杀（1/0）</li><li>武装袭击（1/0）</li><li>轰炸爆炸（1/0）</li><li>劫持（1/0）</li><li>设施攻击（1/0）</li><li>徒手攻击（1/0）</li><li>未知（1/0）</li></ol><ol start="8"><li>攻击成功（1/0）</li><li>自杀式袭击（suicide）<h6 id="武器类型"><a href="#武器类型" class="headerlink" title="武器类型"></a><strong>武器类型</strong></h6></li></ol><ol start="9"><li>生化武器、放射性武器（1/0）</li><li>核武器</li><li>轻武器</li><li>炸弹</li><li>燃烧武器</li><li>治乱武器</li><li>交通工具</li><li>破坏设备</li><li>未知</li></ol><h6 id="受害者类型"><a href="#受害者类型" class="headerlink" title="受害者类型"></a><strong>受害者类型</strong></h6><ol start="18"><li>商业</li><li>政府</li><li>警察</li><li>军事</li><li>流产有关</li><li>运输（机场（飞机）或巴士、火车、高铁运输）</li><li>教育机构</li><li>食物或水供应</li><li>媒体设施</li><li>海事</li><li>非政府组织</li><li>其他</li></ol><h6 id="地区"><a href="#地区" class="headerlink" title="地区"></a><strong>地区</strong></h6><ol start="30"><li>北美</li><li>南美</li><li>东亚</li><li>东南亚</li><li>南亚</li><li>中亚</li><li>西欧</li><li>东欧</li><li>中东和北非</li><li>撒哈拉以南非洲</li><li>澳大利亚</li></ol><h6 id="入选标准"><a href="#入选标准" class="headerlink" title="入选标准"></a><strong>入选标准</strong></h6><ol start="41"><li>标准1</li><li>标准2</li><li>标准3</li></ol><p>–</p><ol start="44"><li>疑似恐怖主义</li></ol><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a><strong>输出：</strong></h4><ol><li>灾难性的</li><li>重大的</li><li>较小的</li><li>无损失</li><li>未知</li></ol><ol><li>设置propextent中为空的部分为0，这样就可以去除property</li></ol><h4 id="K-means聚类结果分析"><a href="#K-means聚类结果分析" class="headerlink" title="K-means聚类结果分析"></a><strong>K-means聚类结果分析</strong></h4><blockquote><p>样本数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10953\times 17</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>聚类结果（5类）</p></blockquote><table><thead><tr><th>统计</th><th>类1</th><th>类2</th><th>类3</th><th>类4</th><th>类5</th></tr></thead><tbody><tr><td>数量</td><td>2497</td><td>4645</td><td>134</td><td>1854</td><td>1823</td></tr></tbody></table><h4 id="Spectral-Clustering聚类结果分析"><a href="#Spectral-Clustering聚类结果分析" class="headerlink" title="Spectral Clustering聚类结果分析"></a><strong>Spectral Clustering聚类结果分析</strong></h4><blockquote><p>样本数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10953\times 17</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>聚类结果（5类）</p></blockquote><table><thead><tr><th>统计</th><th>类1</th><th>类2</th><th>类3</th><th>类4</th><th>类5</th></tr></thead><tbody><tr><td>数量</td><td>10883</td><td>1</td><td>15</td><td>1</td><td>53</td></tr></tbody></table><h4 id="分段后K-means聚类结果分析"><a href="#分段后K-means聚类结果分析" class="headerlink" title="分段后K-means聚类结果分析"></a><strong>分段后K-means聚类结果分析</strong></h4><blockquote><p>样本数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10953\times 36</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>聚类结果（5类）</p></blockquote><table><thead><tr><th>统计</th><th>类1</th><th>类2</th><th>类3</th><th>类4</th><th>类5</th></tr></thead><tbody><tr><td>数量</td><td>6339</td><td>1541</td><td>1474</td><td>725</td><td>874</td></tr></tbody></table><h4 id="分段后Spectral-Clustering聚类结果分析"><a href="#分段后Spectral-Clustering聚类结果分析" class="headerlink" title="分段后Spectral Clustering聚类结果分析"></a><strong>分段后Spectral Clustering聚类结果分析</strong></h4><blockquote><p>样本数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10953\times 36</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>聚类结果（5类）</p></blockquote><table><thead><tr><th>统计</th><th>类1</th><th>类2</th><th>类3</th><th>类4</th><th>类5</th></tr></thead><tbody><tr><td>数量</td><td>9472</td><td>26</td><td>1343</td><td>93</td><td>19</td></tr></tbody></table><h4 id="增大死亡数以及财产损失权重，分段后K-means聚类结果分析"><a href="#增大死亡数以及财产损失权重，分段后K-means聚类结果分析" class="headerlink" title="增大死亡数以及财产损失权重，分段后K-means聚类结果分析"></a><strong>增大死亡数以及财产损失权重，分段后K-means聚类结果分析</strong></h4><blockquote><p>样本数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10953\times 36</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>聚类结果（5类）</p></blockquote><table><thead><tr><th>统计</th><th>类1</th><th>类2</th><th>类3</th><th>类4</th><th>类5</th></tr></thead><tbody><tr><td>数量</td><td>1541</td><td>735</td><td>7203</td><td>1474</td><td>0</td></tr></tbody></table><h4 id="增大死亡数以及财产损失权重，分段后Spectral-Clustering聚类结果分析"><a href="#增大死亡数以及财产损失权重，分段后Spectral-Clustering聚类结果分析" class="headerlink" title="增大死亡数以及财产损失权重，分段后Spectral Clustering聚类结果分析"></a><strong>增大死亡数以及财产损失权重，分段后Spectral Clustering聚类结果分析</strong></h4><blockquote><p>样本数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10953\times 36</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>聚类结果（5类）</p></blockquote><table><thead><tr><th>统计</th><th>类1</th><th>类2</th><th>类3</th><th>类4</th><th>类5</th></tr></thead><tbody><tr><td>数量</td><td>9471</td><td>1</td><td>1349</td><td>39</td><td>93</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;研究生数学建模：恐怖袭击事件分级&quot;&gt;&lt;a href=&quot;#研究生数学建模：恐怖袭击事件分级&quot; class=&quot;headerlink&quot; title=&quot;研究生数学建模：恐怖袭击事件分级&quot;&gt;&lt;/a&gt;研究生数学建模：恐怖袭击事件分级&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;特征：人员伤
      
    
    </summary>
    
      <category term="竞赛" scheme="http://yoursite.com/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>智慧教育师范应用表格接口规范</title>
    <link href="http://yoursite.com/2018/07/10/%E6%99%BA%E6%85%A7%E6%95%99%E8%82%B2%E5%B8%88%E8%8C%83%E5%BA%94%E7%94%A8%E8%A1%A8%E6%A0%BC%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/07/10/智慧教育师范应用表格接口规范/</id>
    <published>2018-07-10T09:33:01.000Z</published>
    <updated>2019-01-08T10:29:30.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智慧教育-网络学院示范应用"><a href="#智慧教育-网络学院示范应用" class="headerlink" title="智慧教育-网络学院示范应用"></a>智慧教育-网络学院示范应用</h1><h2 id="后端数据访问接口"><a href="#后端数据访问接口" class="headerlink" title="后端数据访问接口"></a>后端数据访问接口</h2><h3 id="主题状态"><a href="#主题状态" class="headerlink" title="主题状态"></a>主题状态</h3><h5 id="1-主题状态表"><a href="#1-主题状态表" class="headerlink" title="1. 主题状态表"></a>1. <strong>主题状态表</strong></h5><table><thead><tr><th>列名</th><th>类型</th><th>长度</th></tr></thead><tbody><tr><td>state_id</td><td>bigint(long)</td><td>20</td></tr><tr><td>domain_id</td><td>bigint(long)</td><td>20</td></tr><tr><td>states</td><td>varchar(string)</td><td>255</td></tr><tr><td>user_id</td><td>bigint(long)</td><td>20</td></tr><tr><td>created_time</td><td>datetime</td><td>1</td></tr><tr><td>modified_time</td><td>datetime</td><td>1</td></tr></tbody></table><blockquote><p>说明：</p></blockquote><blockquote><ul><li>（1）    学习状态：0表示未学习，1表示正在学习，2表示已学习；</li></ul></blockquote><blockquote><ul><li>（2）    states（主题状态列表）形式：学习状态1，学习状态2，学习状态3，……</li></ul></blockquote><blockquote><pre><code>举例： 1， 0， 1， 2，……</code></pre></blockquote><hr><h5 id="2-主题状态接口"><a href="#2-主题状态接口" class="headerlink" title="2.  主题状态接口"></a>2.  <strong>主题状态接口</strong></h5><blockquote><ul><li>（1）    /topicState/getByDomainIdAndUserId</li></ul></blockquote><blockquote><p>查询主题状态，参数</p></blockquote><table><thead><tr><th>long domainId</th><th>long userId</th></tr></thead><tbody><tr><td>课程id</td><td>用户id</td></tr></tbody></table><blockquote><ul><li>（2）    /topicState/saveStateByDomainIdAndUserId</li></ul></blockquote><blockquote><p>保存主题状态，参数</p></blockquote><table><thead><tr><th>long domainId</th><th>String states</th><th>long userId</th></tr></thead><tbody><tr><td>课程id</td><td>主题状态列表</td><td>用户id</td></tr></tbody></table><blockquote><ul><li>（3）    /topicState/saveStateByDomainNameAndUserId</li></ul></blockquote><blockquote><p>保存主题状态，参数</p></blockquote><table><thead><tr><th>long domainName</th><th>String states</th><th>long userId</th></tr></thead><tbody><tr><td>课程名</td><td>主题状态列表</td><td>用户id</td></tr></tbody></table><hr><h3 id="分面状态"><a href="#分面状态" class="headerlink" title="分面状态"></a>分面状态</h3><h5 id="1-分面状态表"><a href="#1-分面状态表" class="headerlink" title="1. 分面状态表"></a>1. <strong>分面状态表</strong></h5><table><thead><tr><th>列名</th><th>类型</th><th>长度</th></tr></thead><tbody><tr><td>state_id</td><td>bigint(long)</td><td>20</td></tr><tr><td>domain_id</td><td>bigint(long)</td><td>20</td></tr><tr><td>topic_id</td><td>bigint(long)</td><td>20</td></tr><tr><td>states</td><td>varchar(string)</td><td>255</td></tr><tr><td>user_id</td><td>bigint(long)</td><td>20</td></tr><tr><td>created_time</td><td>datetime</td><td>1</td></tr><tr><td>modified_time</td><td>datetime</td><td>1</td></tr></tbody></table><blockquote><p>说明：</p></blockquote><blockquote><ul><li>（1）    学习状态：0表示未学习，1表示已在学习；</li></ul></blockquote><blockquote><ul><li>（2）    states（分面状态列表）形式：学习状态1，学习状态2，学习状态3，……</li></ul></blockquote><blockquote><pre><code>举例： 1， 0， 1， 0，……</code></pre></blockquote><h5 id="2-分面状态接口"><a href="#2-分面状态接口" class="headerlink" title="2.  分面状态接口"></a>2.  <strong>分面状态接口</strong></h5><blockquote><ul><li>（1）/facetState/getByDomainIdAndTopicIdAndUserId</li></ul></blockquote><blockquote><p>查询分面状态，参数</p></blockquote><table><thead><tr><th>long domainId</th><th>long userId</th><th>long topicId</th></tr></thead><tbody><tr><td>课程id</td><td>用户id</td><td>主题id</td></tr></tbody></table><blockquote><ul><li>（2）/facetState/saveStateByDomainIdAndTopicIdAndUserId</li></ul></blockquote><blockquote><p>保存分面状态，参数</p></blockquote><table><thead><tr><th>long domainId</th><th>long topicId</th><th>String states</th><th>long userId</th></tr></thead><tbody><tr><td>课程id</td><td>主题id</td><td>分面状态列表</td><td>用户id</td></tr></tbody></table><blockquote><ul><li>（3）/facetState/saveStateByDomainNameAndTopicNameAndUserId</li></ul></blockquote><blockquote><p>保存分面状态，参数</p></blockquote><table><thead><tr><th>string domainName</th><th>string topicName</th><th>String states</th><th>long userId</th></tr></thead><tbody><tr><td>课程名</td><td>主题名</td><td>分面状态列表</td><td>用户id</td></tr></tbody></table><blockquote><ul><li>（4）/facetState/saveStateByDomainIdAndUserId</li></ul></blockquote><blockquote><p>保存分面状态，参数</p></blockquote><table><thead><tr><th>long domainId</th><th>String states</th><th>long userId</th></tr></thead><tbody><tr><td>课程id</td><td>分面状态列表</td><td>用户id</td></tr></tbody></table><blockquote><ul><li>（5）/facetState/saveStateByDomainNameAndUserId</li></ul></blockquote><blockquote><p>保存主题状态，参数</p></blockquote><table><thead><tr><th>long domainName</th><th>String states</th><th>long userId</th></tr></thead><tbody><tr><td>课程名</td><td>分面状态列表</td><td>用户id</td></tr></tbody></table><p><strong><em>注</em></strong>：states：分面状态的矩阵（行（主题）之间以分号隔开，行内以逗号隔开）</p><h2 id="例如：0-0-1-0-0-0-1-1-1-0-1-0-1-1-1-……"><a href="#例如：0-0-1-0-0-0-1-1-1-0-1-0-1-1-1-……" class="headerlink" title="例如：0,0,1,0;0,0,1;1,1,0;1,0,1,1,1;……"></a>例如：0,0,1,0;0,0,1;1,1,0;1,0,1,1,1;……</h2><h3 id="推荐主题"><a href="#推荐主题" class="headerlink" title="推荐主题"></a>推荐主题</h3><h5 id="1-推荐主题表"><a href="#1-推荐主题表" class="headerlink" title="1. 推荐主题表"></a>1. <strong>推荐主题表</strong></h5><table><thead><tr><th>列名</th><th>类型</th><th>长度</th></tr></thead><tbody><tr><td>recommendation_id</td><td>bigint(long)</td><td>20</td></tr><tr><td>domain_id</td><td>bigint(long)</td><td>20</td></tr><tr><td>recommendation_topics</td><td>varchar(string)</td><td>255</td></tr><tr><td>user_id</td><td>bigint(long)</td><td>20</td></tr><tr><td>created_time</td><td>datetime</td><td>1</td></tr><tr><td>modified_time</td><td>datetime</td><td>1</td></tr></tbody></table><blockquote><p>说明：</p></blockquote><blockquote><ul><li>（1）recommendation_topics（推荐主题列表）形式：：推荐主题1 id，推荐主题2 id，推荐主题3 id；推荐主题3 id，推荐主题1 id，推荐主题4 id；……<br>即，不同推荐方式之间以分号隔开，同一推荐方式内的主题id以逗号分隔开</li></ul></blockquote><h5 id="2-2-推荐主题接口"><a href="#2-2-推荐主题接口" class="headerlink" title="2.  2.    推荐主题接口"></a>2.  <strong>2.    推荐主题接口</strong></h5><blockquote><ul><li>（1）    recommendation/getByDomainIdAndUserId</li></ul></blockquote><blockquote><p>查询推荐主题，参数</p></blockquote><table><thead><tr><th>long domainId</th><th>long userId </th></tr></thead><tbody><tr><td>课程id</td><td>用户id</td></tr></tbody></table><blockquote><ul><li>（2）    recommendation/saveRecommendationByDomainIdAndUserId</li></ul></blockquote><blockquote><p>保存推荐主题，参数</p></blockquote><table><thead><tr><th>long domainId</th><th>String recommendationTopics</th><th>long userId</th></tr></thead><tbody><tr><td>课程id</td><td>推荐主题列表</td><td>用户id</td></tr></tbody></table><blockquote><ul><li>（3）    recommendation/saveRecommendationByDomainNameAndUserId</li></ul></blockquote><blockquote><p>保存推荐主题，参数</p></blockquote><table><thead><tr><th>long domainName</th><th>String recommendationTopics</th><th>long userId</th></tr></thead><tbody><tr><td>课程名</td><td>推荐主题列表</td><td>用户id</td></tr></tbody></table><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;智慧教育-网络学院示范应用&quot;&gt;&lt;a href=&quot;#智慧教育-网络学院示范应用&quot; class=&quot;headerlink&quot; title=&quot;智慧教育-网络学院示范应用&quot;&gt;&lt;/a&gt;智慧教育-网络学院示范应用&lt;/h1&gt;&lt;h2 id=&quot;后端数据访问接口&quot;&gt;&lt;a href=&quot;#后
      
    
    </summary>
    
      <category term="工程" scheme="http://yoursite.com/categories/%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="智慧教育系统" scheme="http://yoursite.com/tags/%E6%99%BA%E6%85%A7%E6%95%99%E8%82%B2%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
