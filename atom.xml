<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yangkuan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-05T09:11:44.218Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yang Kuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>句子分块</title>
    <link href="http://yoursite.com/2019/04/19/%E5%8F%A5%E5%AD%90%E5%88%86%E5%9D%97/"/>
    <id>http://yoursite.com/2019/04/19/句子分块/</id>
    <published>2019-04-19T02:52:03.000Z</published>
    <updated>2019-05-05T09:11:44.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="句子分块"><a href="#句子分块" class="headerlink" title="句子分块"></a>句子分块</h2><p>分块也称为浅层分析，它基本上是识别句子部分和短语(如名词短语)。 词性标注告诉你单词是名词，动词，形容词等，但它并没有给你任何关于句子中句子或短语结构的线索。有时除了单词的词性，自然语言处理任务需要获取更多信息，这是就需要对句子进行解析，从中获得完整的解析树。<br><a id="more"></a><br><a href="https://github.com/nicolashernandez/PyRATA" target="_blank" rel="noopener">PyRATA</a></p><p><a href="https://www.programcreek.com/python/example/91255/nltk.RegexpParser" target="_blank" rel="noopener">Python nltk.RegexpParser() Examples</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def prepareForNLP(text):</span><br><span class="line">    sentences = nltk.sent_tokenize(text)</span><br><span class="line">    sentences = [nltk.word_tokenize(sent) for sent in sentences]</span><br><span class="line">    sentences = [nltk.pos_tag(sent) for sent in sentences]</span><br><span class="line">    return sentences</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def chunk(sentence):</span><br><span class="line">    chunkToExtract = &quot;&quot;&quot;</span><br><span class="line">NP: &#123;&lt;NNP&gt;*&#125;</span><br><span class="line">&#123;&lt;DT&gt;?&lt;JJ&gt;?&lt;NNS&gt;&#125;</span><br><span class="line">&#123;&lt;NN&gt;&lt;NN&gt;&#125;&quot;&quot;&quot;</span><br><span class="line">    grammar = r&quot;&quot;&quot;</span><br><span class="line">     NP: &#123;&lt;DT|JJ|NN.*&gt;+&#125;          # Chunk sequences of DT, JJ, NN</span><br><span class="line">     PP: &#123;&lt;IN&gt;&lt;NP&gt;&#125;               # Chunk prepositions followed by NP</span><br><span class="line">     VP: &#123;&lt;VB.*&gt;&lt;NP|PP|CLAUSE&gt;+&#125; # Chunk verbs and their arguments</span><br><span class="line">     CLAUSE: &#123;&lt;NP&gt;&lt;VP&gt;&#125;           # Chunk NP, VP</span><br><span class="line">     &#125;&lt;[\.VI].*&gt;+&#123;       # chink any verbs, prepositions or periods</span><br><span class="line">     &quot;&quot;&quot;</span><br><span class="line">    parser = nltk.RegexpParser(grammar)</span><br><span class="line">    result = parser.parse(sentence)</span><br><span class="line">    print &quot;result.label():&quot;, result.label()</span><br><span class="line">    for subtree in result.subtrees():</span><br><span class="line">        t = subtree</span><br><span class="line">        t = &apos; &apos;.join(word for word, pos in t.leaves())</span><br><span class="line">        print(t)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    example_sent = &quot;A man with a red helmet stands on a small moped on a dirt road .&quot;.lower()</span><br><span class="line">    sentences = prepareForNLP(example_sent)</span><br><span class="line">    for sentence in sentences:</span><br><span class="line">        chunk(sentence)</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a man with a red helmet stands on a small moped on a dirt road .</span><br><span class="line">a man</span><br><span class="line">with a red helmet</span><br><span class="line">a red helmet</span><br><span class="line">stands on a small moped on a dirt road</span><br><span class="line">on a small moped</span><br><span class="line">a small moped</span><br><span class="line">on a dirt road</span><br><span class="line">a dirt road</span><br></pre></td></tr></table></figure></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><h3 id="名词短语的分块："><a href="#名词短语的分块：" class="headerlink" title="名词短语的分块："></a>名词短语的分块：</h3><p><a href="https://aclweb.org/aclwiki/NP_Chunking_(State_of_the_art" target="_blank" rel="noopener">NP Chunking (State of the art)</a>)</p><h3 id="词性标记集"><a href="#词性标记集" class="headerlink" title="词性标记集"></a>词性标记集</h3><p><a href="https://www.ibm.com/support/knowledgecenter/zh/SS5RWK_3.5.0/com.ibm.discovery.es.ta.doc/iiysspostagset.htm" target="_blank" rel="noopener">英语标记集</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;句子分块&quot;&gt;&lt;a href=&quot;#句子分块&quot; class=&quot;headerlink&quot; title=&quot;句子分块&quot;&gt;&lt;/a&gt;句子分块&lt;/h2&gt;&lt;p&gt;分块也称为浅层分析，它基本上是识别句子部分和短语(如名词短语)。 词性标注告诉你单词是名词，动词，形容词等，但它并没有给你任何关于句子中句子或短语结构的线索。有时除了单词的词性，自然语言处理任务需要获取更多信息，这是就需要对句子进行解析，从中获得完整的解析树。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="自然语言处理" scheme="http://yoursite.com/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
      <category term="chunk" scheme="http://yoursite.com/tags/chunk/"/>
    
      <category term="NLTK" scheme="http://yoursite.com/tags/NLTK/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴实习生面试</title>
    <link href="http://yoursite.com/2019/04/17/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/04/17/阿里巴巴实习生面试/</id>
    <published>2019-04-17T14:50:46.000Z</published>
    <updated>2019-04-17T15:10:07.275Z</updated>
    
    <content type="html"><![CDATA[<p>阿里巴巴暑期实习，官网内推投的成都蚂蚁金服，经过漫长等待和催促终于等来了面试。<br><a id="more"></a> </p><h2 id="一面（48min）"><a href="#一面（48min）" class="headerlink" title="一面（48min）"></a>一面（48min）</h2><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><h3 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h3><ul><li>一个之前没注意的问题：synchronized关键字可以修饰类吗？</li></ul><h3 id="Spring-bean的生命周期和作用域"><a href="#Spring-bean的生命周期和作用域" class="headerlink" title="Spring bean的生命周期和作用域"></a>Spring bean的生命周期和作用域</h3><h3 id="IOC有什么用"><a href="#IOC有什么用" class="headerlink" title="IOC有什么用"></a>IOC有什么用</h3><p>解耦</p><h3 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h3><ul><li>索引</li><li>索引的优缺点</li><li>锁</li></ul><h3 id="蚂蚁金服干啥了解吗"><a href="#蚂蚁金服干啥了解吗" class="headerlink" title="蚂蚁金服干啥了解吗"></a>蚂蚁金服干啥了解吗</h3><p>安全</p><h3 id="蚂蚁金服的对手有哪些"><a href="#蚂蚁金服的对手有哪些" class="headerlink" title="蚂蚁金服的对手有哪些"></a>蚂蚁金服的对手有哪些</h3><p>微信支付、京东金融</p><h3 id="蚂蚁金服和对手的优势和劣势"><a href="#蚂蚁金服和对手的优势和劣势" class="headerlink" title="蚂蚁金服和对手的优势和劣势"></a>蚂蚁金服和对手的优势和劣势</h3><h3 id="幂等律"><a href="#幂等律" class="headerlink" title="幂等律"></a>幂等律</h3><p>一个请求与多个请求等效</p><h3 id="一个用户的同一请求（比如充值操作）由于网络问题等多次发送给服务端，怎么实现幂等？"><a href="#一个用户的同一请求（比如充值操作）由于网络问题等多次发送给服务端，怎么实现幂等？" class="headerlink" title="一个用户的同一请求（比如充值操作）由于网络问题等多次发送给服务端，怎么实现幂等？"></a>一个用户的同一请求（比如充值操作）由于网络问题等多次发送给服务端，怎么实现幂等？</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阿里巴巴暑期实习，官网内推投的成都蚂蚁金服，经过漫长等待和催促终于等来了面试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="实习" scheme="http://yoursite.com/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="阿里巴巴" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"/>
    
      <category term="蚂蚁金服" scheme="http://yoursite.com/tags/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>Stacked Cross Attention for Image-Text Matching</title>
    <link href="http://yoursite.com/2019/04/15/Stacked-Cross-Attention-for-Image-Text-Matching/"/>
    <id>http://yoursite.com/2019/04/15/Stacked-Cross-Attention-for-Image-Text-Matching/</id>
    <published>2019-04-15T02:30:23.000Z</published>
    <updated>2019-04-15T09:37:19.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这篇文章做了什么？"><a href="#这篇文章做了什么？" class="headerlink" title="这篇文章做了什么？"></a>这篇文章做了什么？</h2><p>通过对图像中的对象或者突出内容与句子中的单词进行潜在语义对齐，使得图文匹配过程能够捕获到视觉与语言之间细粒度的相互关系，使得图文匹配更具有可解释性。目的是将单词和图像区域映射到同一嵌入空间（<code>common embedding space</code>）从而推断整个图像与句子之间的相似度。<br><a id="more"></a> </p><h2 id="相比于已有的方法有什么优点？"><a href="#相比于已有的方法有什么优点？" class="headerlink" title="相比于已有的方法有什么优点？"></a>相比于已有的方法有什么优点？</h2><p>已有方法：</p><ol><li>简单聚合所有可能的区域以及单词对之间的相似度，却没有关注区分单词和区域之间的重要性；</li><li>使用多步骤的注意力过程来捕获数量有限且缺乏一定解释性的语义对齐。</li></ol><p>这篇文章使用提出的<code>Stacked Cross Attention</code>去发现在图像区域和单词之间的所有潜在对齐，从而计算图文相似度。已有方法通过执行固定步骤的注意力推理，从而在一个时刻只能发现有限的语义对齐，而<code>Stacked Cross Attention</code>可以同时发现所有可能的语义对齐。由于语义对齐的数量随着不同的图像和句子而变化，因此<code>Stacked Cross Attention</code>方法推断出的对应关系更加全面，从而使图像文本匹配更具可解释性。</p><h2 id="这篇文章是怎么做的？"><a href="#这篇文章是怎么做的？" class="headerlink" title="这篇文章是怎么做的？"></a>这篇文章是怎么做的？</h2><ol><li>利用自底向上的注意力机制检测图像区域，并提取图像区域的特征；</li><li>将句子中的单词及其句子上下文映射为特征向量；</li><li>应用<code>Stacked Cross Attention</code>通过对齐图像区域和单词特征来推断图文相似度。</li><li>这篇文章的损失函数关注每一个<code>Batch</code>中最负面的图文对（也就是最不匹配的图文对）。所以对于给定的正样例对$(I,T)$，那么最负样例对定义为$\hat{I}<em>h=argmax</em>{m\neq{I}}S(m,T)$以及$\hat{T}<em>h=argmax</em>{d\neq{T}}S(I,d)$。所以这篇文章定义损失函数如下：  </li></ol><p>$$<br>l_{hard}(I,T)=[\alpha-S(I,T)+S(I,\hat{T}<em>h)]</em>++[\alpha-S(I,T)+S(\hat{I}<em>h,T)]</em>+<br>$$</p><h2 id="怎么文章题目中的Stacked-Cross-Attention？"><a href="#怎么文章题目中的Stacked-Cross-Attention？" class="headerlink" title="怎么文章题目中的Stacked Cross Attention？"></a>怎么文章题目中的<code>Stacked Cross Attention</code>？</h2><p><code>Stacked Cross Attention</code>通过两个阶段来关注图像和文本的上下文信息。第一个阶段，给定一个图像和一个句子，关注每个图像区域对应的句子中的单词，并将每个图像区域与来自句子的受关注信息进行比较，以确定图像区域的重要性（比如图像区域在句子中是否被提到）。第二阶段，与第一阶段相似的，根据每个单词对应的图像区域来决定每个单词的重要性（也就是对每个单词的关注度）。</p><h2 id="文章的实验结果展示"><a href="#文章的实验结果展示" class="headerlink" title="文章的实验结果展示"></a>文章的实验结果展示</h2><p>这篇文章在Flickr30K以及MS-COCO数据集上进行实验，结果如下：</p><p><img src="/2019/04/15/Stacked-Cross-Attention-for-Image-Text-Matching/Stacked-Cross-Attention1.png" alt="image"></p><p><img src="/2019/04/15/Stacked-Cross-Attention-for-Image-Text-Matching/Stacked-Cross-Attention2.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;这篇文章做了什么？&quot;&gt;&lt;a href=&quot;#这篇文章做了什么？&quot; class=&quot;headerlink&quot; title=&quot;这篇文章做了什么？&quot;&gt;&lt;/a&gt;这篇文章做了什么？&lt;/h2&gt;&lt;p&gt;通过对图像中的对象或者突出内容与句子中的单词进行潜在语义对齐，使得图文匹配过程能够捕获到视觉与语言之间细粒度的相互关系，使得图文匹配更具有可解释性。目的是将单词和图像区域映射到同一嵌入空间（&lt;code&gt;common embedding space&lt;/code&gt;）从而推断整个图像与句子之间的相似度。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="论文阅读" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="神经网络" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="图像识别" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
      <category term="图文匹配" scheme="http://yoursite.com/tags/%E5%9B%BE%E6%96%87%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>MyIsam存储引擎</title>
    <link href="http://yoursite.com/2019/04/10/MyIsam%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/2019/04/10/MyIsam存储引擎/</id>
    <published>2019-04-10T02:18:51.000Z</published>
    <updated>2019-04-10T02:46:46.092Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Spring Boot的@Transactional注解对MyISAM存储引擎生效的问题？</li></ol><p>未解决问题，一脸懵逼。。。。</p><a id="more"></a> <p>其中，数据表对应的实体对象如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import javax.persistence.Entity;</span><br><span class="line">import javax.persistence.GeneratedValue;</span><br><span class="line">import javax.persistence.GenerationType;</span><br><span class="line">import javax.persistence.Id;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    @Id</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String name, String password) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用Spring Data Jpa进行数据操作，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line">import org.springframework.data.jpa.repository.Modifying;</span><br><span class="line">import org.springframework.data.jpa.repository.Query;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">@Repository(&quot;user_repository&quot;)</span><br><span class="line">public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Integer deleteUserById(Long id);</span><br><span class="line"></span><br><span class="line">    @Modifying(clearAutomatically = true)</span><br><span class="line">    @Query(value = &quot;update User set name=?2,password=?3 where id=?1&quot;)</span><br><span class="line">    Integer updateUserById(Long id,String name,String password);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>业务逻辑层代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">@Service(&quot;uService&quot;)</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserRepository userRepository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = Exception.class)</span><br><span class="line">    public Integer deleteUserById(Long id)&#123;</span><br><span class="line">        Integer i = userRepository.deleteUserById(id);</span><br><span class="line">        if(id.equals(718L))&#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;删除714错误，回滚&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = &#123;IllegalArgumentException.class&#125;)</span><br><span class="line">    public User saveUser(User user)&#123;</span><br><span class="line">        User u = userRepository.save(user);</span><br><span class="line"></span><br><span class="line">        if(u.getName()==&quot;yang1&quot;)&#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;存入yang，导致回滚&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = &#123;IllegalArgumentException.class&#125;)</span><br><span class="line">    public Integer updateUserById(User user)&#123;</span><br><span class="line">        Integer i = userRepository.updateUserById(user.getId(),user.getName(),user.getPassword());</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后是测试代码，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    private final Logger LOGGER = LoggerFactory.getLogger(this.getClass());</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void deleteUserById() &#123;</span><br><span class="line">        Integer i = userService.deleteUserById(718L);</span><br><span class="line">        LOGGER.error(&quot;delete by user id successful: &quot;+ i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void saveUser()&#123;</span><br><span class="line">        User user = new User(&quot;yang&quot;,&quot;adasdsa&quot;);</span><br><span class="line">        User u = userService.saveUser(user);</span><br><span class="line">        LOGGER.error(u.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void updateUser()&#123;</span><br><span class="line">        User user = new User(&quot;yang&quot;,&quot;adasdsa&quot;);</span><br><span class="line">        user.setId(714L);</span><br><span class="line">        int i = userService.updateUserById(user);</span><br><span class="line">        LOGGER.error(&quot;update by user id successful: &quot;+ i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在测试删除用户（deleteUserById）以及保存用户（saveUser）时，发现抛出异常会导致回滚，但是我的数据库引擎是MyIsam，讲道理不应该支持事务。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Spring Boot的@Transactional注解对MyISAM存储引擎生效的问题？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;未解决问题，一脸懵逼。。。。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MyIsam" scheme="http://yoursite.com/tags/MyIsam/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://yoursite.com/2019/04/08/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/08/代理模式/</id>
    <published>2019-04-08T08:01:31.000Z</published>
    <updated>2019-04-08T10:55:16.262Z</updated>
    
    <content type="html"><![CDATA[<p>代理是一种设计模式，提供了对目标对象的间接访问方式，即通过代理访问目标对象。代理模式的作用：控制和管理访问。<br><a id="more"></a> </p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在程序运行前就已经存在对应的代理类，那么这种代理方式就称之为静态代理。由于这种代理方式下的代理类往往是程序员自己在Java代码中定义的，当我们需求发生变化的时候，代理类以及目标类都需要进行修改维护，不够灵活。但是静态代理也有优点，就是在不对目标对象进行修改的前提下就可以对目标对象进行功能扩展和拦截。<br>下面举个简单的例子，在CS（客户端\服务器）主从结构的网络架构中，一般服务器会对客户端发送而来的请求进行过滤和记录，这个时候就可以使用代理类来实现上述功能。</p><ol><li><p>首先，我们定义服务端顶层接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 顶层接口，目标类和代理类都需要实现顶层接口</span><br><span class="line">  */</span><br><span class="line">interface ServerInterface&#123;</span><br><span class="line">    public void processRequest(String request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其次，定义服务类：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 目标类</span><br><span class="line">  */</span><br><span class="line">class Server implements ServerInterface&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void processRequest(String request) &#123;</span><br><span class="line">        System.out.println(&quot;process request&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>最后定义服务代理类，服务类和代理类都实现服务顶层接口：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 代理类</span><br><span class="line"> */</span><br><span class="line">class ServerProxy implements ServerInterface&#123;</span><br><span class="line">    ServerInterface serverInterface;</span><br><span class="line"></span><br><span class="line">    public ServerProxy(ServerInterface serverInterface) &#123;</span><br><span class="line">        this.serverInterface = serverInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * 过滤来自客户端的不合理请求</span><br><span class="line">        * @param request</span><br><span class="line">        * @return</span><br><span class="line">        */</span><br><span class="line">    public boolean filter(String request)&#123;</span><br><span class="line">        System.out.println(&quot;filter request&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * 记录来自客户端的请求</span><br><span class="line">        */</span><br><span class="line">    public void logBefore()&#123;</span><br><span class="line">        System.out.println(&quot;log before&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * 记录返回给客户端的结果</span><br><span class="line">        */</span><br><span class="line">    public void logReturn()&#123;</span><br><span class="line">        System.out.println(&quot;log return&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void processRequest(String request) &#123;</span><br><span class="line">        logBefore();</span><br><span class="line">        if(!filter(request))&#123;</span><br><span class="line">            serverInterface.processRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">        logReturn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从上面可以看出，当我们的需求改变的时候，比如说我们不仅需要过滤请求、日志记录，还需要进行客户端登录时，那么就需要在代理类中添加登录服务器的方法<code>logIn()</code>，并且给<code>processRequest</code>方法中添加登录方法，而实际情况中服务器中处理请求的方法<code>processRequest</code>成千上万，这个时候程序员就需要给一个个<code>processRequest</code>方法添加<code>logIn</code>操作，可以看到修改和维护代码代价过大，代码也不够简洁。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="JDK原生动态代理"><a href="#JDK原生动态代理" class="headerlink" title="JDK原生动态代理"></a>JDK原生动态代理</h3><p>动态代理中，代理类是在运行时通过Java中的反射机制动态生成的。有兴趣的可以去看看Java中<code>ProxyClassFactory</code>类以及<code>ProxyGenerator</code>类动态生成代理类的源码。</p><p>对于应用程序员而言，主要使用<code>InvocationHandler</code>类以及<code>Proxy.newProxyInstance()</code>实现动态代理。我们还是以上述客户端/服务器网络架构为例。</p><p>顶层的服务接口<code>ServerInterface</code>不变，目标类<code>Server</code>也不用改变，只用实现<code>InvocationHandler</code>接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 日志记录类</span><br><span class="line"> */</span><br><span class="line">class Logger &#123;</span><br><span class="line">    /**</span><br><span class="line">        * 记录来自客户端的请求</span><br><span class="line">        */</span><br><span class="line">    public void logBefore() &#123;</span><br><span class="line">        System.out.println(&quot;log before&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * 记录返回给客户端的结果</span><br><span class="line">        */</span><br><span class="line">    public void logReturn() &#123;</span><br><span class="line">        System.out.println(&quot;log return&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 动态代理</span><br><span class="line"> */</span><br><span class="line">class ServerDynamicProxy implements InvocationHandler &#123;</span><br><span class="line">    Object target;</span><br><span class="line">    Object prozy;</span><br><span class="line"></span><br><span class="line">    public ServerDynamicProxy(Object target, Object prozy) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">        this.prozy = prozy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 动态绑定，返回代理对象</span><br><span class="line">    *</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">    public Object bind() &#123;</span><br><span class="line">        return Proxy.newProxyInstance(target.getClass().getClassLoader()</span><br><span class="line">                , target.getClass().getInterfaces(), this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Class prozyClass = proxy.getClass();</span><br><span class="line">        Method beforeMethod = prozyClass.getMethod(&quot;logBefore&quot;);</span><br><span class="line">        Method returnMethod = prozyClass.getMethod(&quot;logReturn&quot;);</span><br><span class="line"></span><br><span class="line">        beforeMethod.invoke(prozy);</span><br><span class="line">        method.invoke(this.target, args);</span><br><span class="line">        returnMethod.invoke(prozy);</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就是动态代理的使用，当测试的时候只需要在主函数中调用<code>bind()</code>方法返回代理类就可以了，当然需要进行强制类型转换，从<code>Object</code>转换成目标类。<br>如果想看见动态代理生成的代理类，可以使用<code>System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;);</code></p><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理，所以当目标类没有实现接口时，就无法使用JDK代理，只能使用CGLIB实现动态代理。<br>示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 目标类</span><br><span class="line"> */</span><br><span class="line">public class Server &#123;</span><br><span class="line"></span><br><span class="line">    public void processRequest(String request) &#123;</span><br><span class="line">        System.out.println(&quot;process request&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 代理类</span><br><span class="line"> */</span><br><span class="line">public class ServerMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    private Object target;//业务类对象，供代理方法中进行真正的业务方法调用</span><br><span class="line"></span><br><span class="line">    public ServerMethodInterceptor(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //相当于JDK动态代理中的绑定</span><br><span class="line">    public Object getInstance() &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer(); //创建加强器，用来创建动态代理类</span><br><span class="line">        enhancer.setSuperclass(this.target.getClass());  //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）</span><br><span class="line">        //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line">        // 创建动态代理类对象并返回</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        // log before</span><br><span class="line">        System.out.println(&quot;log before&quot;);</span><br><span class="line">        Object result = methodProxy.invokeSuper(o,objects);</span><br><span class="line">        // log return</span><br><span class="line">        System.out.println(&quot;log return&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理是一种设计模式，提供了对目标对象的间接访问方式，即通过代理访问目标对象。代理模式的作用：控制和管理访问。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="动态代理" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
      <category term="静态代理" scheme="http://yoursite.com/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动实习生面试</title>
    <link href="http://yoursite.com/2019/03/30/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/03/30/字节跳动实习生面试/</id>
    <published>2019-03-30T13:20:08.000Z</published>
    <updated>2019-03-30T13:33:43.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ol><li>垃圾回收讲一下；</li><li>java内存模型；<blockquote><ul><li>垃圾回收算法（如何确定回收对象（引用计数法、可达性算法）、回收算法（标记回收、标记整理、复制））；</li><li>垃圾收集器；</li><li>MySQL数据库讲一下；数据引擎、索引类型、索引方法（B+树、Hash）<a id="more"></a> </li></ul></blockquote></li><li>手写代码：根据前序遍历和中序遍历还原二叉树，根据获得的前序遍历和中序遍历结果输出一颗二叉树（输出后续遍历）（我问可以IDE吗？尽量别用）<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2></li><li><p>手写代码： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单链表操作：   </span><br><span class="line"> 输入：奇数位升序，偶数位降序  </span><br><span class="line"> 1 -&gt; 80 -&gt; 4 -&gt; 60 -&gt; 6 -&gt; 40 -&gt; 7 -&gt; 2    </span><br><span class="line">输出：升序单链表  </span><br><span class="line"> 1 -&gt; 2 -&gt; 4 -&gt; 6-&gt; 7 -&gt; 40 -&gt; 60 -&gt; 80  </span><br><span class="line">不允许使用其他数据结构。</span><br></pre></td></tr></table></figure></li><li><p>进程和线程的区别</p></li><li>HashMap</li><li>TCP/UDP<h2 id="三面-两道编程题："><a href="#三面-两道编程题：" class="headerlink" title="三面-两道编程题："></a>三面-两道编程题：</h2><ol><li>假定一张表的数据格式为 id,name,parentId，表的数据不大，1000条以内，得到这些数据的树型结构    输入：List<user> ， 输出：Node（手写代码）</user></li></ol></li><li>有2个文件，分别是A(3t大小)，B(2t)大小，A文件的组织形式为 uid, username,B文件的组织形式为 uid, age,找出A、B文件交集的数据放入一个文件，文件的数据格式为uid,username,age（讲讲思路）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;垃圾回收讲一下；&lt;/li&gt;
&lt;li&gt;java内存模型；&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;垃圾回收算法（如何确定回收对象（引用计数法、可达性算法）、回收算法（标记回收、标记整理、复制））；&lt;/li&gt;
&lt;li&gt;垃圾收集器；&lt;/li&gt;
&lt;li&gt;MySQL数据库讲一下；数据引擎、索引类型、索引方法（B+树、Hash）&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="工作" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="实习" scheme="http://yoursite.com/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="字节跳动" scheme="http://yoursite.com/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Deep Residual Learning for Image Recognition</title>
    <link href="http://yoursite.com/2019/03/06/Deep-Residual-Learning-for-Image-Recognition/"/>
    <id>http://yoursite.com/2019/03/06/Deep-Residual-Learning-for-Image-Recognition/</id>
    <published>2019-03-06T12:49:41.000Z</published>
    <updated>2019-03-07T03:12:31.558Z</updated>
    
    <content type="html"><![CDATA[<p>神经网络越深就越难训练，作者提出一种残差学习框架来降低网络训练的难度。<br><a id="more"></a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;神经网络越深就越难训练，作者提出一种残差学习框架来降低网络训练的难度。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="论文阅读" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="神经网络" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="图像识别" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
      <category term="残差网络" scheme="http://yoursite.com/tags/%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper-分布式应用程序协调服务</title>
    <link href="http://yoursite.com/2019/03/06/ZooKeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/03/06/ZooKeeper-分布式应用程序协调服务/</id>
    <published>2019-03-06T06:51:32.000Z</published>
    <updated>2019-03-06T08:26:16.895Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://developer.51cto.com/art/201809/583184.htm" target="_blank" rel="noopener">参考链接</a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Apache ZooKeeper is an effort to develop and maintain an open-source server which enables highly reliable distributed coordination.</p><p>Apache ZooKeeper致力于开发和维护一个支持高度可靠的分布式协调的开源服务器。<br><a id="more"></a><br>Zookeeper是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于Zookeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。  </p><h2 id="Znode"><a href="#Znode" class="headerlink" title="Znode"></a>Znode</h2><p>在ZooKeeper中，“节点”分为两种类型：</p><ul><li>第一类是指构成集群的机器，称之为机器节点；</li><li>第二类则是指数据模型中的数据单元，我们称之为数据节点-Znode。</li></ul><p>ZooKeeper将所有的数据存储在内存中，数据模型是一棵树（Znode Tree）</p><h2 id="ZooKeeper集群介绍介绍"><a href="#ZooKeeper集群介绍介绍" class="headerlink" title="ZooKeeper集群介绍介绍"></a>ZooKeeper集群介绍介绍</h2><p>ZooKeeper集群中的所有机器通过Leader选举过程来选定一台称为“Leader”的机器，Leader既可以为客户端提供写服务又能提供读服务。出Leader外，Follower和Observer只能提供读服务。</p><p>Follower与Observer的唯一区别在于Observer机器不参与Leader的选举过程，也不参与写操作的“过半写成功”策略，因此Observer机器可以在不影响写性能的情况下提升集群的读性能。</p><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>ZAB（ZooKeeper Atomic Broadcast，ZooKeeper原子广播）协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的原子广播协议。</p><p>在ZooKeeper中，主要依赖ZAB协议来实现分布式数据一致性，基于该协议ZooKeeper实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p><p>ZAB协议包括两种基本模式，分别是崩溃恢复和消息广播。<br>当整个服务框架在启动过程中，或是当Leader服务器出现网络中断、崩溃退出与重启等异常情况是，ZAB协议就会进入恢复模式并选举出新的Leader服务器。<br>当选举产生的新的Leader服务器，同时集群中已经有过半的机器与新Leader服务器完成状态同步之后，ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，也就是保证集群中过半的机器与该Leader服务器的数据状态一致。<br>当集群中已经有过半的Follower服务器完成与Leader服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。<br>当一台同样遵守ZAB协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个Leader服务器在负责消息广播，那么新加入的服务器就会自觉地进去数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p><p>正如上文所述，ZooKeeper被设计成只允许唯一的Leader服务器进行事务请求的处理，Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议。如果集群中的其他机器接收到客户端事务请求，那么这些非Leader服务器会首先将这个事务转发给Leader服务器。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在我们的智慧教育示范应用中，主要是使用Kafka收集用户日志，而ZooKeeper就担任了服务生产者和消费者的注册中心。<br>服务生产者将自己提供的服务注册到ZooKeeper中心，服务消费者在进行服务调用的时候先到ZooKeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容和数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://developer.51cto.com/art/201809/583184.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;Apache ZooKeeper is an effort to develop and maintain an open-source server which enables highly reliable distributed coordination.&lt;/p&gt;
&lt;p&gt;Apache ZooKeeper致力于开发和维护一个支持高度可靠的分布式协调的开源服务器。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/categories/ZooKeeper/"/>
    
    
      <category term="开源软件" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="ZooKeeper" scheme="http://yoursite.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>条件生成对抗网络的一系列问题</title>
    <link href="http://yoursite.com/2019/03/05/%E6%9D%A1%E4%BB%B6%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/05/条件生成对抗网络的一系列问题/</id>
    <published>2019-03-05T13:30:04.000Z</published>
    <updated>2019-03-06T05:18:26.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条件生成对抗网络中生成器的输入随机噪声z，文本特征-phi-t-作为条件，噪声输入有什么用？"><a href="#条件生成对抗网络中生成器的输入随机噪声z，文本特征-phi-t-作为条件，噪声输入有什么用？" class="headerlink" title="条件生成对抗网络中生成器的输入随机噪声z，文本特征$\phi(t)$作为条件，噪声输入有什么用？"></a>条件生成对抗网络中生成器的输入随机噪声<code>z</code>，文本特征$\phi(t)$作为条件，噪声输入有什么用？</h2><p><a href="https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/issues/152" target="_blank" rel="noopener">参考链接：https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/issues/152</a></p><p>其实没有噪声输入也可以，但是有时候需要同一个文本输入需要生成的样本更加多样，这时候随机噪声就有用了。<br><a id="more"></a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;条件生成对抗网络中生成器的输入随机噪声z，文本特征-phi-t-作为条件，噪声输入有什么用？&quot;&gt;&lt;a href=&quot;#条件生成对抗网络中生成器的输入随机噪声z，文本特征-phi-t-作为条件，噪声输入有什么用？&quot; class=&quot;headerlink&quot; title=&quot;条件生成对抗网络中生成器的输入随机噪声z，文本特征$\phi(t)$作为条件，噪声输入有什么用？&quot;&gt;&lt;/a&gt;条件生成对抗网络中生成器的输入随机噪声&lt;code&gt;z&lt;/code&gt;，文本特征$\phi(t)$作为条件，噪声输入有什么用？&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/issues/152&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接：https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix/issues/152&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实没有噪声输入也可以，但是有时候需要同一个文本输入需要生成的样本更加多样，这时候随机噪声就有用了。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="论文阅读" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="生成对抗网络" scheme="http://yoursite.com/tags/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/"/>
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数据库范式</title>
    <link href="http://yoursite.com/2019/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/04/数据库范式/</id>
    <published>2019-03-04T13:36:33.000Z</published>
    <updated>2019-04-10T02:19:30.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h2><p>关系模型中实体的每个属性都是原子属性，即元组在每个属性上的取值是不可分的。也就是说这些属性的取值是单一的，不是集合、数组等非原子数据。当实体中的某个属性都多个值时，必须将该属性拆分为多个原子属性。</p><a id="more"></a> <h2 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h2><p><strong>关系模型中的所有非主属性都完全依赖于所有的候选键</strong>。2NF其实就是在1NF的基础上消除那些非主属性对所有候选键的部分函数依赖。<br>例如，关系（学号，课程号，教师，成绩，学院）中，教师部分依赖于课程号，因此这个关系不满足第二范式，所以需要把上述关系拆分成（学号，课程号，成绩）和（课程号，教师，学院）。</p><h2 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h2><p><strong>关系模型中的非主属性既不部分函数依赖也不传递函数依赖于关系中的所有候选键</strong>。也就是说3NF是在2NF的基础上消除了非主属性对候选键的传递依赖关系。</p><p>还是上面的例子，关系（课程号，教师，学院）中存在传递依赖关系课程号-&gt;教师，以及教师-&gt;学院，因此不满足3NF。所以将其分解为（课程号，教师）和（教师，学院）。</p><h2 id="巴斯-科德范式（BCNF）"><a href="#巴斯-科德范式（BCNF）" class="headerlink" title="巴斯-科德范式（BCNF）"></a>巴斯-科德范式（BCNF）</h2><p><strong>对于关系R上的任何非平凡函数依赖X-&gt;Y都有X必包含R的某个候选键</strong>，那么就称关系R满足BCNF。BCNF是在第三范式的基础上继续消除主属性对于键的部分依赖和传递依赖。  </p><p>举个例子来说，关系（课程名，班级，教师）中假定多名教师承担多个班级的教学任务，每个教师仅承担一个课程的教学任务，同时可以给多个班级上课，那么可以知道有函数依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(课程名，班级)-&gt;(教师)</span><br><span class="line">(教师)-&gt;(课程名)</span><br></pre></td></tr></table></figure><p>然而，上述关系中的主键是(课程名，班级)或者(教师，班级)。所以<code>(教师)-&gt;(课程名)</code>就是主属性对候选键的部分依赖，不满足BCNF。</p><h2 id="第四范式（4NF）"><a href="#第四范式（4NF）" class="headerlink" title="第四范式（4NF）"></a>第四范式（4NF）</h2><p>对于关系R中的非平凡多值依赖X-&gt;-&gt;Y，X必包含R的某个候选键，则称满足4NF。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一范式（1NF）&quot;&gt;&lt;a href=&quot;#第一范式（1NF）&quot; class=&quot;headerlink&quot; title=&quot;第一范式（1NF）&quot;&gt;&lt;/a&gt;第一范式（1NF）&lt;/h2&gt;&lt;p&gt;关系模型中实体的每个属性都是原子属性，即元组在每个属性上的取值是不可分的。也就是说这些属性的取值是单一的，不是集合、数组等非原子数据。当实体中的某个属性都多个值时，必须将该属性拆分为多个原子属性。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="范式" scheme="http://yoursite.com/tags/%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器</title>
    <link href="http://yoursite.com/2019/02/28/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2019/02/28/垃圾收集器/</id>
    <published>2019-02-28T02:28:49.000Z</published>
    <updated>2019-02-28T10:54:47.229Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾收集算法是内存回收的方法论，垃圾收集器是垃圾回收的具体实现。在JDK1.7 Update 14之后的HotSpot虚拟机所包含的收集器如下图所示：</p><p><img src="/2019/02/28/垃圾收集器/垃圾收集器1.jpg" alt="垃圾收集器"></p><a id="more"></a> <h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>Serial收集器是最基本、发展历史最悠久的收集器。这是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Serial收集器运行示意图如下：</p><p><img src="/2019/02/28/垃圾收集器/垃圾收集器2.jpg" alt="垃圾收集器"></p><p>也就是说，虚拟机在使用Serial垃圾收集器时会在用户不可见的情况下把所有用户正常工作的线程暂停，这种“Stop The World”操作在很多程序中是难以接受的，带给用户不良体验。<br>举个例子“你妈妈在打扫房间的时候，肯定也会让你老老实实待在椅子上或者房间外待着，如果她一边打扫，你一边丢垃圾，这房间还能打扫完？你妈妈不会崩溃？”，因此看起来“Stop The World”操作情有可原。<br>但是，从JDK1.3开始，HotSpot虚拟机开发团队一直在努力消除或减少工作线程因内存回收而导致的停顿，从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）乃至GC收集器最前沿的成果Garbage First（G1）收集器，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除垃圾回收带来的停顿。<br>Serial收集器虽然很老，可以说很陈旧，但是目前为止它依旧是虚拟机运行在Client模式下的默认新生代收集器。那是因为Serial收集器简单而高效，对于限定单个GPU的情况而言，Serial收集器由于没有线程交互的开销，专心进行垃圾收集自然可以获得最高的单线程收集效率。  </p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew收集器就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为包括Serial收集器的所有可用控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样。ParNew收集器进行垃圾收集的示意图如下：  </p><p><img src="/2019/02/28/垃圾收集器/垃圾收集器3.jpg" alt="垃圾收集器"></p><p>ParNew收集器除了多线程收集外，其他与Serial收集器相比没有太多创新之处，但它却是虚拟机运行在Server模式下的首选新生代收集器，其中一个与性能无关的重要原因是除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器也是新生代收集器，并且使用复制算法收集内存，同时还是并行的多线程收集器。这些特点都和ParNew收集器一样，但是Parallel Scavenge收集器的目标在于达到一个可控制的<strong>吞吐量</strong>（Throughput），所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码/(运行用户代码+垃圾收集时间)。这与CMS等收集器的目标不同，它们目标是尽可能地缩短垃圾收集时间用户线程的停顿时间。<br>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多的交互任务。<br>Parallel Scavenge收集器提供两个参数用于精准控制吞吐量，分别是控制最大垃圾收集时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。<br><strong>MaxGCPauseMillis</strong>参数允许的值是一个大于0的毫秒数，收集器将尽可能在规定时间内完成垃圾收集操作。但是不要认为这个参数越小，系统的垃圾收集速度就会越快，GC停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一点，收集300M新生代肯定比收集500M新生代快，这也将导致垃圾收集更频繁，原来每20s收集一次、一次100ms，现在每10s收集一次、一次70ms。停顿时间的确下降了，但吞吐量也降下来了。<br><strong>GCTimeRatio</strong>参数的值应当是一个大于0小于100的整数，如果把这个参数设置为19，那么允许最大GC时间就占总时间的5%（即1/(1+19)）。<br>Parallel Scavenge收集器还有一个参数-XX:+UseAdaptiveSizePolicy，这个参数打开之后就不需要手动指定新生代的大小（-Xmm）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最适合的停顿时间或者最大吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。  </p><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法，这个收集器的主要意义也是在于给Client模式下的虚拟机使用。<br>在Server模式下，它有两大用途：  </p><ul><li>在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用；</li><li>作为CMS收集器的后备方案，在并发收集发生Concurrent Mode Failure时使用。  </li></ul><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。在JDK1.6之前Parallel Scavenge只能与Serial Old收集器配合使用，由于老年代使用单线程收集内存无法充分利用服务器多CPU的处理能力，这个组合就导致无法达到高吞吐量。在JDK1.6开始提供了Parallel Old收集器和Parallel Scavenge收集器配合使用，从而可以应用在注重吞吐量以及CPU资源敏感的场合。</p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。从名字（包含“Mark Sweep”）就可以看出来，CMS收集器是基于“标记——清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p><ul><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ul><p>其中，初始标记、重新标记这；两个步骤仍需要“Stop The World”。初始标记是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段是为了修正并发标记阶段因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这一阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记阶段的时间短。整个过程中耗时最长的并发标记和并发清除阶段都是与用户线程一起工作，如下图所示：</p><p><img src="/2019/02/28/垃圾收集器/垃圾收集器5.png" alt="垃圾收集器"></p><p>CMS是一款优秀的收集器，它的主要优点是并发收集、低停顿，但是它还有以下三个明显缺点：</p><ul><li>CMS收集器对CPU资源非常敏感；</li><li>CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次的Full GC。</li><li>CMS收集器是基于“标记-清除”算法实现的，在收集结束会产生大量的空间碎片。为了解决这个问题，CMS收集器提供了一个-XX:+USeCMSCompactAtFullCollection开关参数用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程。</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1收集器是当前收集技术最前沿的成果之一，它被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。G1是一款面向服务端应用的垃圾收集器，与其他收集器相比，G1具备如下特点：</p><ul><li>并行与并发</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li></ul><p>在G1之前的其他收集器进行收集的范围是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大区别，它将整个Java堆划分成多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垃圾收集算法是内存回收的方法论，垃圾收集器是垃圾回收的具体实现。在JDK1.7 Update 14之后的HotSpot虚拟机所包含的收集器如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/02/28/垃圾收集器/垃圾收集器1.jpg&quot; alt=&quot;垃圾收集器&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="垃圾收集器" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
      <category term="垃圾收集算法" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程基础</title>
    <link href="http://yoursite.com/2019/02/27/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/02/27/Java并发编程基础/</id>
    <published>2019-02-27T13:49:16.000Z</published>
    <updated>2019-03-01T14:26:51.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>现代操作系统在运行一个程序的时候就会创建一个进程。线程是现在操作系统系统调度的最小单元，也称为轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，每个线程都有自己的程序计数器、堆栈和局部变量等属性，并且能够访问内存中共享的变量。</p><h3 id="使用多线程的原因"><a href="#使用多线程的原因" class="headerlink" title="使用多线程的原因"></a>使用多线程的原因</h3><ol><li>更多的处理器核心：随着处理器上的核心数量越来越多，以及超线程技术的广泛应用，现在的计算机比以往更加擅长并行计算；</li><li>更快的响应时间：当业务逻辑过于复杂，使用多线程技术，将对数据一致性要求不高的操作派发给多个线程处理，这样做能更快地处理完一个复杂任务，缩短响应时间，提升用户体验；</li><li>更好的编程模型：Java为多线程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决，即为所遇到的问题建立合适的模型，而不是绞尽脑汁地考虑如何将任务多线程化。</li></ol><a id="more"></a><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法修改线程的优先级，默认优先级为5，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞的线程则设置较低的优先级，保证处理器不会被独占。</p><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>Java线程在运行的生命周期可能处于6种不同的状态，在任意给定时刻线程只能处于其中的一种状态：</p><table><thead><tr><th>状态名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>NEW</td><td style="text-align:center">初始状态，线程被构建，但是还没有调用start()方法</td></tr><tr><td>RUNNABLE</td><td style="text-align:center">运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称为“运行中”</td></tr><tr><td>BLOCKED</td><td style="text-align:center">阻塞状态，表示线程阻塞于锁</td></tr><tr><td>WAITING</td><td style="text-align:center">等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td>TIME_WAITING</td><td style="text-align:center">超时等待状态，该状态不同于WAITING，它是可以在指定时间自行返回的</td></tr><tr><td>TERMINATED</td><td style="text-align:center">终止状态，表示当前线程已经执行完毕</td></tr></tbody></table><h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程时，Java虚拟机将会退出。可以在线程启动之前通过调用Thread.setDaemon(true)将线程设置为Daemon线程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h2&gt;&lt;p&gt;现代操作系统在运行一个程序的时候就会创建一个进程。线程是现在操作系统系统调度的最小单元，也称为轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，每个线程都有自己的程序计数器、堆栈和局部变量等属性，并且能够访问内存中共享的变量。&lt;/p&gt;
&lt;h3 id=&quot;使用多线程的原因&quot;&gt;&lt;a href=&quot;#使用多线程的原因&quot; class=&quot;headerlink&quot; title=&quot;使用多线程的原因&quot;&gt;&lt;/a&gt;使用多线程的原因&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;更多的处理器核心：随着处理器上的核心数量越来越多，以及超线程技术的广泛应用，现在的计算机比以往更加擅长并行计算；&lt;/li&gt;
&lt;li&gt;更快的响应时间：当业务逻辑过于复杂，使用多线程技术，将对数据一致性要求不高的操作派发给多个线程处理，这样做能更快地处理完一个复杂任务，缩短响应时间，提升用户体验；&lt;/li&gt;
&lt;li&gt;更好的编程模型：Java为多线程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决，即为所遇到的问题建立合适的模型，而不是绞尽脑汁地考虑如何将任务多线程化。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
      <category term="volatile" scheme="http://yoursite.com/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu配置shadowsocks科学上网</title>
    <link href="http://yoursite.com/2019/02/26/Ubuntu%E9%85%8D%E7%BD%AEshadowsocks%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://yoursite.com/2019/02/26/Ubuntu配置shadowsocks科学上网/</id>
    <published>2019-02-26T04:36:59.000Z</published>
    <updated>2019-02-26T12:08:14.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网1.png" alt="科学上网"></p><h2 id="showsocks配置"><a href="#showsocks配置" class="headerlink" title="showsocks配置"></a>showsocks配置</h2><ol><li>安装shadowsocks客户端,命令如下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install shadowsocks</span><br></pre></td></tr></table></figure><a id="more"></a> <ol start="2"><li>查看shadowsocks命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal --help</span><br></pre></td></tr></table></figure><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网2.png" alt="科学上网"></p><ol start="3"><li>启动shadowsocks两种方式：</li></ol><ul><li>通过设置各个参数，如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -s 11.22.33.44 -p 50003 -k &quot;123456&quot; -l 1080 -t 600 -m aes-256-cfb</span><br></pre></td></tr></table></figure><ul><li>或者，直接加载json配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c file_path/shadowsocks.json</span><br></pre></td></tr></table></figure><p>启动shadowsocks如下所示：</p><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网3.png" alt="科学上网"></p><p>配置好shadowsocks客户端后，我们介绍一下三种方式设置代理模式。</p><h2 id="方式一：不要关闭上面的终端，重新打开一个终端，配置全局变量："><a href="#方式一：不要关闭上面的终端，重新打开一个终端，配置全局变量：" class="headerlink" title="方式一：不要关闭上面的终端，重新打开一个终端，配置全局变量："></a>方式一：不要关闭上面的终端，重新打开一个终端，配置全局变量：</h2><p>使用<code>vim ~/.bashrc</code>添加语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias hp=&quot;http_proxy=http://localhost:8123&quot;</span><br></pre></td></tr></table></figure></p><p>使用<code>source ~/.bashrc</code>使更改生效。</p><ol start="5"><li>测试效果</li></ol><ul><li>使用命令<code>hp curl ip.gs</code>查看代理服务器网址，结果如下所示：</li></ul><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网4.png" alt="科学上网"></p><p>可以看出，<code>alias hp=&quot;http_proxy=http://localhost:8123&quot;</code>这句语句的作用就是用命令<code>hp</code>替换<code>http_proxy=http://localhost:8123</code>这一串长命令。</p><h2 id="那我们不想每条指令前面都加上命令hp怎么办，这就需要设置全局代理："><a href="#那我们不想每条指令前面都加上命令hp怎么办，这就需要设置全局代理：" class="headerlink" title="那我们不想每条指令前面都加上命令hp怎么办，这就需要设置全局代理："></a>那我们不想每条指令前面都加上命令<code>hp</code>怎么办，这就需要设置全局代理：</h2><h3 id="方式二：为当前窗口设置全局代理"><a href="#方式二：为当前窗口设置全局代理" class="headerlink" title="方式二：为当前窗口设置全局代理"></a>方式二：为当前窗口设置全局代理</h3><p>命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://localhost:8123 # 当前终端使用代理</span><br><span class="line">unset http_proxy # 当前终端取消代理</span><br></pre></td></tr></table></figure></p><p>测试如下所示，可以看出上设置全局代理后，就不需要<code>hp</code>命令了，取消代理（<code>unset</code>）后可以看到<code>ip</code>变成了陕西西安。<br><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网5.png" alt="科学上网"></p><h3 id="方式三：设置当前用户的全局代理"><a href="#方式三：设置当前用户的全局代理" class="headerlink" title="方式三：设置当前用户的全局代理"></a>方式三：设置当前用户的全局代理</h3><p>在<code>~/.bashrc</code>中添加<code>export http_proxy=http://localhost:8123</code>命令设置当前用户的全局代理。别忘了使用<code>source ~/.bashrc</code>使更改生效。</p><p>如下所示，</p><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网6.png" alt="科学上网"></p><h2 id="经过测试，推荐方式二为当前窗口设置全局代理，命令如下："><a href="#经过测试，推荐方式二为当前窗口设置全局代理，命令如下：" class="headerlink" title="经过测试，推荐方式二为当前窗口设置全局代理，命令如下："></a>经过测试，推荐方式二为当前窗口设置全局代理，命令如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://localhost:8123 # 当前终端使用代理</span><br><span class="line">unset http_proxy # 当前终端取消代理</span><br></pre></td></tr></table></figure><p>这种方式可以开启一个窗口运行export作为科学上网窗口，而其他窗口依旧正常上网，这样可以<strong>节约流量</strong>。<br>除此之外，这是我测试的上述三种上网方式中最稳定的一种，建议使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>配置好之后，科学上网的过程，先打开一个终端窗口，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c file_path/shadowsocks.json</span><br></pre></td></tr></table></figure><p>再打开新窗口，运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://localhost:8123</span><br></pre></td></tr></table></figure></p><p>我使用R-3D中下载YouTube视频的代码作为测试，运行<code>python download_video.py</code>就可以看到下载视频并保存在当前目录的videos目录下。</p><p>示意结果如下，<code>sslocal -c shadowsocks.json</code>启动窗口下方会出现与<code>www.youtube.com</code>连接的日志信息：</p><p><img src="/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网7.png" alt="科学上网"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;系统环境&quot;&gt;&lt;a href=&quot;#系统环境&quot; class=&quot;headerlink&quot; title=&quot;系统环境&quot;&gt;&lt;/a&gt;系统环境&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/02/26/Ubuntu配置shadowsocks科学上网/科学上网1.png&quot; alt=&quot;科学上网&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;showsocks配置&quot;&gt;&lt;a href=&quot;#showsocks配置&quot; class=&quot;headerlink&quot; title=&quot;showsocks配置&quot;&gt;&lt;/a&gt;showsocks配置&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装shadowsocks客户端,命令如下&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt install shadowsocks&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="工程" scheme="http://yoursite.com/categories/%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
      <category term="shadowsocks" scheme="http://yoursite.com/tags/shadowsocks/"/>
    
      <category term="科学上网" scheme="http://yoursite.com/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
      <category term="代理" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%90%86/"/>
    
      <category term="proxy" scheme="http://yoursite.com/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>面向切面编程</title>
    <link href="http://yoursite.com/2019/02/21/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/21/面向切面编程/</id>
    <published>2019-02-21T09:08:56.000Z</published>
    <updated>2019-03-09T14:10:14.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向切面编程（Aspect-Oriented-Programming，AOP）是什么？"><a href="#面向切面编程（Aspect-Oriented-Programming，AOP）是什么？" class="headerlink" title="面向切面编程（Aspect Oriented Programming，AOP）是什么？"></a>面向切面编程（Aspect Oriented Programming，AOP）是什么？</h2><ol><li>AOP是一种编程范式，不是编程语言；</li><li>AOP解决特定问题，但不能解决所有问题；</li><li>OOP的补充，而不是其替代。<a id="more"></a> </li></ol><h2 id="AOP为什么出现？"><a href="#AOP为什么出现？" class="headerlink" title="AOP为什么出现？"></a>AOP为什么出现？</h2><ol><li>提高代码重用性；</li><li>概念分离：分离功能性需求和非功能性需求。将功能性需求从非功能性需求中分离出来。</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>权限控制</li><li>缓存控制</li><li>事务控制</li><li>审计日志</li><li>性能监控</li><li>分布式追踪</li><li>异常处理</li></ol><h2 id="Spring-AOP的通过代理实现"><a href="#Spring-AOP的通过代理实现" class="headerlink" title="Spring AOP的通过代理实现"></a>Spring AOP的通过代理实现</h2><p>通过DefaultAopProxyFactory.java源码可以看到AOP由jdk和cglib两种方式实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        if (targetClass == null) &#123;</span><br><span class="line">            throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +</span><br><span class="line">                    &quot;Either an interface or a target is required for proxy creation.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            return new JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        return new ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return new JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Spring-AOP的使用"><a href="#Spring-AOP的使用" class="headerlink" title="Spring AOP的使用"></a>Spring AOP的使用</h2><p>在Spring中主要使用注解@Aspect、@Pointcut、@Before、@After、@AfterReturning、@AfterThrowing以及@Around进行面向切面编程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface Aspect &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Per clause expression, defaults to singleton aspect</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * Valid values are &quot;&quot; (singleton), &quot;perthis(...)&quot;, etc</span><br><span class="line">     */</span><br><span class="line">    public String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码是@Aspect注解的定义，ElementType.TYPE可以看出该注解作用目标是接口、类、枚举、注解，@Aspect注解，Spring通过@Aspect注解切面并把它应用到目标对象上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface Pointcut &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The pointcut expression</span><br><span class="line">     * We allow &quot;&quot; as default for abstract pointcut</span><br><span class="line">     */</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * When compiling without debug info, or when interpreting pointcuts at runtime,</span><br><span class="line">     * the names of any arguments used in the pointcut are not available.</span><br><span class="line">     * Under these circumstances only, it is necessary to provide the arg names in </span><br><span class="line">     * the annotation - these MUST duplicate the names used in the annotated method.</span><br><span class="line">     * Format is a simple comma-separated list.</span><br><span class="line">     */</span><br><span class="line">    String argNames() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码是@Pointcut注解的定义，value()用来定义切面所在的位置，定义方式有以下几种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// execution定义切面，匹配符合表达式的所有方法</span><br><span class="line">@Pointcut(&quot;execution(* com.xjtu.springbootstudy.aop.bymyself.service.ProgrammerService.work())&quot;)</span><br><span class="line">// within用于匹配类，对应类下的所有方法都执行切面方法；</span><br><span class="line">@Pointcut(&quot;within(com.xjtu.springbootstudy.aop.bymyself.service.*)&quot;)</span><br><span class="line">// @annotation用于匹配自定义注解，如下面的@SignLog注解，再将@SignLog放在想定义切面的方法</span><br><span class="line">@Pointcut(&quot;@annotation(com.xjtu.springbootstudy.aop.bymyself.annotation.SignLog)&quot;)</span><br><span class="line">// @within用于匹配自定义注解，如下面的@SignLog注解，再将@SignLog放在想定义切面的类上</span><br><span class="line">@Pointcut(&quot;@within(com.xjtu.springbootstudy.aop.bymyself.annotation.SignLog))&quot;)</span><br><span class="line">public void log()&#123; &#125;</span><br></pre></td></tr></table></figure></p><p>如上对log()添加注解，@Pointcut注解中value定义切面位置，使用execution、within、@annotation、@within等方式设置切面。</p><ul><li>@before在目标方法开始执行时执行；</li><li>@after在目标方法执行结束前执行；</li><li>@AfterReturning在目标方法执行正确返回前执行；</li><li>@AfterThrowing在目标方法执行异常时执行，</li><li>@Around环绕执行，一般是前4个无法实现期望功能时，才使用这个注解。</li></ul><p>我写了一个简单示意切面程序，如下所示，对应执行结果也展示下下方。有个疑问就是@after和@AfterReturning注解的方法谁<strong>先执行</strong>？根据执行结果也可以看出<br><strong>@after</strong>注解的方法<strong>先执行</strong>，@AfterReturning注解的方法后执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Before(value = &quot;log()&quot;)</span><br><span class="line">public void signIn(JoinPoint joinPoint)&#123;</span><br><span class="line">    logger.info(&quot;***********the people signs in******&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@After(value = &quot;log()&quot;)</span><br><span class="line">public void leaveWorkPlace(JoinPoint joinPoint)&#123;</span><br><span class="line">    logger.info(&quot;***********the people leaves workplace******&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@AfterReturning(value = &quot;log()&quot;)</span><br><span class="line">public void signOut(JoinPoint joinPoint)&#123;</span><br><span class="line">    logger.info(&quot;***********the people signs out successfully******&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@AfterThrowing(value = &quot;log()&quot;,throwing = &quot;throwable&quot;)</span><br><span class="line">public void happenAccidentWhenWorking(JoinPoint joinPoint,Throwable throwable)&#123;</span><br><span class="line">    logger.info(&quot;***********the people happens accident when working******&quot;);</span><br><span class="line">    logger.info(&quot;***********&quot;+throwable.getMessage()+&quot;***********&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Around(value = &quot;log()&quot;)</span><br><span class="line">public void happenAround(ProceedingJoinPoint joinPoint)&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        joinPoint.proceed(joinPoint.getArgs());</span><br><span class="line">    &#125; catch (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">***********the people signs in******                // @before</span><br><span class="line">I&apos;m working in workplace!                           // 这是目标方法的执行结果</span><br><span class="line">***********the people leaves workplace******        // @after</span><br><span class="line">***********the people signs out successfully******  // @afterReturning</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向切面编程（Aspect-Oriented-Programming，AOP）是什么？&quot;&gt;&lt;a href=&quot;#面向切面编程（Aspect-Oriented-Programming，AOP）是什么？&quot; class=&quot;headerlink&quot; title=&quot;面向切面编程（Aspect Oriented Programming，AOP）是什么？&quot;&gt;&lt;/a&gt;面向切面编程（Aspect Oriented Programming，AOP）是什么？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;AOP是一种编程范式，不是编程语言；&lt;/li&gt;
&lt;li&gt;AOP解决特定问题，但不能解决所有问题；&lt;/li&gt;
&lt;li&gt;OOP的补充，而不是其替代。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
      <category term="AOP" scheme="http://yoursite.com/tags/AOP/"/>
    
      <category term="面向切面编程" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象编程知识点</title>
    <link href="http://yoursite.com/2019/02/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2019/02/20/Java面向对象编程知识点/</id>
    <published>2019-02-20T02:40:58.000Z</published>
    <updated>2019-04-08T09:10:02.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象的三个基本特征和五种设计原则"><a href="#面向对象的三个基本特征和五种设计原则" class="headerlink" title="面向对象的三个基本特征和五种设计原则"></a>面向对象的三个基本特征和五种设计原则</h2><h3 id="三个基本特征"><a href="#三个基本特征" class="headerlink" title="三个基本特征"></a>三个基本特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏；</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重写原有类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“父类”或“基类”。继承的过程就是从一般到特殊的过程。<br>要实现继承可以通过“继承”和“组合”两种方式实现。在某些OOP语言中，一个子类可以继承多个基类，但一般情况下（Java语言），一个子类只有一个基类，实现多重继承可以通过多级继承来实现。<br><a id="more"></a><br>继承概念的实现方式有三类：  </p><ul><li>实现继承：指使用基类的属性和方法而无需额外编码的能力；</li><li>接口继承：指仅使用基类的属性和方法名称，但子类必须提供实现的能力；</li><li>可视继承：指子类使用基类的外观和实现代码的能力。<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4></li></ul><p>多态是允许你将父对象设置成为和一个或多个它的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同方式运作。简单地说就是：允许将子类类型的指针赋值给父类类型的指针。<br>实现多态有两种方式：覆盖和重载：  </p><ul><li>覆盖是指子类重新定义父类的虚函数的做法；</li><li>重载是指允许多个同名函数，这些函数的参数不同（参数个数不同，或参数类型不同，或两者都不同）。</li></ul><h3 id="五种设计原则"><a href="#五种设计原则" class="headerlink" title="五种设计原则"></a>五种设计原则</h3><h4 id="单一职责原则-Single-Responsibility-Principle，SRP"><a href="#单一职责原则-Single-Responsibility-Principle，SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle，SRP)"></a>单一职责原则(Single Responsibility Principle，SRP)</h4><p>单一职责原则是指一个类的功能要单一，不能包罗万象。一个类应该只有一个引起它变化的原因。</p><h4 id="开放封闭原则-Open－Close-Principle，OCP"><a href="#开放封闭原则-Open－Close-Principle，OCP" class="headerlink" title="开放封闭原则(Open－Close Principle，OCP)"></a>开放封闭原则(Open－Close Principle，OCP)</h4><p> 开放封闭原则指的是对扩展性的开放和对修改的封闭：</p><ul><li>对扩展性的开放：模块的行为应该是可扩展的，从而该模块可表现出行的行为以满足需求的变化；</li><li><p>对修改的封闭：模块自身的代码时不应该被修改的，扩展模块的一般途径是修改内部实现。</p><h4 id="里氏替换原则-the-Liskov-Substitution-Principle，LSP"><a href="#里氏替换原则-the-Liskov-Substitution-Principle，LSP" class="headerlink" title="里氏替换原则(the Liskov Substitution Principle，LSP)"></a>里氏替换原则(the Liskov Substitution Principle，LSP)</h4><p>子类型必须能够替换掉它们的父类型，并出现在父类能够出现的任何地方。</p></li></ul><h4 id="依赖倒置原则-the-Dependency-Inversion-Principle，PIP"><a href="#依赖倒置原则-the-Dependency-Inversion-Principle，PIP" class="headerlink" title="依赖倒置原则(the Dependency Inversion Principle，PIP)"></a>依赖倒置原则(the Dependency Inversion Principle，PIP)</h4><p>具体依赖抽象，上层依赖下层。</p><h4 id="接口隔离原则-the-Interface-Segregation-Principle，ISP"><a href="#接口隔离原则-the-Interface-Segregation-Principle，ISP" class="headerlink" title="接口隔离原则(the Interface Segregation Principle，ISP)"></a>接口隔离原则(the Interface Segregation Principle，ISP)</h4><p>模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来。</p><h2 id="Class-java类文件下getMethods-和getDeclaredMethods-的区别"><a href="#Class-java类文件下getMethods-和getDeclaredMethods-的区别" class="headerlink" title="Class.java类文件下getMethods()和getDeclaredMethods()的区别"></a><code>Class.java</code>类文件下<code>getMethods()</code>和<code>getDeclaredMethods()</code>的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public Method[] getMethods() throws SecurityException &#123;</span><br><span class="line">    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);</span><br><span class="line">    return copyMethods(privateGetPublicMethods());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@CallerSensitive</span><br><span class="line">public Method[] getDeclaredMethods() throws SecurityException &#123;</span><br><span class="line">    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);</span><br><span class="line">    return copyMethods(privateGetDeclaredMethods(false));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getMethods()</code>是获取对应类及其所有父类中的共有（public）方法；<code>getDeclaredMethods()</code>获取的是当前类中的所有方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向对象的三个基本特征和五种设计原则&quot;&gt;&lt;a href=&quot;#面向对象的三个基本特征和五种设计原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象的三个基本特征和五种设计原则&quot;&gt;&lt;/a&gt;面向对象的三个基本特征和五种设计原则&lt;/h2&gt;&lt;h3 id=&quot;三个基本特征&quot;&gt;&lt;a href=&quot;#三个基本特征&quot; class=&quot;headerlink&quot; title=&quot;三个基本特征&quot;&gt;&lt;/a&gt;三个基本特征&lt;/h3&gt;&lt;h4 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h4&gt;&lt;p&gt;封装就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏；&lt;/p&gt;
&lt;h4 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h4&gt;&lt;p&gt;继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重写原有类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“父类”或“基类”。继承的过程就是从一般到特殊的过程。&lt;br&gt;要实现继承可以通过“继承”和“组合”两种方式实现。在某些OOP语言中，一个子类可以继承多个基类，但一般情况下（Java语言），一个子类只有一个基类，实现多重继承可以通过多级继承来实现。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工作" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>StackGAN: Text to Photo-realistic Image Synthesis with Stacked Generative Adversarial Networks</title>
    <link href="http://yoursite.com/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/"/>
    <id>http://yoursite.com/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/</id>
    <published>2019-02-19T09:06:58.000Z</published>
    <updated>2019-02-20T08:12:42.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p><a href="https://github.com/hanzhanggit/StackGAN" target="_blank" rel="noopener">源码地址：https://github.com/hanzhanggit/StackGAN</a></p><p>这篇文章提出<code>Stacked Generative Adversarial Networks (StackGAN)</code>合成高分辨率（$256 \times 256$）的逼真图像。这个模型将困难的图像合成问题分成两个子问题：<code>Stage-I GAN</code>根据输入的文本描述合成对象的基本形状和颜色；<code>Stage-II GAN</code>根据<code>Stage-I GAN</code>以合成的图像结果和文本描述作为输入，丰富合成图像的细节，生成逼真的高分辨率图像。 </p><p><img src="/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/StackGAN0.png" alt="image"></p><a id="more"></a> <p>我们都知道生成对抗网络的训练过程存在不稳定性，作者提出了一种新的条件增强技术促进潜在条件流形（<code>latent conditioning manifold</code>）的平滑性，从而改善了合成图像的多样性和训练生成对抗网络过程的稳定性。</p><h2 id="Stacked-Generative-Adversarial-Networks"><a href="#Stacked-Generative-Adversarial-Networks" class="headerlink" title="Stacked Generative Adversarial Networks"></a>Stacked Generative Adversarial Networks</h2><p><img src="/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/StackGAN.png" alt="image"></p><p><code>Stacked Generative Adversarial Networks</code>的结构如下图所示分为<code>Stage-I GAN</code>和<code>Stage-II GAN</code>两个子网络：  </p><ul><li><code>Stage-I GAN</code>：以文本描述和噪声向量为输入，文本描述控制对象的基本形状和颜色，噪声控制背景布局，从而生成一张低分辨率图像；</li><li><code>Stage-II GAN</code>：纠正<code>Stage-I</code>生成的低分辨率图像的缺陷，再次通过读取文本描述来补全图像的细节，从而生成高分辨率的逼真图像。</li></ul><h3 id="Stage-I-GAN"><a href="#Stage-I-GAN" class="headerlink" title="Stage-I GAN"></a>Stage-I GAN</h3><h4 id="KL散度（Kullback–Leibler-divergence-KL-divergence）"><a href="#KL散度（Kullback–Leibler-divergence-KL-divergence）" class="headerlink" title="KL散度（Kullback–Leibler divergence,KL divergence）"></a>KL散度（<code>Kullback–Leibler divergence,KL divergence</code>）</h4><p>本文章中的条件增强技术中计算标准高斯分布和条件高斯分布之间的KL散度，所以先简单介绍KL散度。<br>KL散度又被称为相对熵（<code>relative entropy</code>）或者信息散度，是连个概率分布间差异的非对称性度量。  </p><p>$$<br>KL(p(x)||q(x))=\sum_x{p(x)\log{\frac{p(x)}{q(x)}}}\\<br>=\sum_x{p(x)\log{p(x)}-p(x)\log{q(x)}}<br>$$</p><p>KL散度是衡量两个分布之间的差异大小的，KL散度大于等于0，并且越接近0说明p与q这两个分布越像，当且仅当p与q相等时KL散度取0。</p><h4 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h4><p>对于生成器$G_0$，为了获得文本条件变量$\hat{c}_0$，文本嵌入$\varphi_t$首先通过全连接层生成$\mu_0$和$\delta_0$（$\delta_0$是$\sum_0$的对角线元素值）。$\hat{c}_0$由高斯分布$N(\mu(\varphi(t)),\sum_0(\varphi(t)))$抽样得到。$N_g$维的条件向量$\hat{c}_0$由公式$\hat{c}_0=\mu_0+\delta_0 \bigodot\epsilon$计算得到，其中$\bigodot$表示元素乘积（<code>element-wise multiplication</code>），$\epsilon\sim\N(0,I)$。之后，$\hat{c}_0$与$N_z$维的噪声向量拼接并通过一系列的上采样块生成尺寸为$W_0\times H_0$的图像。<br>对于判别器$D_0$,文本嵌入$\varphi(t)$通过全连接压缩为$N_d$维然后通过复制将其转换成$M_d \times M_d \times N_d$大小的张量。同时图像经过一系列下采样块，输出$M_d \times M_d$大小的张量。最后把图像和文本得到的张量拼接在一起，经过$1\times 1$的卷积层以及一个只有一个节点的全连接层，从而得到决策值。<br>Stage-I训练过程损失函数如下，目的在于最大化$L_{D_0}$以训练判别器，最小化$L_{G_0}$以训练生成器。</p><p>$$<br>L_{D_0}=E_{(I_0,t)\sim{p_{data}}}[\log D_0(I_0,\varphi_t)]<br>+E_{z\sim{p_z},t\sim p_{data}}[\log {(1-D_0(G_0(z,\hat{c}_0),\varphi_t)}]\\<br>L_{G_0}=E_{z\sim{p_z},t\sim p_{data}}[\log {(1-D_0(G_0(z,\hat{c}_0),\varphi_t)}]+\lambda{D_{KL}}(N(\mu_0(\varphi_t),\sum_0(\varphi_t)||N(0,I)),<br>$$</p><h3 id="Stage-II-GAN"><a href="#Stage-II-GAN" class="headerlink" title="Stage-II GAN"></a>Stage-II GAN</h3><p><code>Stage-II GAN</code>的模型框架和<code>Stage-I GAN</code>相似，只不过没有了噪声输入，换成了<code>Stage-I</code>合成的低分率图像。<br>Stage-II其损失函数如下，目的在于最大化$L_D$以训练判别器，最小化$L_G$以训练生成器。  </p><p>$$<br>L_D=E_{(I,t)\sim{p_{data}}}[\log D(I,\varphi_t)]<br>+E_{s_0\sim{p_{G_0}},t\sim p_{data}}[\log {(1-D(G(s_0,\hat{c}),\varphi_t)}]\\<br>L_G=E_{s_0\sim{p_{G_0}},t\sim p_{data}}[\log {(1-D(G(s_0,\hat{c}),\varphi_t)}]+\lambda{D_{KL}}(N(\mu(\varphi_t),\sum(\varphi_t)||N(0,I)),<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/hanzhanggit/StackGAN&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码地址：https://github.com/hanzhanggit/StackGAN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章提出&lt;code&gt;Stacked Generative Adversarial Networks (StackGAN)&lt;/code&gt;合成高分辨率（$256 \times 256$）的逼真图像。这个模型将困难的图像合成问题分成两个子问题：&lt;code&gt;Stage-I GAN&lt;/code&gt;根据输入的文本描述合成对象的基本形状和颜色；&lt;code&gt;Stage-II GAN&lt;/code&gt;根据&lt;code&gt;Stage-I GAN&lt;/code&gt;以合成的图像结果和文本描述作为输入，丰富合成图像的细节，生成逼真的高分辨率图像。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/02/19/StackGAN-Text-to-Photo-realistic-Image-Synthesis-with-Stacked-Generative-Adversarial-Networks/StackGAN0.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://yoursite.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="论文阅读" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="text2image" scheme="http://yoursite.com/tags/text2image/"/>
    
      <category term="图像合成" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90/"/>
    
      <category term="生成对抗网络" scheme="http://yoursite.com/tags/%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型（二）</title>
    <link href="http://yoursite.com/2019/02/19/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/19/Java内存模型（二）/</id>
    <published>2019-02-19T07:05:28.000Z</published>
    <updated>2019-02-19T08:35:29.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的手段。</p><h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>如果两个操作访问同一个变量，且这两个操作中有一为写操作，此时这两个操作时间就存在数据依赖性。数据依赖分为三种类型：写后读、写后写、读后写。<br>上述三种情况，只要重排序这两个操作的执行顺序，程序的执行结果就会改变。因此编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作顺序。<br>这类所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。<br><a id="more"></a> </p><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a><code>as-if-serial</code>语义</h3><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不会被改变。as-if-serial语义把单线程程序保护起来，遵循as-if-serial语义的编译器、runtime和处理器保证单线程程序执行的结果与其按照顺序执行的结果一致。</p><h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;           //A</span><br><span class="line">double r = 1.0;             //B</span><br><span class="line">double area = pi * r * r;   //C</span><br></pre></td></tr></table></figure><p>根据happens-before的程序顺序规则，上面计算圆面积的示例代码存在3个happens-before关系：  </p><ul><li><code>A happens-before B</code></li><li><code>B happens-before C</code></li><li><code>A happens-before C</code></li></ul><p>这里<code>A happens-before B</code>，但在实际执行时B却可以在A之前执行。如果<code>A happens-before B</code>，JMM并不一定要求A在B之前执行。JMM仅仅要求前一个操作对后一个操作可见，且前一个操作按顺序排在后一操作之前。这里操作A的执行结果并不需要对操作B可见；而且重排序操作A和操作B后的执行结果，与操作A和操作B按照<code>A happens-before B</code>顺序执行的结果一致。在这种情况下，JMM会认为这种重排序不非法（not illegal）,JMM允许这种重排序。<br>在计算机中，软件技术和硬件技术有一个共同目的：在不改变程序执行结果的前提下，尽可能提高并行度。</p><h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><p>多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><h3 id="数据竞争与顺序一致性"><a href="#数据竞争与顺序一致性" class="headerlink" title="数据竞争与顺序一致性"></a>数据竞争与顺序一致性</h3><p>当程序未正确同步时，就可能会存在数据竞争。Java内存模型规范对数据竞争的定义如下：  </p><ul><li>在一个线程中写入一个变量；</li><li>在另一个线程中读同一个变量；</li><li>而且写和读没有通过同步来排序。  </li></ul><p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果。如果一个多线程程序能够同步，这个程序将是一个没有数据竞争的程序。JMM对正确同步的多线程程序的内存一致性做了如下保证：<br>如果程序时正确同步的，程序的执行将具有顺序一致性——即程序的执行结果与改程序在顺序一致性内存模型中的执行结果相同。</p><h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>顺序一致性内存模型是一个被计算机科学家理想化的理论参考模型。它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：  </p><ul><li>一个线程中的所有操作都必须按照程序的顺序来执行；</li><li>（不管线程是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;h2 id=&quot;重排序&quot;&gt;&lt;a href=&quot;#重排序&quot; class=&quot;headerlink&quot; title=&quot;重排序&quot;&gt;&lt;/a&gt;重排序&lt;/h2&gt;&lt;p&gt;重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的手段。&lt;/p&gt;
&lt;h3 id=&quot;数据依赖性&quot;&gt;&lt;a href=&quot;#数据依赖性&quot; class=&quot;headerlink&quot; title=&quot;数据依赖性&quot;&gt;&lt;/a&gt;数据依赖性&lt;/h3&gt;&lt;p&gt;如果两个操作访问同一个变量，且这两个操作中有一为写操作，此时这两个操作时间就存在数据依赖性。数据依赖分为三种类型：写后读、写后写、读后写。&lt;br&gt;上述三种情况，只要重排序这两个操作的执行顺序，程序的执行结果就会改变。因此编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作顺序。&lt;br&gt;这类所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="重排序" scheme="http://yoursite.com/tags/%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    
      <category term="数据依赖性" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E6%80%A7/"/>
    
      <category term="顺序一致性" scheme="http://yoursite.com/tags/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型（一）</title>
    <link href="http://yoursite.com/2019/02/18/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/18/Java内存模型（一）/</id>
    <published>2019-02-18T06:54:08.000Z</published>
    <updated>2019-02-18T08:13:46.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="Java内存模型的基础"><a href="#Java内存模型的基础" class="headerlink" title="Java内存模型的基础"></a>Java内存模型的基础</h2><h3 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h3><ol><li>线程之间如何通信？</li><li>线程之间如何同步？</li></ol><p>通信是指线程之间以何种机制交换信息，在命令式编程中线程之间的通信机制有两种：共享内存和消息传递。在共享内存模型中，线程之间共享程序的公共状态，通过读写内存中的公共状态进行隐式通信；而在消息传递的并发模型中，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。<br><a id="more"></a><br>同步是指程序中用来控制不同线程间操作发生的相对顺序的机制。在共享内存并发模型中，同步是显式进行的。程序员必须显式指定某个方法或某个代码段需要在线程之间互斥执行。在消息传递的并发模型中，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。<br>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行的，整个通信过程对于程序员完全透明。</p><h3 id="Java内存模型的抽象结构"><a href="#Java内存模型的抽象结构" class="headerlink" title="Java内存模型的抽象结构"></a>Java内存模型的抽象结构</h3><p>在Java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。局部变量（Local Variables），方法定义参数（Formal Method Parameters）和异常处理器参数（Exception Handler Parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。<br>Java线程之间的通信由Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程读写共享变量的副本。本地内存是JMM的一个抽象概念，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><p><img src="/2019/02/18/Java内存模型（一）/jmm1.png" alt="image"></p><p>由上图看出线程A和线程B之间要通信的话，必须经历以下两个步骤：<br>1）.线程A把本地内存A中更新过的共享变量 刷新到主内存中去；<br>2）.线程B到主内存中去读取线程A之前已更新过的共享变量。</p><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为3种类型。<br>1）编译器优化的重排序。编译器再不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。<br>2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<br>3）内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是乱序执行。</p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作，既可以在一个线程之内，也可以在不同线程之间。<br>与程序员密切相关的happens-before规则如下：  </p><ul><li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。（也就是说一个线程中的每个操作的结果对于该线程中的其他操作都是可见的）</li><li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。（也就是说一个锁的解锁操作需要对该锁的解锁操作可见）</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果<code>A happens-before B</code>，且<code>B happens-before C</code>，那么<code>A happens-before C</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;h2 id=&quot;Java内存模型的基础&quot;&gt;&lt;a href=&quot;#Java内存模型的基础&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型的基础&quot;&gt;&lt;/a&gt;Java内存模型的基础&lt;/h2&gt;&lt;h3 id=&quot;并发编程模型的两个关键问题&quot;&gt;&lt;a href=&quot;#并发编程模型的两个关键问题&quot; class=&quot;headerlink&quot; title=&quot;并发编程模型的两个关键问题&quot;&gt;&lt;/a&gt;并发编程模型的两个关键问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;线程之间如何通信？&lt;/li&gt;
&lt;li&gt;线程之间如何同步？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通信是指线程之间以何种机制交换信息，在命令式编程中线程之间的通信机制有两种：共享内存和消息传递。在共享内存模型中，线程之间共享程序的公共状态，通过读写内存中的公共状态进行隐式通信；而在消息传递的并发模型中，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java内存模型" scheme="http://yoursite.com/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="共享内存" scheme="http://yoursite.com/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    
      <category term="happens-before" scheme="http://yoursite.com/tags/happens-before/"/>
    
      <category term="指令重排序" scheme="http://yoursite.com/tags/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发机制的底层实现原理</title>
    <link href="http://yoursite.com/2019/01/21/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/01/21/并发机制的底层实现原理/</id>
    <published>2019-01-21T02:22:24.000Z</published>
    <updated>2019-01-21T13:02:52.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发机制的底层实现原理"><a href="#并发机制的底层实现原理" class="headerlink" title="并发机制的底层实现原理"></a>并发机制的底层实现原理</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>在多线程并发编程中synchronized和volatile关键字都扮演着重要角色，volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外的线程可以读到修改后的值。volatile的恰当使用能比synchronized关键字的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。<br><a id="more"></a><br><strong>定义</strong>：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。<br>Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。<br>在X86处理器下通过工具获取JIT编译器生成的汇编指令，查看对volatile变量进行写操作时，对应CPU的操作，例子如下：</p><ul><li><p>Java代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = new Singleton();    //instance是volatile变量</span><br></pre></td></tr></table></figure></li><li><p>转化为汇编代码，如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x01a3de1d: movb $0x0,ox1104800(%esi);0x01a3de24: lock addl $0x0,(%esp);</span><br></pre></td></tr></table></figure></li></ul><p>有volatile变量修饰的共享变量进行写操作时会多出两行汇编代码，通过查看IA-32架构软件开发者手册可知，Lock前缀的指令在多核处理器中会发生以下两件事情。  </p><ol><li>将当前处理器的缓存行的数据写回到系统内存；</li><li>这个写回内存的操作会是其他CPU里缓存了该内存地址的数据无效。</li></ol><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>在多线程并发编程中synchronized一直是元老级角色，很多人称呼它为重量级锁。Java SE1.6对synchronized进行了各种优化，为减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。<br>synchronized实现同步的基础：Java中的每一个对象都可以作为锁，具体表现为一些3种形式：  </p><ul><li>对于普通同步方法，锁是当前实例对象；</li><li>对于静态同步方法，锁是当前类的Class对象；</li><li>对于同步代码块，锁是Synchronized括号里配置的对象。  </li></ul><p>当一个线程师徒访问同步代码块时，它首先必须得到锁，退出或者抛出异常时必须释放锁。<br>从JVM规范中可以看到Synchronized在JVM里实现的原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者实现细节不同。代码块同步用monitorenter和monitorexit指令实现，而方法同步是使用另一种方式实现的，细节没有在JVM规范中提及。但方法的同步同样可以使用上述两个指令实现。<br>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有之后，它将处于被锁状态。线程执行到monitor指令时，将尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。  </p><h3 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h3><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，在Java SE 1.6中，锁一共有4个状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态随着竞争情况逐渐升级。锁可以升级但不可以降级，意味着偏向锁升级为轻量级锁后不能降级为偏向锁。这种锁只能升级不能降级的策略是为了提高获得锁和释放锁的效率。</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作（atomic operation）指的是不可被中断的一个或者一系列操作。<br>处理器保证从系统内存中读取或写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。但是负责的内存操作处理器是不能自动保证原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来保证复杂内存操作的原子性。</p><ul><li>总线锁是指使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器就可以独占共享内存。但是总线锁定把CPU和内存之间的通信锁定了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定开销比较大。</li><li>缓存锁定是指内存区域如果被缓存在处理器的缓存行中，并且在LOCK操作期间被锁定，那么当它执行写操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效  </li></ul><p>CAS实现原子操作的三大问题：</p><ol><li>ABA问题；</li><li>循环时间长开销大；</li><li>只能保证一个共享变量的原子操作。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发机制的底层实现原理&quot;&gt;&lt;a href=&quot;#并发机制的底层实现原理&quot; class=&quot;headerlink&quot; title=&quot;并发机制的底层实现原理&quot;&gt;&lt;/a&gt;并发机制的底层实现原理&lt;/h1&gt;&lt;h2 id=&quot;volatile&quot;&gt;&lt;a href=&quot;#volatile&quot; class=&quot;headerlink&quot; title=&quot;volatile&quot;&gt;&lt;/a&gt;volatile&lt;/h2&gt;&lt;p&gt;在多线程并发编程中synchronized和volatile关键字都扮演着重要角色，volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外的线程可以读到修改后的值。volatile的恰当使用能比synchronized关键字的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
      <category term="volatile" scheme="http://yoursite.com/tags/volatile/"/>
    
      <category term="原子操作" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>并发编程的挑战</title>
    <link href="http://yoursite.com/2019/01/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98/"/>
    <id>http://yoursite.com/2019/01/20/并发编程的挑战/</id>
    <published>2019-01-20T12:06:28.000Z</published>
    <updated>2019-01-21T02:25:24.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h1><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>在多线程执行代码的过程中，CPU为每个线程分配CPU时间片保证线程的执行，时间片很短，一般是几十毫秒（ms）。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存前一个任务的状态，以便下次切换回这个任务的时候可以再加载这个任务。任务从保存到再加载的过程就是一次上下文切换。<br><a id="more"></a><br>多线程由于上下文切换的存在使得其不一定比单线程快，一般减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。  </p><ul><li><strong>无锁并发编程</strong>：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些方法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同线程处理不同段的数据；</li><li><strong>CAS算法</strong>：Java的Atomic包使用CAS算法来更新数据，而不需要加锁；</li><li><strong>使用最少线程</strong>：避免创建不需要的线程，比如任务少时，创建很多线程会造成大量线程都处于等待状态；</li><li><strong>使用协程</strong>：在单线程中实现多任务的调度，并在单线程里维持多个任务间的切换。<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2>死锁是指由于两个或者多个任务互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。</li></ul><h3 id="线程死锁产生的四个必要条件"><a href="#线程死锁产生的四个必要条件" class="headerlink" title="线程死锁产生的四个必要条件"></a>线程死锁产生的四个必要条件</h3><ol><li><strong>互斥条件</strong>：某种资源一次只允许一个线程访问，即该资源一旦分配给某个线程，其他线程就不能再访问，直到该进程访问结束并释放；</li><li><strong>请求和保持条件</strong>：指线程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它线程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放；</li><li><strong>不剥夺条件</strong>：指线程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放；</li><li><strong>环路(循环)等待条件</strong>：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合<code>{t0，t1，t2，···，tn}</code>中的t0正在等待一个t1占用的资源；t1正在等待t2占用的资源，……，tn正在等待已被t0占用的资源。</li></ol><h3 id="避免死锁的几个常用方法"><a href="#避免死锁的几个常用方法" class="headerlink" title="避免死锁的几个常用方法"></a>避免死锁的几个常用方法</h3><ul><li>避免一个线程同时获得多个锁；</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源；</li><li>尝试使用定时锁，使用<code>lock。tryLock(timeout)</code>来替代使用内部锁机制；</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li></ul><h2 id="资源限制的挑战"><a href="#资源限制的挑战" class="headerlink" title="资源限制的挑战"></a>资源限制的挑战</h2><p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。例如，网络带宽的限制、硬盘读写速度的限制、CPU计算速度的限制、数据库的连接数和socket连接数限制等。</p><h3 id="资源限制引发的问题"><a href="#资源限制引发的问题" class="headerlink" title="资源限制引发的问题"></a>资源限制引发的问题</h3><p>在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变为并发执行，但如果将某段串行代码并发执行，因为资源受限，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。</p><h3 id="资源限制的解决"><a href="#资源限制的解决" class="headerlink" title="资源限制的解决"></a>资源限制的解决</h3><p>对应硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机上运行。比如用<code>ODPS</code>、<code>Hadoop</code>或者自己搭建服务器集群，不同的机器处理不同的数据。<br>对于软件资源限制，可以考虑使用资源池复用资源。比如使用连接池将数据库和Socket连接复用，或者在调用对方webservice接口获取数据时，只建立一个连接。</p><h3 id="资源限制下的并发编程"><a href="#资源限制下的并发编程" class="headerlink" title="资源限制下的并发编程"></a>资源限制下的并发编程</h3><p>根据不同的资源限制调整程序的并发度，比如下载文件程序依赖于两个资源——带宽和硬盘读写速度。有数据库操作时，涉及数据库连接数，如果SQL语句执行非常快，而线程的数量比数据库连接数大很多，就会导致某些线程被阻塞，等待数据库连接，因此这个时候就应该降低线程数量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程的挑战&quot;&gt;&lt;a href=&quot;#并发编程的挑战&quot; class=&quot;headerlink&quot; title=&quot;并发编程的挑战&quot;&gt;&lt;/a&gt;并发编程的挑战&lt;/h1&gt;&lt;h2 id=&quot;上下文切换&quot;&gt;&lt;a href=&quot;#上下文切换&quot; class=&quot;headerlink&quot; title=&quot;上下文切换&quot;&gt;&lt;/a&gt;上下文切换&lt;/h2&gt;&lt;p&gt;在多线程执行代码的过程中，CPU为每个线程分配CPU时间片保证线程的执行，时间片很短，一般是几十毫秒（ms）。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存前一个任务的状态，以便下次切换回这个任务的时候可以再加载这个任务。任务从保存到再加载的过程就是一次上下文切换。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="上下文切换" scheme="http://yoursite.com/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
    
      <category term="死锁" scheme="http://yoursite.com/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
</feed>
