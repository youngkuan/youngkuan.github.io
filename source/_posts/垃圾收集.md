---
title: 垃圾收集(一)
date: 2019-01-12 11:50:08
tags:
    - 内存分配策略
    - 引用计数法
    - 可达性算法
categories: 深入理解Java虚拟机
---

# 垃圾收集
垃圾回收需要关注的事情：  
1. 哪些内存需要回收？ Java堆和方法区
2. 什么时候回收？
3. 如何回收？  

java内存运行时各个区域，其中程序计数器、java虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地进行出栈和入栈操作。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收器所关注的就是这部分内存。

## 对象存活判断

### 引用计数法（Reference Counting）
算法描述：给对象中添加一个引用计数器，每当有一个引用指向这个对象，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器值为0的对象就不可能再被使用。  
引用计数法存在一个问题：它很难解决对象之间的相互循环引用问题，举个例子，示例代码如下。对象```objA```和```objB```都有字段```instance```，赋值```objA.instance = objB```及```objB.instance = objA```，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致引用计数器值都不为0，于是引用计数算法无法通知GC收集器回收它们。
```
/**
 * 对象objA和objB存在相互引用
 * @author yangkuan
 */
public class ReferenceCounteringGC {
    public Object instance = null;

    private static final int _1MB = 1024 * 1024;
    /**
     * 这个成员变量的意义是通过其占用的内存，通过GC日志查看对象是否被回收
     */
    private byte[] bigSize = new byte[2 * _1MB];

    public static void testGC(){
        ReferenceCounteringGC objA = new ReferenceCounteringGC();
        ReferenceCounteringGC objB = new ReferenceCounteringGC();
        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        // 假设此处发生垃圾回收，如果回收算法是引用计数法，那么objA和objB将不会被回收
        System.gc();
    }
}
```

### 可达性分析算法（Reachability Analysis）

#### 算法描述
这个算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（即该对象到GC Roots不可达）时，则证明这个对象不可用。那这些不可达的对象就可以判定为可回收对象。
可作为GC Roots的对象包括以下几种：  
- 虚拟机栈（栈帧中的本地变量表）中引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中JNI（即Native方法）引用的对象。

#### 引用类型
1. **强引用（Strong Reference）**  
强引用就是指在程序代码之中普遍存在的，类似```Object obj = new Object()```这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
2. **软引用（Soft Reference）**  
软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收之后还没有足够的内存，那么程序就会抛出内存溢出异常。
3. **弱引用（Weak Reference）**  
弱引用也是用来描述非必须对象的，但是它的强度比软引用还要更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前。当垃圾收集器工作时，无论当内存是否足够，都会回收掉只被弱引用关联的对象。
4. **虚引用（Phantom Reference）**  
虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成威胁，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。


#### 对象的两次标记过程
1. 如果对象再进行可达性分析的时候发现其与```GC Roots```之间不可达，那么它将会被第一次标记并进行下一次筛选，筛选的条件是此对象是否有必要执行```finalize()```方法。当对象没有覆盖```finalize()```方法或者```finalize()```方法已经被虚拟机执行过，都会被认为没有必要执行。
2. 如果这个对象被虚拟机认为有必要执行```finalize()```方法，那么这个对象将会放置在一个叫```F-Queue```的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的```Finalizer```线程去执行它。如果对象想要拯救自己，那么覆盖```finalize()```方法在方法中重新将自身与引用链上的任意一个对象关联起来就可以避免自己被回收。

### 回收方法区

方法区（永久代）的垃圾回收主要包括两个部分：废弃常量和无用的类。
- 废弃常量指的是没有任何地方引用这个常量，这个常量会被系统清理出常量池；
- 无用的类需要同时满足以下三个条件：
> 1. 该类的所有实例都已经被回收，也就是```Java```堆中不存在该类的任何实例；
> 2. 加载该类的```ClassLoader```已经被回收；
> 3. 该类对应的```java.lang.Class```对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。


