---
title: 代理模式
date: 2019-04-08 16:01:31
tags: 
    - 动态代理
    - 静态代理
    - Java
categories: 设计模式
---

代理是一种设计模式，提供了对目标对象的间接访问方式，即通过代理访问目标对象。代理模式的作用：控制和管理访问。
<!-- more --> 
## 静态代理
在程序运行前就已经存在对应的代理类，那么这种代理方式就称之为静态代理。由于这种代理方式下的代理类往往是程序员自己在Java代码中定义的，当我们需求发生变化的时候，代理类以及目标类都需要进行修改维护，不够灵活。但是静态代理也有优点，就是在不对目标对象进行修改的前提下就可以对目标对象进行功能扩展和拦截。
下面举个简单的例子，在CS（客户端\服务器）主从结构的网络架构中，一般服务器会对客户端发送而来的请求进行过滤和记录，这个时候就可以使用代理类来实现上述功能。
1. 首先，我们定义服务端顶层接口：
```
 /**
  * 顶层接口，目标类和代理类都需要实现顶层接口
  */
interface ServerInterface{
    public void processRequest(String request);
}
```
2. 其次，定义服务类：

```
 /**
  * 目标类
  */
class Server implements ServerInterface{
    @Override
    public void processRequest(String request) {
        System.out.println("process request");
    }
}
```
3. 最后定义服务代理类，服务类和代理类都实现服务顶层接口：
```
/**
 * 代理类
 */
class ServerProxy implements ServerInterface{
    ServerInterface serverInterface;

    public ServerProxy(ServerInterface serverInterface) {
        this.serverInterface = serverInterface;
    }

    /**
        * 过滤来自客户端的不合理请求
        * @param request
        * @return
        */
    public boolean filter(String request){
        System.out.println("filter request");
        return true;
    }

    /**
        * 记录来自客户端的请求
        */
    public void logBefore(){
        System.out.println("log before");
    }

    /**
        * 记录返回给客户端的结果
        */
    public void logReturn(){
        System.out.println("log return");
    }

    @Override
    public void processRequest(String request) {
        logBefore();
        if(!filter(request)){
            serverInterface.processRequest(request);
        }
        logReturn();
    }
}
```
从上面可以看出，当我们的需求改变的时候，比如说我们不仅需要过滤请求、日志记录，还需要进行客户端登录时，那么就需要在代理类中添加登录服务器的方法`logIn()`，并且给`processRequest`方法中添加登录方法，而实际情况中服务器中处理请求的方法`processRequest`成千上万，这个时候程序员就需要给一个个`processRequest`方法添加`logIn`操作，可以看到修改和维护代码代价过大，代码也不够简洁。

## 动态代理
### JDK原生动态代理
动态代理中，代理类是在运行时通过Java中的反射机制动态生成的。有兴趣的可以去看看Java中`ProxyClassFactory`类以及`ProxyGenerator`类动态生成代理类的源码。

对于应用程序员而言，主要使用`InvocationHandler`类以及`Proxy.newProxyInstance()`实现动态代理。我们还是以上述客户端/服务器网络架构为例。

顶层的服务接口`ServerInterface`不变，目标类`Server`也不用改变，只用实现`InvocationHandler`接口如下：
```
/**
 * 日志记录类
 */
class Logger {
    /**
        * 记录来自客户端的请求
        */
    public void logBefore() {
        System.out.println("log before");
    }

    /**
        * 记录返回给客户端的结果
        */
    public void logReturn() {
        System.out.println("log return");
    }
}

/**
 * 动态代理
 */
class ServerDynamicProxy implements InvocationHandler {
    Object target;
    Object prozy;

    public ServerDynamicProxy(Object target, Object prozy) {
        this.target = target;
        this.prozy = prozy;
    }

    /**
    * 动态绑定，返回代理对象
    *
    * @return
    */
    public Object bind() {
        return Proxy.newProxyInstance(target.getClass().getClassLoader()
                , target.getClass().getInterfaces(), this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Class prozyClass = proxy.getClass();
        Method beforeMethod = prozyClass.getMethod("logBefore");
        Method returnMethod = prozyClass.getMethod("logReturn");

        beforeMethod.invoke(prozy);
        method.invoke(this.target, args);
        returnMethod.invoke(prozy);

        return null;
    }
}
```
以上就是动态代理的使用，当测试的时候只需要在主函数中调用`bind()`方法返回代理类就可以了，当然需要进行强制类型转换，从`Object`转换成目标类。  
如果想看见动态代理生成的代理类，可以使用`System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true"); `

### CGLIB动态代理
CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理，所以当目标类没有实现接口时，就无法使用JDK代理，只能使用CGLIB实现动态代理。  
示例代码如下：
```
/**
 * 目标类
 */
public class Server {

    public void processRequest(String request) {
        System.out.println("process request");
    }
}

/**
 * 代理类
 */
public class ServerMethodInterceptor implements MethodInterceptor {

    private Object target;//业务类对象，供代理方法中进行真正的业务方法调用

    public ServerMethodInterceptor(Object target) {
        this.target = target;
    }

    //相当于JDK动态代理中的绑定
    public Object getInstance() {
        Enhancer enhancer = new Enhancer(); //创建加强器，用来创建动态代理类
        enhancer.setSuperclass(this.target.getClass());  //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）
        //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦
        enhancer.setCallback(this);
        // 创建动态代理类对象并返回
        return enhancer.create();
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        // log before
        System.out.println("log before");
        Object result = methodProxy.invokeSuper(o,objects);
        // log return
        System.out.println("log return");
        return result;
    }
}

```